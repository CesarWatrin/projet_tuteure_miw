/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@babel/runtime/regenerator/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/runtime/regenerator/index.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! regenerator-runtime */ \"./node_modules/regenerator-runtime/runtime.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3IvaW5kZXguanM/YTM0YSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxnSEFBK0MiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3IvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJyZWdlbmVyYXRvci1ydW50aW1lXCIpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/regenerator/index.js\n");

/***/ }),

/***/ "./resources/js/map.js":
/*!*****************************!*\
  !*** ./resources/js/map.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/regenerator */ \"./node_modules/@babel/runtime/regenerator/index.js\");\n/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var leaflet_markercluster__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! leaflet.markercluster */ \"./node_modules/leaflet.markercluster/dist/leaflet.markercluster-src.js\");\n/* harmony import */ var leaflet_markercluster__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(leaflet_markercluster__WEBPACK_IMPORTED_MODULE_1__);\n\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\n\nvar carte = L.map('map', {\n  center: [46.3630104, 2.9846608],\n  zoom: 5,\n\n  /*attributionControl : false,*/\n  zoomControl: false\n});\nL.tileLayer('https://{s}.tile.osm.org/{z}/{x}/{y}.png', {\n  attribution: '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors'\n}).addTo(carte);\nL.control.zoom({\n  position: 'bottomright'\n}).addTo(carte);\nvar markers = L.markerClusterGroup({\n  iconCreateFunction: function iconCreateFunction(cluster) {\n    return L.divIcon({\n      html: cluster.getChildCount(),\n      className: 'mycluster',\n      iconSize: null\n    });\n  }\n}).addTo(carte); //pour les tests :\n\ncarte.setView([44.544606, 6.077989], 14, {\n  animation: true\n});\nnearStores([6.077989, 44.544606]);\nvar popup = document.getElementsByClassName('popup')[0];\ncarte.addEventListener('click', function () {\n  autocomplete.innerHTML = '';\n\n  if (popup.classList[1] === 'active') {\n    popup.classList.value = 'popup';\n  }\n\n  switchFilter();\n});\nvar bouton_filter = document.getElementsByClassName('filter')[0];\nvar filter_cancel = document.getElementById('filter_cancel');\nbouton_filter.addEventListener('click', function () {\n  if (filter_cancel.getAttribute('xlink:href') == 'images/sprite.svg#filter_cancel') {\n    popup.classList.value = 'popup';\n  }\n\n  switchFilter();\n});\n\nfunction switchFilter() {\n  if (popup.classList[1] === 'active') {\n    filter_cancel.setAttribute('xlink:href', 'images/sprite.svg#filter_cancel');\n  } else {\n    filter_cancel.setAttribute('xlink:href', 'images/sprite.svg#filter');\n  }\n}\n\nvar bouton_emptySearch = document.getElementsByClassName('emptySearch')[0];\nbouton_emptySearch.addEventListener('click', function () {\n  inputSearch.value = '';\n  autocomplete.innerHTML = '';\n});\n\nfunction distance(lat1, lon1, lat2, lon2, unit) {\n  if (lat1 == lat2 && lon1 == lon2) {\n    return 0;\n  } else {\n    var radlat1 = Math.PI * lat1 / 180;\n    var radlat2 = Math.PI * lat2 / 180;\n    var theta = lon1 - lon2;\n    var radtheta = Math.PI * theta / 180;\n    var dist = Math.sin(radlat1) * Math.sin(radlat2) + Math.cos(radlat1) * Math.cos(radlat2) * Math.cos(radtheta);\n\n    if (dist > 1) {\n      dist = 1;\n    }\n\n    dist = Math.acos(dist);\n    dist = dist * 180 / Math.PI;\n    dist = dist * 60 * 1.1515;\n\n    if (unit == \"K\") {\n      dist = dist * 1.609344;\n    }\n\n    if (unit == \"N\") {\n      dist = dist * 0.8684;\n    }\n\n    return dist;\n  }\n}\n\nfunction formatTel(ndt) {\n  if (isNaN(ndt * 1)) {\n    return false;\n  } else {\n    ndt = ndt.toString();\n  }\n\n  var newTel = \"\";\n  var count = 0;\n\n  for (var i = 0; i != ndt.length; i++) {\n    switch (count) {\n      case 0:\n        newTel += ndt.charAt(i);\n        count++;\n        break;\n\n      case 1:\n        newTel += ndt.charAt(i);\n        count++;\n        break;\n\n      case 2:\n        newTel += \" \" + ndt.charAt(i);\n        count = 1;\n        break;\n    }\n  }\n\n  return newTel;\n}\n\nvar markerRestaurant = L.icon({\n  iconUrl: 'images/icon_cat/restaurant@2x.png',\n  iconRetinaUrl: 'images/icon_cat/restaurant@3x.png',\n  iconSize: [25, 35]\n});\nvar markerMagasin = L.icon({\n  iconUrl: 'images/icon_cat/magasin@2x.png',\n  iconRetinaUrl: 'images/icon_cat/magasin@3x.png',\n  iconSize: [25, 35]\n});\nvar markerBoucherie = L.icon({\n  iconUrl: 'images/icon_cat/boucherie@2x.png',\n  iconRetinaUrl: 'images/icon_cat/boucherie@3x.png',\n  iconSize: [25, 35]\n});\nvar markerFruits_legumes = L.icon({\n  iconUrl: 'images/icon_cat/fruits_legumes@2x.png',\n  iconRetinaUrl: 'images/icon_cat/fruits_legumes@3x.png',\n  iconSize: [25, 35]\n});\nvar markerDebit_boissons = L.icon({\n  iconUrl: 'images/icon_cat/debit_boissons@2x.png',\n  iconRetinaUrl: 'images/icon_cat/debit_boissons@3x.png',\n  iconSize: [25, 35]\n});\nvar markerMagasin_vetements = L.icon({\n  iconUrl: 'images/icon_cat/magasin_vetements@2x.png',\n  iconRetinaUrl: 'images/icon_cat/magasin_vetements@3x.png',\n  iconSize: [25, 35]\n});\nvar markerCulture = L.icon({\n  iconUrl: 'images/icon_cat/culture@2x.png',\n  iconRetinaUrl: 'images/icon_cat/culture@3x.png',\n  iconSize: [25, 35]\n});\n\nfunction nearStores(_x) {\n  return _nearStores.apply(this, arguments);\n}\n\nfunction _nearStores() {\n  _nearStores = _asyncToGenerator( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default().mark(function _callee(coord) {\n    var lat, lon, response, stores;\n    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            markers.clearLayers();\n            lat = coord[1];\n            lon = coord[0];\n            _context.next = 5;\n            return fetch(\"\".concat(window.location.origin, \"/api/stores?lat=\").concat(lat, \"&lon=\").concat(lon));\n\n          case 5:\n            response = _context.sent;\n            _context.next = 8;\n            return response.json();\n\n          case 8:\n            stores = _context.sent;\n            console.log(stores);\n            stores.forEach(function (store) {\n              if (store.category_id == 1) {\n                var marker = L.marker([store.lat, store.lon], {\n                  icon: markerRestaurant\n                }).bindTooltip(store.name, {\n                  permanent: false,\n                  offset: L.point(0, -16),\n                  direction: 'top',\n                  opacity: 0.8\n                });\n              } else if (store.category_id == 2) {\n                var marker = L.marker([store.lat, store.lon], {\n                  icon: markerMagasin\n                }).bindTooltip(store.name, {\n                  permanent: false,\n                  offset: L.point(0, -16),\n                  direction: 'top',\n                  opacity: 0.8\n                });\n              } else if (store.category_id == 3) {\n                var marker = L.marker([store.lat, store.lon], {\n                  icon: markerBoucherie\n                }).bindTooltip(store.name, {\n                  permanent: false,\n                  offset: L.point(0, -16),\n                  direction: 'top',\n                  opacity: 0.8\n                });\n              } else if (store.category_id == 4) {\n                var marker = L.marker([store.lat, store.lon], {\n                  icon: markerFruits_legumes\n                }).bindTooltip(store.name, {\n                  permanent: false,\n                  offset: L.point(0, -16),\n                  direction: 'top',\n                  opacity: 0.8\n                });\n              } else if (store.category_id == 5) {\n                var marker = L.marker([store.lat, store.lon], {\n                  icon: markerDebit_boissons\n                }).bindTooltip(store.name, {\n                  permanent: false,\n                  offset: L.point(0, -16),\n                  direction: 'top',\n                  opacity: 0.8\n                });\n              } else if (store.category_id == 6) {\n                var marker = L.marker([store.lat, store.lon], {\n                  icon: markerMagasin_vetements\n                }).bindTooltip(store.name, {\n                  permanent: false,\n                  offset: L.point(0, -16),\n                  direction: 'top',\n                  opacity: 0.8\n                });\n              } else if (store.category_id == 7) {\n                var marker = L.marker([store.lat, store.lon], {\n                  icon: markerCulture\n                }).bindTooltip(store.name, {\n                  permanent: false,\n                  offset: L.point(0, -16),\n                  direction: 'top',\n                  opacity: 0.8\n                });\n              }\n\n              marker.addEventListener('click', function () {\n                var store_name = document.getElementById('store_name');\n                var store_distance = document.getElementById('store_distance');\n                var store_score = document.getElementById('store_score');\n                var store_address = document.getElementById('store_address');\n                var store_delivery = document.getElementById('store_delivery');\n                var store_desc = document.getElementById('store_desc');\n                var store_schedule = document.getElementById('store_schedule');\n                var store_tel = document.getElementById('store_tel');\n                var store_mail = document.getElementById('store_mail');\n                var store_website = document.getElementById('store_website');\n                var delivery_check = document.getElementById('delivery_check');\n                var store_id = document.getElementById('store_id');\n                var dist = distance(lat, lon, store.lat, store.lon, 'K');\n                dist = dist.toFixed(1);\n                store_name.textContent = store.name;\n                store_distance.textContent = \"\\xA0\\xE0 \" + dist + 'km';\n                store_score.textContent = \"\\xA04/5\";\n\n                if (store.city.zip.length < 5) {\n                  store.city.zip = '0' + store.city.zip;\n                }\n\n                store_address.textContent = store.address1 + ', ' + store.city.zip + ' ' + store.city.name;\n\n                if (store.delivery === 1) {\n                  delivery_check.classList.value = 'fas fa-check';\n                  store_delivery.textContent = 'Livraison possible';\n                } else {\n                  delivery_check.classList.value = 'fas fa-times';\n                  store_delivery.textContent = 'Livraison indisponible';\n                }\n\n                store_desc.textContent = store.description;\n                store_schedule.textContent = store.opening_hours;\n                var phonenumber = formatTel(store.phonenumber);\n                store_tel.textContent = phonenumber;\n                store_mail.textContent = store.email;\n                store_website.href = store.website;\n                store_id.textContent = store.id;\n                var macyofavoris = localStorage.getItem('macyofavoris');\n                var heart_fav = document.getElementById('heart_fav');\n                var exist = 0;\n\n                if (macyofavoris !== null) {\n                  macyofavoris = [macyofavoris];\n                  macyofavoris = macyofavoris[0].split([',']);\n\n                  for (var i = 0; i < macyofavoris.length; i++) {\n                    if (macyofavoris[i] == store.id) {\n                      exist++;\n                    }\n                  }\n\n                  if (exist !== 0) {\n                    heart_fav.setAttribute('xlink:href', 'images/sprite.svg#heart_full');\n                  } else {\n                    heart_fav.setAttribute('xlink:href', 'images/sprite.svg#heart_empty');\n                  }\n                } else {\n                  heart_fav.setAttribute('xlink:href', 'images/sprite.svg#heart_empty');\n                }\n\n                if (popup.classList[1] === undefined) {\n                  popup.classList.value = 'popup active';\n                }\n\n                switchFilter();\n                var popup_gmaps = document.getElementById('popup_gmaps');\n                popup_gmaps.href = 'https://www.google.com/maps/search/?api=1&query=' + store.name + '+' + store.city.name;\n              });\n              marker.addTo(markers);\n            });\n\n          case 11:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _nearStores.apply(this, arguments);\n}\n\nvar buttonSearch = document.getElementById('buttonSearch');\nbuttonSearch.addEventListener('click', recherche);\nvar inputSearch = document.getElementById('inputSearch');\ninputSearch.addEventListener('input', chargeVilles);\ninputSearch.addEventListener('keyup', function (e) {\n  if (e.code === 'Enter') recherche();\n});\ninputSearch.addEventListener('click', function () {\n  popup.classList.value = 'popup';\n  switchFilter();\n});\nvar autocomplete = document.getElementById('autocomplete');\n\nfunction chargeVilles() {\n  if (inputSearch.value.replace(/\\s+/, '').length) {\n    $.ajax({\n      url: \"https://api-adresse.data.gouv.fr/search/?q=\" + inputSearch.value + \"&limit=10\",\n      success: function success(data) {\n        recupVilles(data.features);\n      },\n      error: function error(data) {\n        console.log('error when search');\n      }\n    });\n  } else {\n    autocomplete.innerHTML = '';\n  }\n}\n\nfunction recupVilles(adresse) {\n  var option = '';\n\n  for (var i = 0; i < adresse.length; i++) {\n    option += '<p onclick=\"setAdresse(this);\">' + adresse[i].properties.label + '</p>';\n  }\n\n  autocomplete.innerHTML = option;\n}\n\nfunction setAdresse(elem) {\n  inputSearch.value = elem.textContent;\n  autocomplete.innerHTML = '';\n}\n\nwindow.setAdresse = setAdresse;\nvar markerSearch = L.icon({\n  iconUrl: 'images/icon_cat/recherche@2x.png',\n  iconRetinaUrl: 'images/icon_cat/recherche@3x.png',\n  iconSize: [25, 35]\n});\nvar searchLayer = L.marker([0, 0], {\n  icon: markerSearch\n});\nvar markerPosition = L.icon({\n  iconUrl: 'images/icon_cat/position@2x.png',\n  iconRetinaUrl: 'images/icon_cat/position@3x.png',\n  iconSize: [25, 35]\n});\n\nfunction recherche() {\n  autocomplete.innerHTML = '';\n  carte.removeLayer(searchLayer);\n\n  if (inputSearch.value != '') {\n    window.history.replaceState({\n      id: 'search'\n    }, 'Carte | MAC-YO', '/map?q=' + inputSearch.value);\n    $.ajax({\n      url: \"https://api-adresse.data.gouv.fr/search/?q=\" + inputSearch.value + \"&limit=1\",\n      success: function success(data) {\n        var lat = data.features[0].geometry.coordinates[0];\n        var lon = data.features[0].geometry.coordinates[1];\n        carte.setView([lon, lat], 14, {\n          animation: true\n        });\n        searchLayer = L.marker([lon, lat], {\n          icon: markerSearch\n        }).bindTooltip(data.features[0].properties.label, {\n          permanent: false,\n          offset: L.point(0, -16),\n          direction: 'top',\n          opacity: 0.8\n        }).addTo(carte);\n        nearStores([lat, lon]);\n      },\n      error: function error(data) {\n        console.log('error when search');\n      }\n    });\n  }\n}\n\nfunction userPosition() {\n  if (\"geolocation\" in navigator) {\n    navigator.geolocation.getCurrentPosition(function (position) {\n      L.marker([position.coords.latitude, position.coords.longitude], {\n        icon: markerPosition\n      }).addTo(markers); // carte.setView([position.coords.latitude, position.coords.longitude], 14, { animation: true });\n    });\n  } else {\n    /* la géolocalisation n'est pas disponible */\n    alert('Votre géolocalisation est indisponible');\n  }\n}\n\nuserPosition();\nvar url_string = window.location.href;\nvar url = new URL(url_string);\nvar lat = url.searchParams.get(\"lat\");\nvar lon = url.searchParams.get(\"lon\");\n\nif (lat !== null && lon !== null) {\n  carte.setView([lat, lon], 20, {\n    animation: true\n  });\n  nearStores([lon, lat]);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvbWFwLmpzPzk5NDkiXSwibmFtZXMiOlsiY2FydGUiLCJMIiwibWFwIiwiY2VudGVyIiwiem9vbSIsInpvb21Db250cm9sIiwidGlsZUxheWVyIiwiYXR0cmlidXRpb24iLCJhZGRUbyIsImNvbnRyb2wiLCJwb3NpdGlvbiIsIm1hcmtlcnMiLCJtYXJrZXJDbHVzdGVyR3JvdXAiLCJpY29uQ3JlYXRlRnVuY3Rpb24iLCJjbHVzdGVyIiwiZGl2SWNvbiIsImh0bWwiLCJnZXRDaGlsZENvdW50IiwiY2xhc3NOYW1lIiwiaWNvblNpemUiLCJzZXRWaWV3IiwiYW5pbWF0aW9uIiwibmVhclN0b3JlcyIsInBvcHVwIiwiZG9jdW1lbnQiLCJnZXRFbGVtZW50c0J5Q2xhc3NOYW1lIiwiYWRkRXZlbnRMaXN0ZW5lciIsImF1dG9jb21wbGV0ZSIsImlubmVySFRNTCIsImNsYXNzTGlzdCIsInZhbHVlIiwic3dpdGNoRmlsdGVyIiwiYm91dG9uX2ZpbHRlciIsImZpbHRlcl9jYW5jZWwiLCJnZXRFbGVtZW50QnlJZCIsImdldEF0dHJpYnV0ZSIsInNldEF0dHJpYnV0ZSIsImJvdXRvbl9lbXB0eVNlYXJjaCIsImlucHV0U2VhcmNoIiwiZGlzdGFuY2UiLCJsYXQxIiwibG9uMSIsImxhdDIiLCJsb24yIiwidW5pdCIsInJhZGxhdDEiLCJNYXRoIiwiUEkiLCJyYWRsYXQyIiwidGhldGEiLCJyYWR0aGV0YSIsImRpc3QiLCJzaW4iLCJjb3MiLCJhY29zIiwiZm9ybWF0VGVsIiwibmR0IiwiaXNOYU4iLCJ0b1N0cmluZyIsIm5ld1RlbCIsImNvdW50IiwiaSIsImxlbmd0aCIsImNoYXJBdCIsIm1hcmtlclJlc3RhdXJhbnQiLCJpY29uIiwiaWNvblVybCIsImljb25SZXRpbmFVcmwiLCJtYXJrZXJNYWdhc2luIiwibWFya2VyQm91Y2hlcmllIiwibWFya2VyRnJ1aXRzX2xlZ3VtZXMiLCJtYXJrZXJEZWJpdF9ib2lzc29ucyIsIm1hcmtlck1hZ2FzaW5fdmV0ZW1lbnRzIiwibWFya2VyQ3VsdHVyZSIsImNvb3JkIiwiY2xlYXJMYXllcnMiLCJsYXQiLCJsb24iLCJmZXRjaCIsIndpbmRvdyIsImxvY2F0aW9uIiwib3JpZ2luIiwicmVzcG9uc2UiLCJqc29uIiwic3RvcmVzIiwiY29uc29sZSIsImxvZyIsImZvckVhY2giLCJzdG9yZSIsImNhdGVnb3J5X2lkIiwibWFya2VyIiwiYmluZFRvb2x0aXAiLCJuYW1lIiwicGVybWFuZW50Iiwib2Zmc2V0IiwicG9pbnQiLCJkaXJlY3Rpb24iLCJvcGFjaXR5Iiwic3RvcmVfbmFtZSIsInN0b3JlX2Rpc3RhbmNlIiwic3RvcmVfc2NvcmUiLCJzdG9yZV9hZGRyZXNzIiwic3RvcmVfZGVsaXZlcnkiLCJzdG9yZV9kZXNjIiwic3RvcmVfc2NoZWR1bGUiLCJzdG9yZV90ZWwiLCJzdG9yZV9tYWlsIiwic3RvcmVfd2Vic2l0ZSIsImRlbGl2ZXJ5X2NoZWNrIiwic3RvcmVfaWQiLCJ0b0ZpeGVkIiwidGV4dENvbnRlbnQiLCJjaXR5IiwiemlwIiwiYWRkcmVzczEiLCJkZWxpdmVyeSIsImRlc2NyaXB0aW9uIiwib3BlbmluZ19ob3VycyIsInBob25lbnVtYmVyIiwiZW1haWwiLCJocmVmIiwid2Vic2l0ZSIsImlkIiwibWFjeW9mYXZvcmlzIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsImhlYXJ0X2ZhdiIsImV4aXN0Iiwic3BsaXQiLCJ1bmRlZmluZWQiLCJwb3B1cF9nbWFwcyIsImJ1dHRvblNlYXJjaCIsInJlY2hlcmNoZSIsImNoYXJnZVZpbGxlcyIsImUiLCJjb2RlIiwicmVwbGFjZSIsIiQiLCJhamF4IiwidXJsIiwic3VjY2VzcyIsImRhdGEiLCJyZWN1cFZpbGxlcyIsImZlYXR1cmVzIiwiZXJyb3IiLCJhZHJlc3NlIiwib3B0aW9uIiwicHJvcGVydGllcyIsImxhYmVsIiwic2V0QWRyZXNzZSIsImVsZW0iLCJtYXJrZXJTZWFyY2giLCJzZWFyY2hMYXllciIsIm1hcmtlclBvc2l0aW9uIiwicmVtb3ZlTGF5ZXIiLCJoaXN0b3J5IiwicmVwbGFjZVN0YXRlIiwiZ2VvbWV0cnkiLCJjb29yZGluYXRlcyIsInVzZXJQb3NpdGlvbiIsIm5hdmlnYXRvciIsImdlb2xvY2F0aW9uIiwiZ2V0Q3VycmVudFBvc2l0aW9uIiwiY29vcmRzIiwibGF0aXR1ZGUiLCJsb25naXR1ZGUiLCJhbGVydCIsInVybF9zdHJpbmciLCJVUkwiLCJzZWFyY2hQYXJhbXMiLCJnZXQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFFQSxJQUFJQSxLQUFLLEdBQUdDLENBQUMsQ0FBQ0MsR0FBRixDQUFNLEtBQU4sRUFBYTtBQUFDQyxRQUFNLEVBQUUsQ0FBQyxVQUFELEVBQWEsU0FBYixDQUFUO0FBQWlDQyxNQUFJLEVBQUUsQ0FBdkM7O0FBQTBDO0FBQWdDQyxhQUFXLEVBQUU7QUFBdkYsQ0FBYixDQUFaO0FBQ0FKLENBQUMsQ0FBQ0ssU0FBRixDQUFZLDBDQUFaLEVBQXdEO0FBQUNDLGFBQVcsRUFBRTtBQUFkLENBQXhELEVBQW1KQyxLQUFuSixDQUF5SlIsS0FBeko7QUFDQUMsQ0FBQyxDQUFDUSxPQUFGLENBQVVMLElBQVYsQ0FBZTtBQUFDTSxVQUFRLEVBQUM7QUFBVixDQUFmLEVBQXlDRixLQUF6QyxDQUErQ1IsS0FBL0M7QUFDQSxJQUFJVyxPQUFPLEdBQUdWLENBQUMsQ0FBQ1csa0JBQUYsQ0FBcUI7QUFDL0JDLG9CQUFrQixFQUFFLDRCQUFTQyxPQUFULEVBQWtCO0FBQ2xDLFdBQU9iLENBQUMsQ0FBQ2MsT0FBRixDQUFVO0FBQ2JDLFVBQUksRUFBRUYsT0FBTyxDQUFDRyxhQUFSLEVBRE87QUFFYkMsZUFBUyxFQUFFLFdBRkU7QUFHYkMsY0FBUSxFQUFFO0FBSEcsS0FBVixDQUFQO0FBS0g7QUFQOEIsQ0FBckIsRUFRWFgsS0FSVyxDQVFMUixLQVJLLENBQWQsQyxDQVVBOztBQUNBQSxLQUFLLENBQUNvQixPQUFOLENBQWMsQ0FBQyxTQUFELEVBQVksUUFBWixDQUFkLEVBQXFDLEVB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QUMsWUFBVSxDQUFDLENBQUN1RCxHQUFELEVBQU1ELEdBQU4sQ0FBRCxDQUFWO0FBQ0YiLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvbWFwLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICdsZWFmbGV0Lm1hcmtlcmNsdXN0ZXInO1xyXG5cclxubGV0IGNhcnRlID0gTC5tYXAoJ21hcCcsIHtjZW50ZXI6IFs0Ni4zNjMwMTA0LCAyLjk4NDY2MDhdLHpvb206IDUsIC8qYXR0cmlidXRpb25Db250cm9sIDogZmFsc2UsKi8gem9vbUNvbnRyb2w6IGZhbHNlfSk7XHJcbkwudGlsZUxheWVyKCdodHRwczovL3tzfS50aWxlLm9zbS5vcmcve3p9L3t4fS97eX0ucG5nJywge2F0dHJpYnV0aW9uOiAnJmNvcHk7IDxhIGhyZWY9XCJodHRwOi8vb3NtLm9yZy9jb3B5cmlnaHRcIj5PcGVuU3RyZWV0TWFwPC9hPiBjb250cmlidXRvcnMnfSkuYWRkVG8oY2FydGUpO1xyXG5MLmNvbnRyb2wuem9vbSh7cG9zaXRpb246J2JvdHRvbXJpZ2h0J30pLmFkZFRvKGNhcnRlKTtcclxubGV0IG1hcmtlcnMgPSBMLm1hcmtlckNsdXN0ZXJHcm91cCh7XHJcbiAgICBpY29uQ3JlYXRlRnVuY3Rpb246IGZ1bmN0aW9uKGNsdXN0ZXIpIHtcclxuICAgICAgICByZXR1cm4gTC5kaXZJY29uKHtcclxuICAgICAgICAgICAgaHRtbDogY2x1c3Rlci5nZXRDaGlsZENvdW50KCksXHJcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ215Y2x1c3RlcicsXHJcbiAgICAgICAgICAgIGljb25TaXplOiBudWxsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn0pLmFkZFRvKGNhcnRlKTtcclxuXHJcbi8vcG91ciBsZXMgdGVzdHMgOlxyXG5jYXJ0ZS5zZXRWaWV3KFs0NC41NDQ2MDYsIDYuMDc3OTg5XSwgMTQsIHsgYW5pbWF0aW9uOiB0cnVlIH0pO1xyXG5uZWFyU3RvcmVzKFs2LjA3Nzk4OSwgNDQuNTQ0NjA2XSk7XHJcblxyXG52YXIgcG9wdXAgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdwb3B1cCcpWzBdO1xyXG5cclxuY2FydGUuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XHJcbiAgIGF1dG9jb21wbGV0ZS5pbm5lckhUTUwgPSAnJztcclxuICAgaWYgKHBvcHVwLmNsYXNzTGlzdFsxXSA9PT0gJ2FjdGl2ZScpIHtcclxuICAgICAgcG9wdXAuY2xhc3NMaXN0LnZhbHVlID0gJ3BvcHVwJztcclxuICAgfVxyXG4gICBzd2l0Y2hGaWx0ZXIoKTtcclxufSk7XHJcblxyXG52YXIgYm91dG9uX2ZpbHRlciA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2ZpbHRlcicpWzBdO1xyXG52YXIgZmlsdGVyX2NhbmNlbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdmaWx0ZXJfY2FuY2VsJyk7XHJcblxyXG5ib3V0b25fZmlsdGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xyXG4gICBpZiAoZmlsdGVyX2NhbmNlbC5nZXRBdHRyaWJ1dGUoJ3hsaW5rOmhyZWYnKSA9PSAnaW1hZ2VzL3Nwcml0ZS5zdmcjZmlsdGVyX2NhbmNlbCcpIHtcclxuICAgICAgcG9wdXAuY2xhc3NMaXN0LnZhbHVlID0gJ3BvcHVwJztcclxuICAgfVxyXG4gICBzd2l0Y2hGaWx0ZXIoKTtcclxufSk7XHJcblxyXG5mdW5jdGlvbiBzd2l0Y2hGaWx0ZXIoKSB7XHJcbiAgIGlmIChwb3B1cC5jbGFzc0xpc3RbMV0gPT09ICdhY3RpdmUnKSB7XHJcbiAgICAgIGZpbHRlcl9jYW5jZWwuc2V0QXR0cmlidXRlKCd4bGluazpocmVmJywgJ2ltYWdlcy9zcHJpdGUuc3ZnI2ZpbHRlcl9jYW5jZWwnKTtcclxuICAgfSBlbHNlIHtcclxuICAgICAgZmlsdGVyX2NhbmNlbC5zZXRBdHRyaWJ1dGUoJ3hsaW5rOmhyZWYnLCAnaW1hZ2VzL3Nwcml0ZS5zdmcjZmlsdGVyJyk7XHJcbiAgIH1cclxufVxyXG5cclxudmFyIGJvdXRvbl9lbXB0eVNlYXJjaCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2VtcHR5U2VhcmNoJylbMF07XHJcbmJvdXRvbl9lbXB0eVNlYXJjaC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsKCkgPT4ge1xyXG4gICBpbnB1dFNlYXJjaC52YWx1ZSA9ICcnO1xyXG4gICBhdXRvY29tcGxldGUuaW5uZXJIVE1MID0gJyc7XHJcbn0pO1xyXG5cclxuZnVuY3Rpb24gZGlzdGFuY2UobGF0MSwgbG9uMSwgbGF0MiwgbG9uMiwgdW5pdCkge1xyXG4gICBpZiAoKGxhdDEgPT0gbGF0MikgJiYgKGxvbjEgPT0gbG9uMikpIHtcclxuICAgICAgcmV0dXJuIDA7XHJcbiAgIH1cclxuICAgZWxzZSB7XHJcbiAgICAgIHZhciByYWRsYXQxID0gTWF0aC5QSSAqIGxhdDEvMTgwO1xyXG4gICAgICB2YXIgcmFkbGF0MiA9IE1hdGguUEkgKiBsYXQyLzE4MDtcclxuICAgICAgdmFyIHRoZXRhID0gbG9uMS1sb24yO1xyXG4gICAgICB2YXIgcmFkdGhldGEgPSBNYXRoLlBJICogdGhldGEvMTgwO1xyXG4gICAgICB2YXIgZGlzdCA9IE1hdGguc2luKHJhZGxhdDEpICogTWF0aC5zaW4ocmFkbGF0MikgKyBNYXRoLmNvcyhyYWRsYXQxKSAqIE1hdGguY29zKHJhZGxhdDIpICogTWF0aC5jb3MocmFkdGhldGEpO1xyXG4gICAgICBpZiAoZGlzdCA+IDEpIHtcclxuICAgICAgICAgZGlzdCA9IDE7XHJcbiAgICAgIH1cclxuICAgICAgZGlzdCA9IE1hdGguYWNvcyhkaXN0KTtcclxuICAgICAgZGlzdCA9IGRpc3QgKiAxODAvTWF0aC5QSTtcclxuICAgICAgZGlzdCA9IGRpc3QgKiA2MCAqIDEuMTUxNTtcclxuICAgICAgaWYgKHVuaXQ9PVwiS1wiKSB7IGRpc3QgPSBkaXN0ICogMS42MDkzNDQgfVxyXG4gICAgICBpZiAodW5pdD09XCJOXCIpIHsgZGlzdCA9IGRpc3QgKiAwLjg2ODQgfVxyXG4gICAgICByZXR1cm4gZGlzdDtcclxuICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBmb3JtYXRUZWwobmR0KSB7XHJcbiAgIGlmKGlzTmFOKG5kdCoxKSkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgIH0gZWxzZSB7XHJcbiAgICAgIG5kdCA9IG5kdC50b1N0cmluZygpO1xyXG4gICB9XHJcbiAgIHZhciBuZXdUZWwgPSBcIlwiO1xyXG4gICB2YXIgY291bnQgPSAwO1xyXG4gICBmb3IodmFyIGk9MDsgaSE9bmR0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHN3aXRjaChjb3VudCkge1xyXG4gICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgIG5ld1RlbCs9bmR0LmNoYXJBdChpKTtcclxuICAgICAgICAgY291bnQrKztcclxuICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgbmV3VGVsKz1uZHQuY2hhckF0KGkpO1xyXG4gICAgICAgICBjb3VudCsrO1xyXG4gICAgICAgICBicmVhaztcclxuICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICBuZXdUZWwrPVwiIFwiK25kdC5jaGFyQXQoaSk7XHJcbiAgICAgICAgIGNvdW50PTE7XHJcbiAgICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgIH1cclxuICAgcmV0dXJuIG5ld1RlbDtcclxufVxyXG5cclxudmFyIG1hcmtlclJlc3RhdXJhbnQgPSBMLmljb24oe1xyXG4gICBpY29uVXJsOiAnaW1hZ2VzL2ljb25fY2F0L3Jlc3RhdXJhbnRAMngucG5nJyxcclxuICAgaWNvblJldGluYVVybDogJ2ltYWdlcy9pY29uX2NhdC9yZXN0YXVyYW50QDN4LnBuZycsXHJcbiAgIGljb25TaXplOiAgICAgWzI1LCAzNV1cclxufSk7XHJcblxyXG52YXIgbWFya2VyTWFnYXNpbiA9IEwuaWNvbih7XHJcbiAgIGljb25Vcmw6ICdpbWFnZXMvaWNvbl9jYXQvbWFnYXNpbkAyeC5wbmcnLFxyXG4gICBpY29uUmV0aW5hVXJsOiAnaW1hZ2VzL2ljb25fY2F0L21hZ2FzaW5AM3gucG5nJyxcclxuICAgaWNvblNpemU6ICAgICBbMjUsIDM1XVxyXG59KTtcclxuXHJcbnZhciBtYXJrZXJCb3VjaGVyaWUgPSBMLmljb24oe1xyXG4gICBpY29uVXJsOiAnaW1hZ2VzL2ljb25fY2F0L2JvdWNoZXJpZUAyeC5wbmcnLFxyXG4gICBpY29uUmV0aW5hVXJsOiAnaW1hZ2VzL2ljb25fY2F0L2JvdWNoZXJpZUAzeC5wbmcnLFxyXG4gICBpY29uU2l6ZTogICAgIFsyNSwgMzVdXHJcbn0pO1xyXG5cclxudmFyIG1hcmtlckZydWl0c19sZWd1bWVzID0gTC5pY29uKHtcclxuICAgaWNvblVybDogJ2ltYWdlcy9pY29uX2NhdC9mcnVpdHNfbGVndW1lc0AyeC5wbmcnLFxyXG4gICBpY29uUmV0aW5hVXJsOiAnaW1hZ2VzL2ljb25fY2F0L2ZydWl0c19sZWd1bWVzQDN4LnBuZycsXHJcbiAgIGljb25TaXplOiAgICAgWzI1LCAzNV1cclxufSk7XHJcblxyXG52YXIgbWFya2VyRGViaXRfYm9pc3NvbnMgPSBMLmljb24oe1xyXG4gICBpY29uVXJsOiAnaW1hZ2VzL2ljb25fY2F0L2RlYml0X2JvaXNzb25zQDJ4LnBuZycsXHJcbiAgIGljb25SZXRpbmFVcmw6ICdpbWFnZXMvaWNvbl9jYXQvZGViaXRfYm9pc3NvbnNAM3gucG5nJyxcclxuICAgaWNvblNpemU6ICAgICBbMjUsIDM1XVxyXG59KTtcclxuXHJcbnZhciBtYXJrZXJNYWdhc2luX3ZldGVtZW50cyA9IEwuaWNvbih7XHJcbiAgIGljb25Vcmw6ICdpbWFnZXMvaWNvbl9jYXQvbWFnYXNpbl92ZXRlbWVudHNAMngucG5nJyxcclxuICAgaWNvblJldGluYVVybDogJ2ltYWdlcy9pY29uX2NhdC9tYWdhc2luX3ZldGVtZW50c0AzeC5wbmcnLFxyXG4gICBpY29uU2l6ZTogICAgIFsyNSwgMzVdXHJcbn0pO1xyXG5cclxudmFyIG1hcmtlckN1bHR1cmUgPSBMLmljb24oe1xyXG4gICBpY29uVXJsOiAnaW1hZ2VzL2ljb25fY2F0L2N1bHR1cmVAMngucG5nJyxcclxuICAgaWNvblJldGluYVVybDogJ2ltYWdlcy9pY29uX2NhdC9jdWx0dXJlQDN4LnBuZycsXHJcbiAgIGljb25TaXplOiAgICAgWzI1LCAzNV1cclxufSk7XHJcblxyXG5hc3luYyBmdW5jdGlvbiBuZWFyU3RvcmVzKGNvb3JkKSB7XHJcblxyXG4gICBtYXJrZXJzLmNsZWFyTGF5ZXJzKCk7XHJcblxyXG4gICBsZXQgbGF0ID0gY29vcmRbMV07XHJcbiAgIGxldCBsb24gPSBjb29yZFswXTtcclxuXHJcblxyXG4gICBsZXQgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHt3aW5kb3cubG9jYXRpb24ub3JpZ2lufS9hcGkvc3RvcmVzP2xhdD0ke2xhdH0mbG9uPSR7bG9ufWApO1xyXG4gICBsZXQgc3RvcmVzID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG5cclxuICAgY29uc29sZS5sb2coc3RvcmVzKTtcclxuXHJcbiAgIHN0b3Jlcy5mb3JFYWNoKChzdG9yZSkgPT4ge1xyXG4gICAgICBpZiAoc3RvcmUuY2F0ZWdvcnlfaWQgPT0gMSkge1xyXG4gICAgICAgICB2YXIgbWFya2VyID0gTC5tYXJrZXIoW3N0b3JlLmxhdCwgc3RvcmUubG9uXSwge2ljb246IG1hcmtlclJlc3RhdXJhbnR9KS5iaW5kVG9vbHRpcChcclxuICAgICAgICAgICAgc3RvcmUubmFtZVxyXG4gICAgICAgICAgICAse1xyXG4gICAgICAgICAgICAgICBwZXJtYW5lbnQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICBvZmZzZXQ6IEwucG9pbnQoMCwgLTE2KSxcclxuICAgICAgICAgICAgICAgZGlyZWN0aW9uOiAndG9wJyxcclxuICAgICAgICAgICAgICAgb3BhY2l0eTogMC44XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgKTtcclxuICAgICAgfSBlbHNlIGlmIChzdG9yZS5jYXRlZ29yeV9pZCA9PSAyKSB7XHJcbiAgICAgICAgIHZhciBtYXJrZXIgPSBMLm1hcmtlcihbc3RvcmUubGF0LCBzdG9yZS5sb25dLCB7aWNvbjogbWFya2VyTWFnYXNpbn0pLmJpbmRUb29sdGlwKFxyXG4gICAgICAgICAgICBzdG9yZS5uYW1lXHJcbiAgICAgICAgICAgICx7XHJcbiAgICAgICAgICAgICAgIHBlcm1hbmVudDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgIG9mZnNldDogTC5wb2ludCgwLCAtMTYpLFxyXG4gICAgICAgICAgICAgICBkaXJlY3Rpb246ICd0b3AnLFxyXG4gICAgICAgICAgICAgICBvcGFjaXR5OiAwLjhcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICApO1xyXG4gICAgICB9IGVsc2UgaWYgKHN0b3JlLmNhdGVnb3J5X2lkID09IDMpIHtcclxuICAgICAgICAgdmFyIG1hcmtlciA9IEwubWFya2VyKFtzdG9yZS5sYXQsIHN0b3JlLmxvbl0sIHtpY29uOiBtYXJrZXJCb3VjaGVyaWV9KS5iaW5kVG9vbHRpcChcclxuICAgICAgICAgICAgc3RvcmUubmFtZVxyXG4gICAgICAgICAgICAse1xyXG4gICAgICAgICAgICAgICBwZXJtYW5lbnQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICBvZmZzZXQ6IEwucG9pbnQoMCwgLTE2KSxcclxuICAgICAgICAgICAgICAgZGlyZWN0aW9uOiAndG9wJyxcclxuICAgICAgICAgICAgICAgb3BhY2l0eTogMC44XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgKTtcclxuICAgICAgfSBlbHNlIGlmIChzdG9yZS5jYXRlZ29yeV9pZCA9PSA0KSB7XHJcbiAgICAgICAgIHZhciBtYXJrZXIgPSBMLm1hcmtlcihbc3RvcmUubGF0LCBzdG9yZS5sb25dLCB7aWNvbjogbWFya2VyRnJ1aXRzX2xlZ3VtZXN9KS5iaW5kVG9vbHRpcChcclxuICAgICAgICAgICAgc3RvcmUubmFtZVxyXG4gICAgICAgICAgICAse1xyXG4gICAgICAgICAgICAgICBwZXJtYW5lbnQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICBvZmZzZXQ6IEwucG9pbnQoMCwgLTE2KSxcclxuICAgICAgICAgICAgICAgZGlyZWN0aW9uOiAndG9wJyxcclxuICAgICAgICAgICAgICAgb3BhY2l0eTogMC44XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgKTtcclxuICAgICAgfSBlbHNlIGlmIChzdG9yZS5jYXRlZ29yeV9pZCA9PSA1KSB7XHJcbiAgICAgICAgIHZhciBtYXJrZXIgPSBMLm1hcmtlcihbc3RvcmUubGF0LCBzdG9yZS5sb25dLCB7aWNvbjogbWFya2VyRGViaXRfYm9pc3NvbnN9KS5iaW5kVG9vbHRpcChcclxuICAgICAgICAgICAgc3RvcmUubmFtZVxyXG4gICAgICAgICAgICAse1xyXG4gICAgICAgICAgICAgICBwZXJtYW5lbnQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICBvZmZzZXQ6IEwucG9pbnQoMCwgLTE2KSxcclxuICAgICAgICAgICAgICAgZGlyZWN0aW9uOiAndG9wJyxcclxuICAgICAgICAgICAgICAgb3BhY2l0eTogMC44XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgKTtcclxuICAgICAgfSBlbHNlIGlmIChzdG9yZS5jYXRlZ29yeV9pZCA9PSA2KSB7XHJcbiAgICAgICAgIHZhciBtYXJrZXIgPSBMLm1hcmtlcihbc3RvcmUubGF0LCBzdG9yZS5sb25dLCB7aWNvbjogbWFya2VyTWFnYXNpbl92ZXRlbWVudHN9KS5iaW5kVG9vbHRpcChcclxuICAgICAgICAgICAgc3RvcmUubmFtZVxyXG4gICAgICAgICAgICAse1xyXG4gICAgICAgICAgICAgICBwZXJtYW5lbnQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICBvZmZzZXQ6IEwucG9pbnQoMCwgLTE2KSxcclxuICAgICAgICAgICAgICAgZGlyZWN0aW9uOiAndG9wJyxcclxuICAgICAgICAgICAgICAgb3BhY2l0eTogMC44XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgKTtcclxuICAgICAgfSBlbHNlIGlmIChzdG9yZS5jYXRlZ29yeV9pZCA9PSA3KSB7XHJcbiAgICAgICAgIHZhciBtYXJrZXIgPSBMLm1hcmtlcihbc3RvcmUubGF0LCBzdG9yZS5sb25dLCB7aWNvbjogbWFya2VyQ3VsdHVyZX0pLmJpbmRUb29sdGlwKFxyXG4gICAgICAgICAgICBzdG9yZS5uYW1lXHJcbiAgICAgICAgICAgICx7XHJcbiAgICAgICAgICAgICAgIHBlcm1hbmVudDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgIG9mZnNldDogTC5wb2ludCgwLCAtMTYpLFxyXG4gICAgICAgICAgICAgICBkaXJlY3Rpb246ICd0b3AnLFxyXG4gICAgICAgICAgICAgICBvcGFjaXR5OiAwLjhcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBtYXJrZXIuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XHJcbiAgICAgICAgIHZhciBzdG9yZV9uYW1lID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3N0b3JlX25hbWUnKTtcclxuICAgICAgICAgdmFyIHN0b3JlX2Rpc3RhbmNlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3N0b3JlX2Rpc3RhbmNlJyk7XHJcbiAgICAgICAgIHZhciBzdG9yZV9zY29yZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzdG9yZV9zY29yZScpO1xyXG4gICAgICAgICB2YXIgc3RvcmVfYWRkcmVzcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzdG9yZV9hZGRyZXNzJyk7XHJcbiAgICAgICAgIHZhciBzdG9yZV9kZWxpdmVyeSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzdG9yZV9kZWxpdmVyeScpO1xyXG4gICAgICAgICB2YXIgc3RvcmVfZGVzYyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzdG9yZV9kZXNjJyk7XHJcbiAgICAgICAgIHZhciBzdG9yZV9zY2hlZHVsZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzdG9yZV9zY2hlZHVsZScpO1xyXG4gICAgICAgICB2YXIgc3RvcmVfdGVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3N0b3JlX3RlbCcpO1xyXG4gICAgICAgICB2YXIgc3RvcmVfbWFpbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzdG9yZV9tYWlsJyk7XHJcbiAgICAgICAgIHZhciBzdG9yZV93ZWJzaXRlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3N0b3JlX3dlYnNpdGUnKTtcclxuICAgICAgICAgdmFyIGRlbGl2ZXJ5X2NoZWNrID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RlbGl2ZXJ5X2NoZWNrJyk7XHJcbiAgICAgICAgIHZhciBzdG9yZV9pZCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzdG9yZV9pZCcpO1xyXG5cclxuICAgICAgICAgdmFyIGRpc3QgPSBkaXN0YW5jZShsYXQsIGxvbiwgc3RvcmUubGF0LCBzdG9yZS5sb24sICdLJyk7XHJcbiAgICAgICAgIGRpc3QgPSBkaXN0LnRvRml4ZWQoMSk7XHJcblxyXG4gICAgICAgICBzdG9yZV9uYW1lLnRleHRDb250ZW50ID0gc3RvcmUubmFtZTtcclxuICAgICAgICAgc3RvcmVfZGlzdGFuY2UudGV4dENvbnRlbnQgPSAnXFx1MDBhMMOgICcgKyBkaXN0ICsgJ2ttJztcclxuICAgICAgICAgc3RvcmVfc2NvcmUudGV4dENvbnRlbnQgPSAnXFx1MDBhMDQvNSc7XHJcbiAgICAgICAgIGlmICgoc3RvcmUuY2l0eS56aXApLmxlbmd0aCA8IDUpIHtcclxuICAgICAgICAgICAgc3RvcmUuY2l0eS56aXAgPSAnMCcgKyBzdG9yZS5jaXR5LnppcDtcclxuICAgICAgICAgfVxyXG4gICAgICAgICBzdG9yZV9hZGRyZXNzLnRleHRDb250ZW50ID0gc3RvcmUuYWRkcmVzczEgKyAnLCAnICsgc3RvcmUuY2l0eS56aXAgKyAnICcgKyBzdG9yZS5jaXR5Lm5hbWU7XHJcbiAgICAgICAgIGlmIChzdG9yZS5kZWxpdmVyeSA9PT0gMSkge1xyXG4gICAgICAgICAgICBkZWxpdmVyeV9jaGVjay5jbGFzc0xpc3QudmFsdWUgID0gJ2ZhcyBmYS1jaGVjayc7XHJcbiAgICAgICAgICAgIHN0b3JlX2RlbGl2ZXJ5LnRleHRDb250ZW50ID0gJ0xpdnJhaXNvbiBwb3NzaWJsZSc7XHJcbiAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGRlbGl2ZXJ5X2NoZWNrLmNsYXNzTGlzdC52YWx1ZSA9ICdmYXMgZmEtdGltZXMnO1xyXG4gICAgICAgICAgICBzdG9yZV9kZWxpdmVyeS50ZXh0Q29udGVudCA9ICdMaXZyYWlzb24gaW5kaXNwb25pYmxlJztcclxuICAgICAgICAgfVxyXG4gICAgICAgICBzdG9yZV9kZXNjLnRleHRDb250ZW50ID0gc3RvcmUuZGVzY3JpcHRpb247XHJcbiAgICAgICAgIHN0b3JlX3NjaGVkdWxlLnRleHRDb250ZW50ID0gc3RvcmUub3BlbmluZ19ob3VycztcclxuICAgICAgICAgdmFyIHBob25lbnVtYmVyID0gZm9ybWF0VGVsKHN0b3JlLnBob25lbnVtYmVyKTtcclxuICAgICAgICAgc3RvcmVfdGVsLnRleHRDb250ZW50ID0gcGhvbmVudW1iZXI7XHJcbiAgICAgICAgIHN0b3JlX21haWwudGV4dENvbnRlbnQgPSBzdG9yZS5lbWFpbDtcclxuICAgICAgICAgc3RvcmVfd2Vic2l0ZS5ocmVmID0gc3RvcmUud2Vic2l0ZTtcclxuICAgICAgICAgc3RvcmVfaWQudGV4dENvbnRlbnQgPSBzdG9yZS5pZDtcclxuXHJcbiAgICAgICAgIHZhciBtYWN5b2Zhdm9yaXMgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnbWFjeW9mYXZvcmlzJyk7XHJcbiAgICAgICAgIHZhciBoZWFydF9mYXYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaGVhcnRfZmF2Jyk7XHJcbiAgICAgICAgIHZhciBleGlzdCA9IDA7XHJcbiAgICAgICAgIGlmIChtYWN5b2Zhdm9yaXMgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgbWFjeW9mYXZvcmlzID0gW21hY3lvZmF2b3Jpc107XHJcbiAgICAgICAgICAgIG1hY3lvZmF2b3JpcyA9IG1hY3lvZmF2b3Jpc1swXS5zcGxpdChbJywnXSk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFjeW9mYXZvcmlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgIGlmIChtYWN5b2Zhdm9yaXNbaV0gPT0gc3RvcmUuaWQpIHtcclxuICAgICAgICAgICAgICAgICAgZXhpc3QrKztcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChleGlzdCAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICBoZWFydF9mYXYuc2V0QXR0cmlidXRlKCd4bGluazpocmVmJywgJ2ltYWdlcy9zcHJpdGUuc3ZnI2hlYXJ0X2Z1bGwnKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgaGVhcnRfZmF2LnNldEF0dHJpYnV0ZSgneGxpbms6aHJlZicsICdpbWFnZXMvc3ByaXRlLnN2ZyNoZWFydF9lbXB0eScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGhlYXJ0X2Zhdi5zZXRBdHRyaWJ1dGUoJ3hsaW5rOmhyZWYnLCAnaW1hZ2VzL3Nwcml0ZS5zdmcjaGVhcnRfZW1wdHknKTtcclxuICAgICAgICAgfVxyXG5cclxuICAgICAgICAgaWYgKHBvcHVwLmNsYXNzTGlzdFsxXSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHBvcHVwLmNsYXNzTGlzdC52YWx1ZSA9ICdwb3B1cCBhY3RpdmUnO1xyXG4gICAgICAgICB9XHJcbiAgICAgICAgIHN3aXRjaEZpbHRlcigpO1xyXG5cclxuICAgICAgICAgdmFyIHBvcHVwX2dtYXBzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3BvcHVwX2dtYXBzJyk7XHJcbiAgICAgICAgIHBvcHVwX2dtYXBzLmhyZWYgPSAnaHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS9tYXBzL3NlYXJjaC8/YXBpPTEmcXVlcnk9JytzdG9yZS5uYW1lKycrJytzdG9yZS5jaXR5Lm5hbWU7XHJcbiAgICAgIH0pO1xyXG4gICAgICBtYXJrZXIuYWRkVG8obWFya2Vycyk7XHJcbiAgIH0pO1xyXG59XHJcblxyXG5sZXQgYnV0dG9uU2VhcmNoID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2J1dHRvblNlYXJjaCcpO1xyXG5idXR0b25TZWFyY2guYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCByZWNoZXJjaGUpO1xyXG5cclxubGV0IGlucHV0U2VhcmNoID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2lucHV0U2VhcmNoJyk7XHJcbmlucHV0U2VhcmNoLmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgY2hhcmdlVmlsbGVzKTtcclxuaW5wdXRTZWFyY2guYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCAoZSkgPT4ge1xyXG4gICAgaWYoZS5jb2RlID09PSAnRW50ZXInKSByZWNoZXJjaGUoKVxyXG59KTtcclxuaW5wdXRTZWFyY2guYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XHJcbiAgIHBvcHVwLmNsYXNzTGlzdC52YWx1ZSA9ICdwb3B1cCc7XHJcbiAgIHN3aXRjaEZpbHRlcigpO1xyXG59KTtcclxuXHJcbmxldCBhdXRvY29tcGxldGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYXV0b2NvbXBsZXRlJyk7XHJcblxyXG5mdW5jdGlvbiBjaGFyZ2VWaWxsZXMoKSB7XHJcbiAgIGlmIChpbnB1dFNlYXJjaC52YWx1ZS5yZXBsYWNlKC9cXHMrLywgJycpLmxlbmd0aCkge1xyXG4gICAgICAkLmFqYXgoe1xyXG4gICAgICAgICB1cmw6IFwiaHR0cHM6Ly9hcGktYWRyZXNzZS5kYXRhLmdvdXYuZnIvc2VhcmNoLz9xPVwiK2lucHV0U2VhcmNoLnZhbHVlK1wiJmxpbWl0PTEwXCIsXHJcbiAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKGRhdGEpIHtcclxuICAgICAgICAgICAgcmVjdXBWaWxsZXMoZGF0YS5mZWF0dXJlcyk7XHJcbiAgICAgICAgIH0sXHJcbiAgICAgICAgIGVycm9yOiBmdW5jdGlvbihkYXRhKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdlcnJvciB3aGVuIHNlYXJjaCcpO1xyXG4gICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICB9IGVsc2Uge1xyXG4gICAgICBhdXRvY29tcGxldGUuaW5uZXJIVE1MID0gJyc7XHJcbiAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gcmVjdXBWaWxsZXMoYWRyZXNzZSkge1xyXG4gICB2YXIgb3B0aW9uID0gJyc7XHJcbiAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWRyZXNzZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICBvcHRpb24gKz0gJzxwIG9uY2xpY2s9XCJzZXRBZHJlc3NlKHRoaXMpO1wiPicrYWRyZXNzZVtpXS5wcm9wZXJ0aWVzLmxhYmVsKyc8L3A+JztcclxuICAgfVxyXG4gICBhdXRvY29tcGxldGUuaW5uZXJIVE1MID0gb3B0aW9uO1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gc2V0QWRyZXNzZShlbGVtKSB7XHJcbiAgIGlucHV0U2VhcmNoLnZhbHVlID0gZWxlbS50ZXh0Q29udGVudDtcclxuICAgYXV0b2NvbXBsZXRlLmlubmVySFRNTCA9ICcnO1xyXG59XHJcbndpbmRvdy5zZXRBZHJlc3NlID0gc2V0QWRyZXNzZTtcclxuXHJcbnZhciBtYXJrZXJTZWFyY2ggPSBMLmljb24oe1xyXG4gICBpY29uVXJsOiAnaW1hZ2VzL2ljb25fY2F0L3JlY2hlcmNoZUAyeC5wbmcnLFxyXG4gICBpY29uUmV0aW5hVXJsOiAnaW1hZ2VzL2ljb25fY2F0L3JlY2hlcmNoZUAzeC5wbmcnLFxyXG4gICBpY29uU2l6ZTogICAgIFsyNSwgMzVdXHJcbn0pO1xyXG5cclxudmFyIHNlYXJjaExheWVyID0gTC5tYXJrZXIoWzAsIDBdLCB7aWNvbjogbWFya2VyU2VhcmNofSk7XHJcblxyXG52YXIgbWFya2VyUG9zaXRpb24gPSBMLmljb24oe1xyXG4gICBpY29uVXJsOiAnaW1hZ2VzL2ljb25fY2F0L3Bvc2l0aW9uQDJ4LnBuZycsXHJcbiAgIGljb25SZXRpbmFVcmw6ICdpbWFnZXMvaWNvbl9jYXQvcG9zaXRpb25AM3gucG5nJyxcclxuICAgaWNvblNpemU6ICAgICBbMjUsIDM1XVxyXG59KTtcclxuXHJcbmZ1bmN0aW9uIHJlY2hlcmNoZSgpIHtcclxuICAgYXV0b2NvbXBsZXRlLmlubmVySFRNTCA9ICcnO1xyXG4gICBjYXJ0ZS5yZW1vdmVMYXllcihzZWFyY2hMYXllcik7XHJcbiAgIGlmIChpbnB1dFNlYXJjaC52YWx1ZSAhPSAnJykge1xyXG4gICAgICAgd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKHtpZDogJ3NlYXJjaCd9LCAnQ2FydGUgfCBNQUMtWU8nLCAnL21hcD9xPScraW5wdXRTZWFyY2gudmFsdWUpO1xyXG4gICAgICAkLmFqYXgoe1xyXG4gICAgICAgICB1cmw6IFwiaHR0cHM6Ly9hcGktYWRyZXNzZS5kYXRhLmdvdXYuZnIvc2VhcmNoLz9xPVwiK2lucHV0U2VhcmNoLnZhbHVlK1wiJmxpbWl0PTFcIixcclxuICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24oZGF0YSkge1xyXG4gICAgICAgICAgICB2YXIgbGF0ID0gZGF0YS5mZWF0dXJlc1swXS5nZW9tZXRyeS5jb29yZGluYXRlc1swXTtcclxuICAgICAgICAgICAgdmFyIGxvbiA9IGRhdGEuZmVhdHVyZXNbMF0uZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMV07XHJcbiAgICAgICAgICAgIGNhcnRlLnNldFZpZXcoW2xvbiwgbGF0XSwgMTQsIHsgYW5pbWF0aW9uOiB0cnVlIH0pO1xyXG4gICAgICAgICAgICBzZWFyY2hMYXllciA9IEwubWFya2VyKFtsb24sIGxhdF0sIHtpY29uOiBtYXJrZXJTZWFyY2h9KS5iaW5kVG9vbHRpcChcclxuICAgICAgICAgICAgICAgZGF0YS5mZWF0dXJlc1swXS5wcm9wZXJ0aWVzLmxhYmVsXHJcbiAgICAgICAgICAgICAgICx7XHJcbiAgICAgICAgICAgICAgICAgIHBlcm1hbmVudDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgIG9mZnNldDogTC5wb2ludCgwLCAtMTYpLFxyXG4gICAgICAgICAgICAgICAgICBkaXJlY3Rpb246ICd0b3AnLFxyXG4gICAgICAgICAgICAgICAgICBvcGFjaXR5OiAwLjhcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICApLmFkZFRvKGNhcnRlKTtcclxuICAgICAgICAgICAgbmVhclN0b3JlcyhbbGF0LGxvbl0pO1xyXG4gICAgICAgICB9LFxyXG4gICAgICAgICBlcnJvcjogZnVuY3Rpb24oZGF0YSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnZXJyb3Igd2hlbiBzZWFyY2gnKTtcclxuICAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiB1c2VyUG9zaXRpb24oKSB7XHJcbiAgIGlmIChcImdlb2xvY2F0aW9uXCIgaW4gbmF2aWdhdG9yKSB7XHJcbiAgICAgIG5hdmlnYXRvci5nZW9sb2NhdGlvbi5nZXRDdXJyZW50UG9zaXRpb24oZnVuY3Rpb24ocG9zaXRpb24pIHtcclxuICAgICAgICAgTC5tYXJrZXIoW3Bvc2l0aW9uLmNvb3Jkcy5sYXRpdHVkZSwgcG9zaXRpb24uY29vcmRzLmxvbmdpdHVkZV0sIHtpY29uOiBtYXJrZXJQb3NpdGlvbn0pLmFkZFRvKG1hcmtlcnMpO1xyXG4gICAgICAgICAvLyBjYXJ0ZS5zZXRWaWV3KFtwb3NpdGlvbi5jb29yZHMubGF0aXR1ZGUsIHBvc2l0aW9uLmNvb3Jkcy5sb25naXR1ZGVdLCAxNCwgeyBhbmltYXRpb246IHRydWUgfSk7XHJcbiAgICAgIH0pO1xyXG4gICB9IGVsc2Uge1xyXG4gICAgICAvKiBsYSBnw6lvbG9jYWxpc2F0aW9uIG4nZXN0IHBhcyBkaXNwb25pYmxlICovXHJcbiAgICAgIGFsZXJ0KCdWb3RyZSBnw6lvbG9jYWxpc2F0aW9uIGVzdCBpbmRpc3BvbmlibGUnKTtcclxuICAgfVxyXG59XHJcbnVzZXJQb3NpdGlvbigpO1xyXG5cclxudmFyIHVybF9zdHJpbmcgPSB3aW5kb3cubG9jYXRpb24uaHJlZjtcclxudmFyIHVybCA9IG5ldyBVUkwodXJsX3N0cmluZyk7XHJcbnZhciBsYXQgPSB1cmwuc2VhcmNoUGFyYW1zLmdldChcImxhdFwiKTtcclxudmFyIGxvbiA9IHVybC5zZWFyY2hQYXJhbXMuZ2V0KFwibG9uXCIpO1xyXG5pZiAobGF0ICE9PSBudWxsICYmIGxvbiAhPT0gbnVsbCkge1xyXG4gICBjYXJ0ZS5zZXRWaWV3KFtsYXQsIGxvbl0sIDIwLCB7IGFuaW1hdGlvbjogdHJ1ZSB9KTtcclxuICAgbmVhclN0b3JlcyhbbG9uLCBsYXRdKTtcclxufVxyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/js/map.js\n");

/***/ }),

/***/ "./node_modules/leaflet.markercluster/dist/leaflet.markercluster-src.js":
/*!******************************************************************************!*\
  !*** ./node_modules/leaflet.markercluster/dist/leaflet.markercluster-src.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("/*\n * Leaflet.markercluster 1.4.1+master.94f9815,\n * Provides Beautiful Animated Marker Clustering functionality for Leaflet, a JS library for interactive maps.\n * https://github.com/Leaflet/Leaflet.markercluster\n * (c) 2012-2017, Dave Leaver, smartrak\n */\n(function (global, factory) {\n\t true ? factory(exports) :\n\t0;\n}(this, (function (exports) { 'use strict';\n\n/*\r\n * L.MarkerClusterGroup extends L.FeatureGroup by clustering the markers contained within\r\n */\r\n\r\nvar MarkerClusterGroup = L.MarkerClusterGroup = L.FeatureGroup.extend({\r\n\r\n\toptions: {\r\n\t\tmaxClusterRadius: 80, //A cluster will cover at most this many pixels from its center\r\n\t\ticonCreateFunction: null,\r\n\t\tclusterPane: L.Marker.prototype.options.pane,\r\n\r\n\t\tspiderfyOnMaxZoom: true,\r\n\t\tshowCoverageOnHover: true,\r\n\t\tzoomToBoundsOnClick: true,\r\n\t\tsingleMarkerMode: false,\r\n\r\n\t\tdisableClusteringAtZoom: null,\r\n\r\n\t\t// Setting this to false prevents the removal of any clusters outside of the viewpoint, which\r\n\t\t// is the default behaviour for performance reasons.\r\n\t\tremoveOutsideVisibleBounds: true,\r\n\r\n\t\t// Set to false to disable all animations (zoom and spiderfy).\r\n\t\t// If false, option animateAddingMarkers below has no effect.\r\n\t\t// If L.DomUtil.TRANSITION is falsy, this option has no effect.\r\n\t\tanimate: true,\r\n\r\n\t\t//Whether to animate adding markers after adding the MarkerClusterGroup to the map\r\n\t\t// If you are adding individual markers set to true, if adding bulk markers leave false for massive performance gains.\r\n\t\tanimateAddingMarkers: false,\r\n\r\n\t\t//Increase to increase the distance away that spiderfied markers appear from the center\r\n\t\tspiderfyDistanceMultiplier: 1,\r\n\r\n\t\t// Make it possible to specify a polyline options on a spider leg\r\n\t\tspiderLegPolylineOptions: { weight: 1.5, color: '#222', opacity: 0.5 },\r\n\r\n\t\t// When bulk adding layers, adds markers in chunks. Means addLayers may not add all the layers in the call, others will be loaded during setTimeouts\r\n\t\tchunkedLoading: false,\r\n\t\tchunkInterval: 200, // process markers for a maximum of ~ n milliseconds (then trigger the chunkProgress callback)\r\n\t\tchunkDelay: 50, // at the end of each interval, give n milliseconds back to system/browser\r\n\t\tchunkProgress: null, // progress callback: function(processed, total, elapsed) (e.g. for a progress indicator)\r\n\r\n\t\t//Options to pass to the L.Polygon constructor\r\n\t\tpolygonOptions: {}\r\n\t},\r\n\r\n\tinitialize: function (options) {\r\n\t\tL.Util.setOptions(this, options);\r\n\t\tif (!this.options.iconCreateFunction) {\r\n\t\t\tthis.options.iconCreateFunction = this._defaultIconCreateFunction;\r\n\t\t}\r\n\r\n\t\tthis._featureGroup = L.featureGroup();\r\n\t\tthis._featureGroup.addEventParent(this);\r\n\r\n\t\tthis._nonPointGroup = L.featureGroup();\r\n\t\tthis._nonPointGroup.addEventParent(this);\r\n\r\n\t\tthis._inZoomAnimation = 0;\r\n\t\tthis._needsClustering = [];\r\n\t\tthis._needsRemoving = []; //Markers removed while we aren't on the map need to be kept track of\r\n\t\t//The bounds of the currently shown area (from _getExpandedVisibleBounds) Updated on zoom/move\r\n\t\tthis._currentShownBounds = null;\r\n\r\n\t\tthis._queue = [];\r\n\r\n\t\tthis._childMarkerEventHandlers = {\r\n\t\t\t'dragstart': this._childMarkerDragStart,\r\n\t\t\t'move': this._childMarkerMoved,\r\n\t\t\t'dragend': this._childMarkerDragEnd,\r\n\t\t};\r\n\r\n\t\t// Hook the appropriate animation methods.\r\n\t\tvar animate = L.DomUtil.TRANSITION && this.options.animate;\r\n\t\tL.extend(this, animate ? this._withAnimation : this._noAnimation);\r\n\t\t// Remember which MarkerCluster class to instantiate (animated or not).\r\n\t\tthis._markerCluster = animate ? L.MarkerCluster : L.MarkerClusterNonAnimated;\r\n\t},\r\n\r\n\taddLayer: function (layer) {\r\n\r\n\t\tif (layer instanceof L.LayerGroup) {\r\n\t\t\treturn this.addLayers([layer]);\r\n\t\t}\r\n\r\n\t\t//Don't cluster non point data\r\n\t\tif (!layer.getLatLng) {\r\n\t\t\tthis._nonPointGroup.addLayer(layer);\r\n\t\t\tthis.fire('layeradd', { layer: layer });\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\tif (!this._map) {\r\n\t\t\tthis._needsClustering.push(layer);\r\n\t\t\tthis.fire('layeradd', { layer: layer });\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\tif (this.hasLayer(layer)) {\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\r\n\t\t//If we have already clustered we'll need to add this one to a cluster\r\n\r\n\t\tif (this._unspiderfy) {\r\n\t\t\tthis._unspiderfy();\r\n\t\t}\r\n\r\n\t\tthis._addLayer(layer, this._maxZoom);\r\n\t\tthis.fire('layeradd', { layer: layer });\r\n\r\n\t\t// Refresh bounds and weighted positions.\r\n\t\tthis._topClusterLevel._recalculateBounds();\r\n\r\n\t\tthis._refreshClustersIcons();\r\n\r\n\t\t//Work out what is visible\r\n\t\tvar visibleLayer = layer,\r\n\t\t    currentZoom = this._zoom;\r\n\t\tif (layer.__parent) {\r\n\t\t\twhile (visibleLayer.__parent._zoom >= currentZoom) {\r\n\t\t\t\tvisibleLayer = visibleLayer.__parent;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (this._currentShownBounds.contains(visibleLayer.getLatLng())) {\r\n\t\t\tif (this.options.animateAddingMarkers) {\r\n\t\t\t\tthis._animationAddLayer(layer, visibleLayer);\r\n\t\t\t} else {\r\n\t\t\t\tthis._animationAddLayerNonAnimated(layer, visibleLayer);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremoveLayer: function (layer) {\r\n\r\n\t\tif (layer instanceof L.LayerGroup) {\r\n\t\t\treturn this.removeLayers([layer]);\r\n\t\t}\r\n\r\n\t\t//Non point layers\r\n\t\tif (!layer.getLatLng) {\r\n\t\t\tthis._nonPointGroup.removeLayer(layer);\r\n\t\t\tthis.fire('layerremove', { layer: layer });\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\tif (!this._map) {\r\n\t\t\tif (!this._arraySplice(this._needsClustering, layer) && this.hasLayer(layer)) {\r\n\t\t\t\tthis._needsRemoving.push({ layer: layer, latlng: layer._latlng });\r\n\t\t\t}\r\n\t\t\tthis.fire('layerremove', { layer: layer });\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\tif (!layer.__parent) {\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\tif (this._unspiderfy) {\r\n\t\t\tthis._unspiderfy();\r\n\t\t\tthis._unspiderfyLayer(layer);\r\n\t\t}\r\n\r\n\t\t//Remove the marker from clusters\r\n\t\tthis._removeLayer(layer, true);\r\n\t\tthis.fire('layerremove', { layer: layer });\r\n\r\n\t\t// Refresh bounds and weighted positions.\r\n\t\tthis._topClusterLevel._recalculateBounds();\r\n\r\n\t\tthis._refreshClustersIcons();\r\n\r\n\t\tlayer.off(this._childMarkerEventHandlers, this);\r\n\r\n\t\tif (this._featureGroup.hasLayer(layer)) {\r\n\t\t\tthis._featureGroup.removeLayer(layer);\r\n\t\t\tif (layer.clusterShow) {\r\n\t\t\t\tlayer.clusterShow();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\t//Takes an array of markers and adds them in bulk\r\n\taddLayers: function (layersArray, skipLayerAddEvent) {\r\n\t\tif (!L.Util.isArray(layersArray)) {\r\n\t\t\treturn this.addLayer(layersArray);\r\n\t\t}\r\n\r\n\t\tvar fg = this._featureGroup,\r\n\t\t    npg = this._nonPointGroup,\r\n\t\t    chunked = this.options.chunkedLoading,\r\n\t\t    chunkInterval = this.options.chunkInterval,\r\n\t\t    chunkProgress = this.options.chunkProgress,\r\n\t\t    l = layersArray.length,\r\n\t\t    offset = 0,\r\n\t\t    originalArray = true,\r\n\t\t    m;\r\n\r\n\t\tif (this._map) {\r\n\t\t\tvar started = (new Date()).getTime();\r\n\t\t\tvar process = L.bind(function () {\r\n\t\t\t\tvar start = (new Date()).getTime();\r\n\t\t\t\tfor (; offset < l; offset++) {\r\n\t\t\t\t\tif (chunked && offset % 200 === 0) {\r\n\t\t\t\t\t\t// every couple hundred markers, instrument the time elapsed since processing started:\r\n\t\t\t\t\t\tvar elapsed = (new Date()).getTime() - start;\r\n\t\t\t\t\t\tif (elapsed > chunkInterval) {\r\n\t\t\t\t\t\t\tbreak; // been working too hard, time to take a break :-)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tm = layersArray[offset];\r\n\r\n\t\t\t\t\t// Group of layers, append children to layersArray and skip.\r\n\t\t\t\t\t// Side effects:\r\n\t\t\t\t\t// - Total increases, so chunkProgress ratio jumps backward.\r\n\t\t\t\t\t// - Groups are not included in this group, only their non-group child layers (hasLayer).\r\n\t\t\t\t\t// Changing array length while looping does not affect performance in current browsers:\r\n\t\t\t\t\t// http://jsperf.com/for-loop-changing-length/6\r\n\t\t\t\t\tif (m instanceof L.LayerGroup) {\r\n\t\t\t\t\t\tif (originalArray) {\r\n\t\t\t\t\t\t\tlayersArray = layersArray.slice();\r\n\t\t\t\t\t\t\toriginalArray = false;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tthis._extractNonGroupLayers(m, layersArray);\r\n\t\t\t\t\t\tl = layersArray.length;\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t//Not point data, can't be clustered\r\n\t\t\t\t\tif (!m.getLatLng) {\r\n\t\t\t\t\t\tnpg.addLayer(m);\r\n\t\t\t\t\t\tif (!skipLayerAddEvent) {\r\n\t\t\t\t\t\t\tthis.fire('layeradd', { layer: m });\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (this.hasLayer(m)) {\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tthis._addLayer(m, this._maxZoom);\r\n\t\t\t\t\tif (!skipLayerAddEvent) {\r\n\t\t\t\t\t\tthis.fire('layeradd', { layer: m });\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t//If we just made a cluster of size 2 then we need to remove the other marker from the map (if it is) or we never will\r\n\t\t\t\t\tif (m.__parent) {\r\n\t\t\t\t\t\tif (m.__parent.getChildCount() === 2) {\r\n\t\t\t\t\t\t\tvar markers = m.__parent.getAllChildMarkers(),\r\n\t\t\t\t\t\t\t    otherMarker = markers[0] === m ? markers[1] : markers[0];\r\n\t\t\t\t\t\t\tfg.removeLayer(otherMarker);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (chunkProgress) {\r\n\t\t\t\t\t// report progress and time elapsed:\r\n\t\t\t\t\tchunkProgress(offset, l, (new Date()).getTime() - started);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Completed processing all markers.\r\n\t\t\t\tif (offset === l) {\r\n\r\n\t\t\t\t\t// Refresh bounds and weighted positions.\r\n\t\t\t\t\tthis._topClusterLevel._recalculateBounds();\r\n\r\n\t\t\t\t\tthis._refreshClustersIcons();\r\n\r\n\t\t\t\t\tthis._topClusterLevel._recursivelyAddChildrenToMap(null, this._zoom, this._currentShownBounds);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tsetTimeout(process, this.options.chunkDelay);\r\n\t\t\t\t}\r\n\t\t\t}, this);\r\n\r\n\t\t\tprocess();\r\n\t\t} else {\r\n\t\t\tvar needsClustering = this._needsClustering;\r\n\r\n\t\t\tfor (; offset < l; offset++) {\r\n\t\t\t\tm = layersArray[offset];\r\n\r\n\t\t\t\t// Group of layers, append children to layersArray and skip.\r\n\t\t\t\tif (m instanceof L.LayerGroup) {\r\n\t\t\t\t\tif (originalArray) {\r\n\t\t\t\t\t\tlayersArray = layersArray.slice();\r\n\t\t\t\t\t\toriginalArray = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis._extractNonGroupLayers(m, layersArray);\r\n\t\t\t\t\tl = layersArray.length;\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t//Not point data, can't be clustered\r\n\t\t\t\tif (!m.getLatLng) {\r\n\t\t\t\t\tnpg.addLayer(m);\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (this.hasLayer(m)) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tneedsClustering.push(m);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\t//Takes an array of markers and removes them in bulk\r\n\tremoveLayers: function (layersArray) {\r\n\t\tvar i, m,\r\n\t\t    l = layersArray.length,\r\n\t\t    fg = this._featureGroup,\r\n\t\t    npg = this._nonPointGroup,\r\n\t\t    originalArray = true;\r\n\r\n\t\tif (!this._map) {\r\n\t\t\tfor (i = 0; i < l; i++) {\r\n\t\t\t\tm = layersArray[i];\r\n\r\n\t\t\t\t// Group of layers, append children to layersArray and skip.\r\n\t\t\t\tif (m instanceof L.LayerGroup) {\r\n\t\t\t\t\tif (originalArray) {\r\n\t\t\t\t\t\tlayersArray = layersArray.slice();\r\n\t\t\t\t\t\toriginalArray = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis._extractNonGroupLayers(m, layersArray);\r\n\t\t\t\t\tl = layersArray.length;\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis._arraySplice(this._needsClustering, m);\r\n\t\t\t\tnpg.removeLayer(m);\r\n\t\t\t\tif (this.hasLayer(m)) {\r\n\t\t\t\t\tthis._needsRemoving.push({ layer: m, latlng: m._latlng });\r\n\t\t\t\t}\r\n\t\t\t\tthis.fire('layerremove', { layer: m });\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\tif (this._unspiderfy) {\r\n\t\t\tthis._unspiderfy();\r\n\r\n\t\t\t// Work on a copy of the array, so that next loop is not affected.\r\n\t\t\tvar layersArray2 = layersArray.slice(),\r\n\t\t\t    l2 = l;\r\n\t\t\tfor (i = 0; i < l2; i++) {\r\n\t\t\t\tm = layersArray2[i];\r\n\r\n\t\t\t\t// Group of layers, append children to layersArray and skip.\r\n\t\t\t\tif (m instanceof L.LayerGroup) {\r\n\t\t\t\t\tthis._extractNonGroupLayers(m, layersArray2);\r\n\t\t\t\t\tl2 = layersArray2.length;\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis._unspiderfyLayer(m);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor (i = 0; i < l; i++) {\r\n\t\t\tm = layersArray[i];\r\n\r\n\t\t\t// Group of layers, append children to layersArray and skip.\r\n\t\t\tif (m instanceof L.LayerGroup) {\r\n\t\t\t\tif (originalArray) {\r\n\t\t\t\t\tlayersArray = layersArray.slice();\r\n\t\t\t\t\toriginalArray = false;\r\n\t\t\t\t}\r\n\t\t\t\tthis._extractNonGroupLayers(m, layersArray);\r\n\t\t\t\tl = layersArray.length;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tif (!m.__parent) {\r\n\t\t\t\tnpg.removeLayer(m);\r\n\t\t\t\tthis.fire('layerremove', { layer: m });\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tthis._removeLayer(m, true, true);\r\n\t\t\tthis.fire('layerremove', { layer: m });\r\n\r\n\t\t\tif (fg.hasLayer(m)) {\r\n\t\t\t\tfg.removeLayer(m);\r\n\t\t\t\tif (m.clusterShow) {\r\n\t\t\t\t\tm.clusterShow();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Refresh bounds and weighted positions.\r\n\t\tthis._topClusterLevel._recalculateBounds();\r\n\r\n\t\tthis._refreshClustersIcons();\r\n\r\n\t\t//Fix up the clusters and markers on the map\r\n\t\tthis._topClusterLevel._recursivelyAddChildrenToMap(null, this._zoom, this._currentShownBounds);\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\t//Removes all layers from the MarkerClusterGroup\r\n\tclearLayers: function () {\r\n\t\t//Need our own special implementation as the LayerGroup one doesn't work for us\r\n\r\n\t\t//If we aren't on the map (yet), blow away the markers we know of\r\n\t\tif (!this._map) {\r\n\t\t\tthis._needsClustering = [];\r\n\t\t\tthis._needsRemoving = [];\r\n\t\t\tdelete this._gridClusters;\r\n\t\t\tdelete this._gridUnclustered;\r\n\t\t}\r\n\r\n\t\tif (this._noanimationUnspiderfy) {\r\n\t\t\tthis._noanimationUnspiderfy();\r\n\t\t}\r\n\r\n\t\t//Remove all the visible layers\r\n\t\tthis._featureGroup.clearLayers();\r\n\t\tthis._nonPointGroup.clearLayers();\r\n\r\n\t\tthis.eachLayer(function (marker) {\r\n\t\t\tmarker.off(this._childMarkerEventHandlers, this);\r\n\t\t\tdelete marker.__parent;\r\n\t\t}, this);\r\n\r\n\t\tif (this._map) {\r\n\t\t\t//Reset _topClusterLevel and the DistanceGrids\r\n\t\t\tthis._generateInitialClusters();\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\t//Override FeatureGroup.getBounds as it doesn't work\r\n\tgetBounds: function () {\r\n\t\tvar bounds = new L.LatLngBounds();\r\n\r\n\t\tif (this._topClusterLevel) {\r\n\t\t\tbounds.extend(this._topClusterLevel._bounds);\r\n\t\t}\r\n\r\n\t\tfor (var i = this._needsClustering.length - 1; i >= 0; i--) {\r\n\t\t\tbounds.extend(this._needsClustering[i].getLatLng());\r\n\t\t}\r\n\r\n\t\tbounds.extend(this._nonPointGroup.getBounds());\r\n\r\n\t\treturn bounds;\r\n\t},\r\n\r\n\t//Overrides LayerGroup.eachLayer\r\n\teachLayer: function (method, context) {\r\n\t\tvar markers = this._needsClustering.slice(),\r\n\t\t\tneedsRemoving = this._needsRemoving,\r\n\t\t\tthisNeedsRemoving, i, j;\r\n\r\n\t\tif (this._topClusterLevel) {\r\n\t\t\tthis._topClusterLevel.getAllChildMarkers(markers);\r\n\t\t}\r\n\r\n\t\tfor (i = markers.length - 1; i >= 0; i--) {\r\n\t\t\tthisNeedsRemoving = true;\r\n\r\n\t\t\tfor (j = needsRemoving.length - 1; j >= 0; j--) {\r\n\t\t\t\tif (needsRemoving[j].layer === markers[i]) {\r\n\t\t\t\t\tthisNeedsRemoving = false;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (thisNeedsRemoving) {\r\n\t\t\t\tmethod.call(context, markers[i]);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis._nonPointGroup.eachLayer(method, context);\r\n\t},\r\n\r\n\t//Overrides LayerGroup.getLayers\r\n\tgetLayers: function () {\r\n\t\tvar layers = [];\r\n\t\tthis.eachLayer(function (l) {\r\n\t\t\tlayers.push(l);\r\n\t\t});\r\n\t\treturn layers;\r\n\t},\r\n\r\n\t//Overrides LayerGroup.getLayer, WARNING: Really bad performance\r\n\tgetLayer: function (id) {\r\n\t\tvar result = null;\r\n\r\n\t\tid = parseInt(id, 10);\r\n\r\n\t\tthis.eachLayer(function (l) {\r\n\t\t\tif (L.stamp(l) === id) {\r\n\t\t\t\tresult = l;\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn result;\r\n\t},\r\n\r\n\t//Returns true if the given layer is in this MarkerClusterGroup\r\n\thasLayer: function (layer) {\r\n\t\tif (!layer) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tvar i, anArray = this._needsClustering;\r\n\r\n\t\tfor (i = anArray.length - 1; i >= 0; i--) {\r\n\t\t\tif (anArray[i] === layer) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tanArray = this._needsRemoving;\r\n\t\tfor (i = anArray.length - 1; i >= 0; i--) {\r\n\t\t\tif (anArray[i].layer === layer) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn !!(layer.__parent && layer.__parent._group === this) || this._nonPointGroup.hasLayer(layer);\r\n\t},\r\n\r\n\t//Zoom down to show the given layer (spiderfying if necessary) then calls the callback\r\n\tzoomToShowLayer: function (layer, callback) {\r\n\r\n\t\tif (typeof callback !== 'function') {\r\n\t\t\tcallback = function () {};\r\n\t\t}\r\n\r\n\t\tvar showMarker = function () {\r\n\t\t\tif ((layer._icon || layer.__parent._icon) && !this._inZoomAnimation) {\r\n\t\t\t\tthis._map.off('moveend', showMarker, this);\r\n\t\t\t\tthis.off('animationend', showMarker, this);\r\n\r\n\t\t\t\tif (layer._icon) {\r\n\t\t\t\t\tcallback();\r\n\t\t\t\t} else if (layer.__parent._icon) {\r\n\t\t\t\t\tthis.once('spiderfied', callback, this);\r\n\t\t\t\t\tlayer.__parent.spiderfy();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tif (layer._icon && this._map.getBounds().contains(layer.getLatLng())) {\r\n\t\t\t//Layer is visible ond on screen, immediate return\r\n\t\t\tcallback();\r\n\t\t} else if (layer.__parent._zoom < Math.round(this._map._zoom)) {\r\n\t\t\t//Layer should be visible at this zoom level. It must not be on screen so just pan over to it\r\n\t\t\tthis._map.on('moveend', showMarker, this);\r\n\t\t\tthis._map.panTo(layer.getLatLng());\r\n\t\t} else {\r\n\t\t\tthis._map.on('moveend', showMarker, this);\r\n\t\t\tthis.on('animationend', showMarker, this);\r\n\t\t\tlayer.__parent.zoomToBounds();\r\n\t\t}\r\n\t},\r\n\r\n\t//Overrides FeatureGroup.onAdd\r\n\tonAdd: function (map) {\r\n\t\tthis._map = map;\r\n\t\tvar i, l, layer;\r\n\r\n\t\tif (!isFinite(this._map.getMaxZoom())) {\r\n\t\t\tthrow \"Map has no maxZoom specified\";\r\n\t\t}\r\n\r\n\t\tthis._featureGroup.addTo(map);\r\n\t\tthis._nonPointGroup.addTo(map);\r\n\r\n\t\tif (!this._gridClusters) {\r\n\t\t\tthis._generateInitialClusters();\r\n\t\t}\r\n\r\n\t\tthis._maxLat = map.options.crs.projection.MAX_LATITUDE;\r\n\r\n\t\t//Restore all the positions as they are in the MCG before removing them\r\n\t\tfor (i = 0, l = this._needsRemoving.length; i < l; i++) {\r\n\t\t\tlayer = this._needsRemoving[i];\r\n\t\t\tlayer.newlatlng = layer.layer._latlng;\r\n\t\t\tlayer.layer._latlng = layer.latlng;\r\n\t\t}\r\n\t\t//Remove them, then restore their new positions\r\n\t\tfor (i = 0, l = this._needsRemoving.length; i < l; i++) {\r\n\t\t\tlayer = this._needsRemoving[i];\r\n\t\t\tthis._removeLayer(layer.layer, true);\r\n\t\t\tlayer.layer._latlng = layer.newlatlng;\r\n\t\t}\r\n\t\tthis._needsRemoving = [];\r\n\r\n\t\t//Remember the current zoom level and bounds\r\n\t\tthis._zoom = Math.round(this._map._zoom);\r\n\t\tthis._currentShownBounds = this._getExpandedVisibleBounds();\r\n\r\n\t\tthis._map.on('zoomend', this._zoomEnd, this);\r\n\t\tthis._map.on('moveend', this._moveEnd, this);\r\n\r\n\t\tif (this._spiderfierOnAdd) { //TODO FIXME: Not sure how to have spiderfier add something on here nicely\r\n\t\t\tthis._spiderfierOnAdd();\r\n\t\t}\r\n\r\n\t\tthis._bindEvents();\r\n\r\n\t\t//Actually add our markers to the map:\r\n\t\tl = this._needsClustering;\r\n\t\tthis._needsClustering = [];\r\n\t\tthis.addLayers(l, true);\r\n\t},\r\n\r\n\t//Overrides FeatureGroup.onRemove\r\n\tonRemove: function (map) {\r\n\t\tmap.off('zoomend', this._zoomEnd, this);\r\n\t\tmap.off('moveend', this._moveEnd, this);\r\n\r\n\t\tthis._unbindEvents();\r\n\r\n\t\t//In case we are in a cluster animation\r\n\t\tthis._map._mapPane.className = this._map._mapPane.className.replace(' leaflet-cluster-anim', '');\r\n\r\n\t\tif (this._spiderfierOnRemove) { //TODO FIXME: Not sure how to have spiderfier add something on here nicely\r\n\t\t\tthis._spiderfierOnRemove();\r\n\t\t}\r\n\r\n\t\tdelete this._maxLat;\r\n\r\n\t\t//Clean up all the layers we added to the map\r\n\t\tthis._hideCoverage();\r\n\t\tthis._featureGroup.remove();\r\n\t\tthis._nonPointGroup.remove();\r\n\r\n\t\tthis._featureGroup.clearLayers();\r\n\r\n\t\tthis._map = null;\r\n\t},\r\n\r\n\tgetVisibleParent: function (marker) {\r\n\t\tvar vMarker = marker;\r\n\t\twhile (vMarker && !vMarker._icon) {\r\n\t\t\tvMarker = vMarker.__parent;\r\n\t\t}\r\n\t\treturn vMarker || null;\r\n\t},\r\n\r\n\t//Remove the given object from the given array\r\n\t_arraySplice: function (anArray, obj) {\r\n\t\tfor (var i = anArray.length - 1; i >= 0; i--) {\r\n\t\t\tif (anArray[i] === obj) {\r\n\t\t\t\tanArray.splice(i, 1);\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t * Removes a marker from all _gridUnclustered zoom levels, starting at the supplied zoom.\r\n\t * @param marker to be removed from _gridUnclustered.\r\n\t * @param z integer bottom start zoom level (included)\r\n\t * @private\r\n\t */\r\n\t_removeFromGridUnclustered: function (marker, z) {\r\n\t\tvar map = this._map,\r\n\t\t    gridUnclustered = this._gridUnclustered,\r\n\t\t\tminZoom = Math.floor(this._map.getMinZoom());\r\n\r\n\t\tfor (; z >= minZoom; z--) {\r\n\t\t\tif (!gridUnclustered[z].removeObject(marker, map.project(marker.getLatLng(), z))) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_childMarkerDragStart: function (e) {\r\n\t\te.target.__dragStart = e.target._latlng;\r\n\t},\r\n\r\n\t_childMarkerMoved: function (e) {\r\n\t\tif (!this._ignoreMove && !e.target.__dragStart) {\r\n\t\t\tvar isPopupOpen = e.target._popup && e.target._popup.isOpen();\r\n\r\n\t\t\tthis._moveChild(e.target, e.oldLatLng, e.latlng);\r\n\r\n\t\t\tif (isPopupOpen) {\r\n\t\t\t\te.target.openPopup();\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_moveChild: function (layer, from, to) {\r\n\t\tlayer._latlng = from;\r\n\t\tthis.removeLayer(layer);\r\n\r\n\t\tlayer._latlng = to;\r\n\t\tthis.addLayer(layer);\r\n\t},\r\n\r\n\t_childMarkerDragEnd: function (e) {\r\n\t\tvar dragStart = e.target.__dragStart;\r\n\t\tdelete e.target.__dragStart;\r\n\t\tif (dragStart) {\r\n\t\t\tthis._moveChild(e.target, dragStart, e.target._latlng);\r\n\t\t}\t\t\r\n\t},\r\n\r\n\r\n\t//Internal function for removing a marker from everything.\r\n\t//dontUpdateMap: set to true if you will handle updating the map manually (for bulk functions)\r\n\t_removeLayer: function (marker, removeFromDistanceGrid, dontUpdateMap) {\r\n\t\tvar gridClusters = this._gridClusters,\r\n\t\t\tgridUnclustered = this._gridUnclustered,\r\n\t\t\tfg = this._featureGroup,\r\n\t\t\tmap = this._map,\r\n\t\t\tminZoom = Math.floor(this._map.getMinZoom());\r\n\r\n\t\t//Remove the marker from distance clusters it might be in\r\n\t\tif (removeFromDistanceGrid) {\r\n\t\t\tthis._removeFromGridUnclustered(marker, this._maxZoom);\r\n\t\t}\r\n\r\n\t\t//Work our way up the clusters removing them as we go if required\r\n\t\tvar cluster = marker.__parent,\r\n\t\t\tmarkers = cluster._markers,\r\n\t\t\totherMarker;\r\n\r\n\t\t//Remove the marker from the immediate parents marker list\r\n\t\tthis._arraySplice(markers, marker);\r\n\r\n\t\twhile (cluster) {\r\n\t\t\tcluster._childCount--;\r\n\t\t\tcluster._boundsNeedUpdate = true;\r\n\r\n\t\t\tif (cluster._zoom < minZoom) {\r\n\t\t\t\t//Top level, do nothing\r\n\t\t\t\tbreak;\r\n\t\t\t} else if (removeFromDistanceGrid && cluster._childCount <= 1) { //Cluster no longer required\r\n\t\t\t\t//We need to push the other marker up to the parent\r\n\t\t\t\totherMarker = cluster._markers[0] === marker ? cluster._markers[1] : cluster._markers[0];\r\n\r\n\t\t\t\t//Update distance grid\r\n\t\t\t\tgridClusters[cluster._zoom].removeObject(cluster, map.project(cluster._cLatLng, cluster._zoom));\r\n\t\t\t\tgridUnclustered[cluster._zoom].addObject(otherMarker, map.project(otherMarker.getLatLng(), cluster._zoom));\r\n\r\n\t\t\t\t//Move otherMarker up to parent\r\n\t\t\t\tthis._arraySplice(cluster.__parent._childClusters, cluster);\r\n\t\t\t\tcluster.__parent._markers.push(otherMarker);\r\n\t\t\t\totherMarker.__parent = cluster.__parent;\r\n\r\n\t\t\t\tif (cluster._icon) {\r\n\t\t\t\t\t//Cluster is currently on the map, need to put the marker on the map instead\r\n\t\t\t\t\tfg.removeLayer(cluster);\r\n\t\t\t\t\tif (!dontUpdateMap) {\r\n\t\t\t\t\t\tfg.addLayer(otherMarker);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tcluster._iconNeedsUpdate = true;\r\n\t\t\t}\r\n\r\n\t\t\tcluster = cluster.__parent;\r\n\t\t}\r\n\r\n\t\tdelete marker.__parent;\r\n\t},\r\n\r\n\t_isOrIsParent: function (el, oel) {\r\n\t\twhile (oel) {\r\n\t\t\tif (el === oel) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\toel = oel.parentNode;\r\n\t\t}\r\n\t\treturn false;\r\n\t},\r\n\r\n\t//Override L.Evented.fire\r\n\tfire: function (type, data, propagate) {\r\n\t\tif (data && data.layer instanceof L.MarkerCluster) {\r\n\t\t\t//Prevent multiple clustermouseover/off events if the icon is made up of stacked divs (Doesn't work in ie <= 8, no relatedTarget)\r\n\t\t\tif (data.originalEvent && this._isOrIsParent(data.layer._icon, data.originalEvent.relatedTarget)) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\ttype = 'cluster' + type;\r\n\t\t}\r\n\r\n\t\tL.FeatureGroup.prototype.fire.call(this, type, data, propagate);\r\n\t},\r\n\r\n\t//Override L.Evented.listens\r\n\tlistens: function (type, propagate) {\r\n\t\treturn L.FeatureGroup.prototype.listens.call(this, type, propagate) || L.FeatureGroup.prototype.listens.call(this, 'cluster' + type, propagate);\r\n\t},\r\n\r\n\t//Default functionality\r\n\t_defaultIconCreateFunction: function (cluster) {\r\n\t\tvar childCount = cluster.getChildCount();\r\n\r\n\t\tvar c = ' marker-cluster-';\r\n\t\tif (childCount < 10) {\r\n\t\t\tc += 'small';\r\n\t\t} else if (childCount < 100) {\r\n\t\t\tc += 'medium';\r\n\t\t} else {\r\n\t\t\tc += 'large';\r\n\t\t}\r\n\r\n\t\treturn new L.DivIcon({ html: '<div><span>' + childCount + '</span></div>', className: 'marker-cluster' + c, iconSize: new L.Point(40, 40) });\r\n\t},\r\n\r\n\t_bindEvents: function () {\r\n\t\tvar map = this._map,\r\n\t\t    spiderfyOnMaxZoom = this.options.spiderfyOnMaxZoom,\r\n\t\t    showCoverageOnHover = this.options.showCoverageOnHover,\r\n\t\t    zoomToBoundsOnClick = this.options.zoomToBoundsOnClick;\r\n\r\n\t\t//Zoom on cluster click or spiderfy if we are at the lowest level\r\n\t\tif (spiderfyOnMaxZoom || zoomToBoundsOnClick) {\r\n\t\t\tthis.on('clusterclick', this._zoomOrSpiderfy, this);\r\n\t\t}\r\n\r\n\t\t//Show convex hull (boundary) polygon on mouse over\r\n\t\tif (showCoverageOnHover) {\r\n\t\t\tthis.on('clustermouseover', this._showCoverage, this);\r\n\t\t\tthis.on('clustermouseout', this._hideCoverage, this);\r\n\t\t\tmap.on('zoomend', this._hideCoverage, this);\r\n\t\t}\r\n\t},\r\n\r\n\t_zoomOrSpiderfy: function (e) {\r\n\t\tvar cluster = e.layer,\r\n\t\t    bottomCluster = cluster;\r\n\r\n\t\twhile (bottomCluster._childClusters.length === 1) {\r\n\t\t\tbottomCluster = bottomCluster._childClusters[0];\r\n\t\t}\r\n\r\n\t\tif (bottomCluster._zoom === this._maxZoom &&\r\n\t\t\tbottomCluster._childCount === cluster._childCount &&\r\n\t\t\tthis.options.spiderfyOnMaxZoom) {\r\n\r\n\t\t\t// All child markers are contained in a single cluster from this._maxZoom to this cluster.\r\n\t\t\tcluster.spiderfy();\r\n\t\t} else if (this.options.zoomToBoundsOnClick) {\r\n\t\t\tcluster.zoomToBounds();\r\n\t\t}\r\n\r\n\t\t// Focus the map again for keyboard users.\r\n\t\tif (e.originalEvent && e.originalEvent.keyCode === 13) {\r\n\t\t\tthis._map._container.focus();\r\n\t\t}\r\n\t},\r\n\r\n\t_showCoverage: function (e) {\r\n\t\tvar map = this._map;\r\n\t\tif (this._inZoomAnimation) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (this._shownPolygon) {\r\n\t\t\tmap.removeLayer(this._shownPolygon);\r\n\t\t}\r\n\t\tif (e.layer.getChildCount() > 2 && e.layer !== this._spiderfied) {\r\n\t\t\tthis._shownPolygon = new L.Polygon(e.layer.getConvexHull(), this.options.polygonOptions);\r\n\t\t\tmap.addLayer(this._shownPolygon);\r\n\t\t}\r\n\t},\r\n\r\n\t_hideCoverage: function () {\r\n\t\tif (this._shownPolygon) {\r\n\t\t\tthis._map.removeLayer(this._shownPolygon);\r\n\t\t\tthis._shownPolygon = null;\r\n\t\t}\r\n\t},\r\n\r\n\t_unbindEvents: function () {\r\n\t\tvar spiderfyOnMaxZoom = this.options.spiderfyOnMaxZoom,\r\n\t\t\tshowCoverageOnHover = this.options.showCoverageOnHover,\r\n\t\t\tzoomToBoundsOnClick = this.options.zoomToBoundsOnClick,\r\n\t\t\tmap = this._map;\r\n\r\n\t\tif (spiderfyOnMaxZoom || zoomToBoundsOnClick) {\r\n\t\t\tthis.off('clusterclick', this._zoomOrSpiderfy, this);\r\n\t\t}\r\n\t\tif (showCoverageOnHover) {\r\n\t\t\tthis.off('clustermouseover', this._showCoverage, this);\r\n\t\t\tthis.off('clustermouseout', this._hideCoverage, this);\r\n\t\t\tmap.off('zoomend', this._hideCoverage, this);\r\n\t\t}\r\n\t},\r\n\r\n\t_zoomEnd: function () {\r\n\t\tif (!this._map) { //May have been removed from the map by a zoomEnd handler\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tthis._mergeSplitClusters();\r\n\r\n\t\tthis._zoom = Math.round(this._map._zoom);\r\n\t\tthis._currentShownBounds = this._getExpandedVisibleBounds();\r\n\t},\r\n\r\n\t_moveEnd: function () {\r\n\t\tif (this._inZoomAnimation) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar newBounds = this._getExpandedVisibleBounds();\r\n\r\n\t\tthis._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), this._zoom, newBounds);\r\n\t\tthis._topClusterLevel._recursivelyAddChildrenToMap(null, Math.round(this._map._zoom), newBounds);\r\n\r\n\t\tthis._currentShownBounds = newBounds;\r\n\t\treturn;\r\n\t},\r\n\r\n\t_generateInitialClusters: function () {\r\n\t\tvar maxZoom = Math.ceil(this._map.getMaxZoom()),\r\n\t\t\tminZoom = Math.floor(this._map.getMinZoom()),\r\n\t\t\tradius = this.options.maxClusterRadius,\r\n\t\t\tradiusFn = radius;\r\n\r\n\t\t//If we just set maxClusterRadius to a single number, we need to create\r\n\t\t//a simple function to return that number. Otherwise, we just have to\r\n\t\t//use the function we've passed in.\r\n\t\tif (typeof radius !== \"function\") {\r\n\t\t\tradiusFn = function () { return radius; };\r\n\t\t}\r\n\r\n\t\tif (this.options.disableClusteringAtZoom !== null) {\r\n\t\t\tmaxZoom = this.options.disableClusteringAtZoom - 1;\r\n\t\t}\r\n\t\tthis._maxZoom = maxZoom;\r\n\t\tthis._gridClusters = {};\r\n\t\tthis._gridUnclustered = {};\r\n\r\n\t\t//Set up DistanceGrids for each zoom\r\n\t\tfor (var zoom = maxZoom; zoom >= minZoom; zoom--) {\r\n\t\t\tthis._gridClusters[zoom] = new L.DistanceGrid(radiusFn(zoom));\r\n\t\t\tthis._gridUnclustered[zoom] = new L.DistanceGrid(radiusFn(zoom));\r\n\t\t}\r\n\r\n\t\t// Instantiate the appropriate L.MarkerCluster class (animated or not).\r\n\t\tthis._topClusterLevel = new this._markerCluster(this, minZoom - 1);\r\n\t},\r\n\r\n\t//Zoom: Zoom to start adding at (Pass this._maxZoom to start at the bottom)\r\n\t_addLayer: function (layer, zoom) {\r\n\t\tvar gridClusters = this._gridClusters,\r\n\t\t    gridUnclustered = this._gridUnclustered,\r\n\t\t\tminZoom = Math.floor(this._map.getMinZoom()),\r\n\t\t    markerPoint, z;\r\n\r\n\t\tif (this.options.singleMarkerMode) {\r\n\t\t\tthis._overrideMarkerIcon(layer);\r\n\t\t}\r\n\r\n\t\tlayer.on(this._childMarkerEventHandlers, this);\r\n\r\n\t\t//Find the lowest zoom level to slot this one in\r\n\t\tfor (; zoom >= minZoom; zoom--) {\r\n\t\t\tmarkerPoint = this._map.project(layer.getLatLng(), zoom); // calculate pixel position\r\n\r\n\t\t\t//Try find a cluster close by\r\n\t\t\tvar closest = gridClusters[zoom].getNearObject(markerPoint);\r\n\t\t\tif (closest) {\r\n\t\t\t\tclosest._addChild(layer);\r\n\t\t\t\tlayer.__parent = closest;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t//Try find a marker close by to form a new cluster with\r\n\t\t\tclosest = gridUnclustered[zoom].getNearObject(markerPoint);\r\n\t\t\tif (closest) {\r\n\t\t\t\tvar parent = closest.__parent;\r\n\t\t\t\tif (parent) {\r\n\t\t\t\t\tthis._removeLayer(closest, false);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t//Create new cluster with these 2 in it\r\n\r\n\t\t\t\tvar newCluster = new this._markerCluster(this, zoom, closest, layer);\r\n\t\t\t\tgridClusters[zoom].addObject(newCluster, this._map.project(newCluster._cLatLng, zoom));\r\n\t\t\t\tclosest.__parent = newCluster;\r\n\t\t\t\tlayer.__parent = newCluster;\r\n\r\n\t\t\t\t//First create any new intermediate parent clusters that don't exist\r\n\t\t\t\tvar lastParent = newCluster;\r\n\t\t\t\tfor (z = zoom - 1; z > parent._zoom; z--) {\r\n\t\t\t\t\tlastParent = new this._markerCluster(this, z, lastParent);\r\n\t\t\t\t\tgridClusters[z].addObject(lastParent, this._map.project(closest.getLatLng(), z));\r\n\t\t\t\t}\r\n\t\t\t\tparent._addChild(lastParent);\r\n\r\n\t\t\t\t//Remove closest from this zoom level and any above that it is in, replace with newCluster\r\n\t\t\t\tthis._removeFromGridUnclustered(closest, zoom);\r\n\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t//Didn't manage to cluster in at this zoom, record us as a marker here and continue upwards\r\n\t\t\tgridUnclustered[zoom].addObject(layer, markerPoint);\r\n\t\t}\r\n\r\n\t\t//Didn't get in anything, add us to the top\r\n\t\tthis._topClusterLevel._addChild(layer);\r\n\t\tlayer.__parent = this._topClusterLevel;\r\n\t\treturn;\r\n\t},\r\n\r\n\t/**\r\n\t * Refreshes the icon of all \"dirty\" visible clusters.\r\n\t * Non-visible \"dirty\" clusters will be updated when they are added to the map.\r\n\t * @private\r\n\t */\r\n\t_refreshClustersIcons: function () {\r\n\t\tthis._featureGroup.eachLayer(function (c) {\r\n\t\t\tif (c instanceof L.MarkerCluster && c._iconNeedsUpdate) {\r\n\t\t\t\tc._updateIcon();\r\n\t\t\t}\r\n\t\t});\r\n\t},\r\n\r\n\t//Enqueue code to fire after the marker expand/contract has happened\r\n\t_enqueue: function (fn) {\r\n\t\tthis._queue.push(fn);\r\n\t\tif (!this._queueTimeout) {\r\n\t\t\tthis._queueTimeout = setTimeout(L.bind(this._processQueue, this), 300);\r\n\t\t}\r\n\t},\r\n\t_processQueue: function () {\r\n\t\tfor (var i = 0; i < this._queue.length; i++) {\r\n\t\t\tthis._queue[i].call(this);\r\n\t\t}\r\n\t\tthis._queue.length = 0;\r\n\t\tclearTimeout(this._queueTimeout);\r\n\t\tthis._queueTimeout = null;\r\n\t},\r\n\r\n\t//Merge and split any existing clusters that are too big or small\r\n\t_mergeSplitClusters: function () {\r\n\t\tvar mapZoom = Math.round(this._map._zoom);\r\n\r\n\t\t//In case we are starting to split before the animation finished\r\n\t\tthis._processQueue();\r\n\r\n\t\tif (this._zoom < mapZoom && this._currentShownBounds.intersects(this._getExpandedVisibleBounds())) { //Zoom in, split\r\n\t\t\tthis._animationStart();\r\n\t\t\t//Remove clusters now off screen\r\n\t\t\tthis._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), this._zoom, this._getExpandedVisibleBounds());\r\n\r\n\t\t\tthis._animationZoomIn(this._zoom, mapZoom);\r\n\r\n\t\t} else if (this._zoom > mapZoom) { //Zoom out, merge\r\n\t\t\tthis._animationStart();\r\n\r\n\t\t\tthis._animationZoomOut(this._zoom, mapZoom);\r\n\t\t} else {\r\n\t\t\tthis._moveEnd();\r\n\t\t}\r\n\t},\r\n\r\n\t//Gets the maps visible bounds expanded in each direction by the size of the screen (so the user cannot see an area we do not cover in one pan)\r\n\t_getExpandedVisibleBounds: function () {\r\n\t\tif (!this.options.removeOutsideVisibleBounds) {\r\n\t\t\treturn this._mapBoundsInfinite;\r\n\t\t} else if (L.Browser.mobile) {\r\n\t\t\treturn this._checkBoundsMaxLat(this._map.getBounds());\r\n\t\t}\r\n\r\n\t\treturn this._checkBoundsMaxLat(this._map.getBounds().pad(1)); // Padding expands the bounds by its own dimensions but scaled with the given factor.\r\n\t},\r\n\r\n\t/**\r\n\t * Expands the latitude to Infinity (or -Infinity) if the input bounds reach the map projection maximum defined latitude\r\n\t * (in the case of Web/Spherical Mercator, it is 85.0511287798 / see https://en.wikipedia.org/wiki/Web_Mercator#Formulas).\r\n\t * Otherwise, the removeOutsideVisibleBounds option will remove markers beyond that limit, whereas the same markers without\r\n\t * this option (or outside MCG) will have their position floored (ceiled) by the projection and rendered at that limit,\r\n\t * making the user think that MCG \"eats\" them and never displays them again.\r\n\t * @param bounds L.LatLngBounds\r\n\t * @returns {L.LatLngBounds}\r\n\t * @private\r\n\t */\r\n\t_checkBoundsMaxLat: function (bounds) {\r\n\t\tvar maxLat = this._maxLat;\r\n\r\n\t\tif (maxLat !== undefined) {\r\n\t\t\tif (bounds.getNorth() >= maxLat) {\r\n\t\t\t\tbounds._northEast.lat = Infinity;\r\n\t\t\t}\r\n\t\t\tif (bounds.getSouth() <= -maxLat) {\r\n\t\t\t\tbounds._southWest.lat = -Infinity;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn bounds;\r\n\t},\r\n\r\n\t//Shared animation code\r\n\t_animationAddLayerNonAnimated: function (layer, newCluster) {\r\n\t\tif (newCluster === layer) {\r\n\t\t\tthis._featureGroup.addLayer(layer);\r\n\t\t} else if (newCluster._childCount === 2) {\r\n\t\t\tnewCluster._addToMap();\r\n\r\n\t\t\tvar markers = newCluster.getAllChildMarkers();\r\n\t\t\tthis._featureGroup.removeLayer(markers[0]);\r\n\t\t\tthis._featureGroup.removeLayer(markers[1]);\r\n\t\t} else {\r\n\t\t\tnewCluster._updateIcon();\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t * Extracts individual (i.e. non-group) layers from a Layer Group.\r\n\t * @param group to extract layers from.\r\n\t * @param output {Array} in which to store the extracted layers.\r\n\t * @returns {*|Array}\r\n\t * @private\r\n\t */\r\n\t_extractNonGroupLayers: function (group, output) {\r\n\t\tvar layers = group.getLayers(),\r\n\t\t    i = 0,\r\n\t\t    layer;\r\n\r\n\t\toutput = output || [];\r\n\r\n\t\tfor (; i < layers.length; i++) {\r\n\t\t\tlayer = layers[i];\r\n\r\n\t\t\tif (layer instanceof L.LayerGroup) {\r\n\t\t\t\tthis._extractNonGroupLayers(layer, output);\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\toutput.push(layer);\r\n\t\t}\r\n\r\n\t\treturn output;\r\n\t},\r\n\r\n\t/**\r\n\t * Implements the singleMarkerMode option.\r\n\t * @param layer Marker to re-style using the Clusters iconCreateFunction.\r\n\t * @returns {L.Icon} The newly created icon.\r\n\t * @private\r\n\t */\r\n\t_overrideMarkerIcon: function (layer) {\r\n\t\tvar icon = layer.options.icon = this.options.iconCreateFunction({\r\n\t\t\tgetChildCount: function () {\r\n\t\t\t\treturn 1;\r\n\t\t\t},\r\n\t\t\tgetAllChildMarkers: function () {\r\n\t\t\t\treturn [layer];\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn icon;\r\n\t}\r\n});\r\n\r\n// Constant bounds used in case option \"removeOutsideVisibleBounds\" is set to false.\r\nL.MarkerClusterGroup.include({\r\n\t_mapBoundsInfinite: new L.LatLngBounds(new L.LatLng(-Infinity, -Infinity), new L.LatLng(Infinity, Infinity))\r\n});\r\n\r\nL.MarkerClusterGroup.include({\r\n\t_noAnimation: {\r\n\t\t//Non Animated versions of everything\r\n\t\t_animationStart: function () {\r\n\t\t\t//Do nothing...\r\n\t\t},\r\n\t\t_animationZoomIn: function (previousZoomLevel, newZoomLevel) {\r\n\t\t\tthis._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), previousZoomLevel);\r\n\t\t\tthis._topClusterLevel._recursivelyAddChildrenToMap(null, newZoomLevel, this._getExpandedVisibleBounds());\r\n\r\n\t\t\t//We didn't actually animate, but we use this event to mean \"clustering animations have finished\"\r\n\t\t\tthis.fire('animationend');\r\n\t\t},\r\n\t\t_animationZoomOut: function (previousZoomLevel, newZoomLevel) {\r\n\t\t\tthis._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), previousZoomLevel);\r\n\t\t\tthis._topClusterLevel._recursivelyAddChildrenToMap(null, newZoomLevel, this._getExpandedVisibleBounds());\r\n\r\n\t\t\t//We didn't actually animate, but we use this event to mean \"clustering animations have finished\"\r\n\t\t\tthis.fire('animationend');\r\n\t\t},\r\n\t\t_animationAddLayer: function (layer, newCluster) {\r\n\t\t\tthis._animationAddLayerNonAnimated(layer, newCluster);\r\n\t\t}\r\n\t},\r\n\r\n\t_withAnimation: {\r\n\t\t//Animated versions here\r\n\t\t_animationStart: function () {\r\n\t\t\tthis._map._mapPane.className += ' leaflet-cluster-anim';\r\n\t\t\tthis._inZoomAnimation++;\r\n\t\t},\r\n\r\n\t\t_animationZoomIn: function (previousZoomLevel, newZoomLevel) {\r\n\t\t\tvar bounds = this._getExpandedVisibleBounds(),\r\n\t\t\t    fg = this._featureGroup,\r\n\t\t\t\tminZoom = Math.floor(this._map.getMinZoom()),\r\n\t\t\t    i;\r\n\r\n\t\t\tthis._ignoreMove = true;\r\n\r\n\t\t\t//Add all children of current clusters to map and remove those clusters from map\r\n\t\t\tthis._topClusterLevel._recursively(bounds, previousZoomLevel, minZoom, function (c) {\r\n\t\t\t\tvar startPos = c._latlng,\r\n\t\t\t\t    markers  = c._markers,\r\n\t\t\t\t    m;\r\n\r\n\t\t\t\tif (!bounds.contains(startPos)) {\r\n\t\t\t\t\tstartPos = null;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (c._isSingleParent() && previousZoomLevel + 1 === newZoomLevel) { //Immediately add the new child and remove us\r\n\t\t\t\t\tfg.removeLayer(c);\r\n\t\t\t\t\tc._recursivelyAddChildrenToMap(null, newZoomLevel, bounds);\r\n\t\t\t\t} else {\r\n\t\t\t\t\t//Fade out old cluster\r\n\t\t\t\t\tc.clusterHide();\r\n\t\t\t\t\tc._recursivelyAddChildrenToMap(startPos, newZoomLevel, bounds);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t//Remove all markers that aren't visible any more\r\n\t\t\t\t//TODO: Do we actually need to do this on the higher levels too?\r\n\t\t\t\tfor (i = markers.length - 1; i >= 0; i--) {\r\n\t\t\t\t\tm = markers[i];\r\n\t\t\t\t\tif (!bounds.contains(m._latlng)) {\r\n\t\t\t\t\t\tfg.removeLayer(m);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t});\r\n\r\n\t\t\tthis._forceLayout();\r\n\r\n\t\t\t//Update opacities\r\n\t\t\tthis._topClusterLevel._recursivelyBecomeVisible(bounds, newZoomLevel);\r\n\t\t\t//TODO Maybe? Update markers in _recursivelyBecomeVisible\r\n\t\t\tfg.eachLayer(function (n) {\r\n\t\t\t\tif (!(n instanceof L.MarkerCluster) && n._icon) {\r\n\t\t\t\t\tn.clusterShow();\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\t//update the positions of the just added clusters/markers\r\n\t\t\tthis._topClusterLevel._recursively(bounds, previousZoomLevel, newZoomLevel, function (c) {\r\n\t\t\t\tc._recursivelyRestoreChildPositions(newZoomLevel);\r\n\t\t\t});\r\n\r\n\t\t\tthis._ignoreMove = false;\r\n\r\n\t\t\t//Remove the old clusters and close the zoom animation\r\n\t\t\tthis._enqueue(function () {\r\n\t\t\t\t//update the positions of the just added clusters/markers\r\n\t\t\t\tthis._topClusterLevel._recursively(bounds, previousZoomLevel, minZoom, function (c) {\r\n\t\t\t\t\tfg.removeLayer(c);\r\n\t\t\t\t\tc.clusterShow();\r\n\t\t\t\t});\r\n\r\n\t\t\t\tthis._animationEnd();\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\t_animationZoomOut: function (previousZoomLevel, newZoomLevel) {\r\n\t\t\tthis._animationZoomOutSingle(this._topClusterLevel, previousZoomLevel - 1, newZoomLevel);\r\n\r\n\t\t\t//Need to add markers for those that weren't on the map before but are now\r\n\t\t\tthis._topClusterLevel._recursivelyAddChildrenToMap(null, newZoomLevel, this._getExpandedVisibleBounds());\r\n\t\t\t//Remove markers that were on the map before but won't be now\r\n\t\t\tthis._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), previousZoomLevel, this._getExpandedVisibleBounds());\r\n\t\t},\r\n\r\n\t\t_animationAddLayer: function (layer, newCluster) {\r\n\t\t\tvar me = this,\r\n\t\t\t    fg = this._featureGroup;\r\n\r\n\t\t\tfg.addLayer(layer);\r\n\t\t\tif (newCluster !== layer) {\r\n\t\t\t\tif (newCluster._childCount > 2) { //Was already a cluster\r\n\r\n\t\t\t\t\tnewCluster._updateIcon();\r\n\t\t\t\t\tthis._forceLayout();\r\n\t\t\t\t\tthis._animationStart();\r\n\r\n\t\t\t\t\tlayer._setPos(this._map.latLngToLayerPoint(newCluster.getLatLng()));\r\n\t\t\t\t\tlayer.clusterHide();\r\n\r\n\t\t\t\t\tthis._enqueue(function () {\r\n\t\t\t\t\t\tfg.removeLayer(layer);\r\n\t\t\t\t\t\tlayer.clusterShow();\r\n\r\n\t\t\t\t\t\tme._animationEnd();\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t} else { //Just became a cluster\r\n\t\t\t\t\tthis._forceLayout();\r\n\r\n\t\t\t\t\tme._animationStart();\r\n\t\t\t\t\tme._animationZoomOutSingle(newCluster, this._map.getMaxZoom(), this._zoom);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t// Private methods for animated versions.\r\n\t_animationZoomOutSingle: function (cluster, previousZoomLevel, newZoomLevel) {\r\n\t\tvar bounds = this._getExpandedVisibleBounds(),\r\n\t\t\tminZoom = Math.floor(this._map.getMinZoom());\r\n\r\n\t\t//Animate all of the markers in the clusters to move to their cluster center point\r\n\t\tcluster._recursivelyAnimateChildrenInAndAddSelfToMap(bounds, minZoom, previousZoomLevel + 1, newZoomLevel);\r\n\r\n\t\tvar me = this;\r\n\r\n\t\t//Update the opacity (If we immediately set it they won't animate)\r\n\t\tthis._forceLayout();\r\n\t\tcluster._recursivelyBecomeVisible(bounds, newZoomLevel);\r\n\r\n\t\t//TODO: Maybe use the transition timing stuff to make this more reliable\r\n\t\t//When the animations are done, tidy up\r\n\t\tthis._enqueue(function () {\r\n\r\n\t\t\t//This cluster stopped being a cluster before the timeout fired\r\n\t\t\tif (cluster._childCount === 1) {\r\n\t\t\t\tvar m = cluster._markers[0];\r\n\t\t\t\t//If we were in a cluster animation at the time then the opacity and position of our child could be wrong now, so fix it\r\n\t\t\t\tthis._ignoreMove = true;\r\n\t\t\t\tm.setLatLng(m.getLatLng());\r\n\t\t\t\tthis._ignoreMove = false;\r\n\t\t\t\tif (m.clusterShow) {\r\n\t\t\t\t\tm.clusterShow();\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tcluster._recursively(bounds, newZoomLevel, minZoom, function (c) {\r\n\t\t\t\t\tc._recursivelyRemoveChildrenFromMap(bounds, minZoom, previousZoomLevel + 1);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\tme._animationEnd();\r\n\t\t});\r\n\t},\r\n\r\n\t_animationEnd: function () {\r\n\t\tif (this._map) {\r\n\t\t\tthis._map._mapPane.className = this._map._mapPane.className.replace(' leaflet-cluster-anim', '');\r\n\t\t}\r\n\t\tthis._inZoomAnimation--;\r\n\t\tthis.fire('animationend');\r\n\t},\r\n\r\n\t//Force a browser layout of stuff in the map\r\n\t// Should apply the current opacity and location to all elements so we can update them again for an animation\r\n\t_forceLayout: function () {\r\n\t\t//In my testing this works, infact offsetWidth of any element seems to work.\r\n\t\t//Could loop all this._layers and do this for each _icon if it stops working\r\n\r\n\t\tL.Util.falseFn(document.body.offsetWidth);\r\n\t}\r\n});\r\n\r\nL.markerClusterGroup = function (options) {\r\n\treturn new L.MarkerClusterGroup(options);\r\n};\n\nvar MarkerCluster = L.MarkerCluster = L.Marker.extend({\r\n\toptions: L.Icon.prototype.options,\r\n\r\n\tinitialize: function (group, zoom, a, b) {\r\n\r\n\t\tL.Marker.prototype.initialize.call(this, a ? (a._cLatLng || a.getLatLng()) : new L.LatLng(0, 0),\r\n            { icon: this, pane: group.options.clusterPane });\r\n\r\n\t\tthis._group = group;\r\n\t\tthis._zoom = zoom;\r\n\r\n\t\tthis._markers = [];\r\n\t\tthis._childClusters = [];\r\n\t\tthis._childCount = 0;\r\n\t\tthis._iconNeedsUpdate = true;\r\n\t\tthis._boundsNeedUpdate = true;\r\n\r\n\t\tthis._bounds = new L.LatLngBounds();\r\n\r\n\t\tif (a) {\r\n\t\t\tthis._addChild(a);\r\n\t\t}\r\n\t\tif (b) {\r\n\t\t\tthis._addChild(b);\r\n\t\t}\r\n\t},\r\n\r\n\t//Recursively retrieve all child markers of this cluster\r\n\tgetAllChildMarkers: function (storageArray, ignoreDraggedMarker) {\r\n\t\tstorageArray = storageArray || [];\r\n\r\n\t\tfor (var i = this._childClusters.length - 1; i >= 0; i--) {\r\n\t\t\tthis._childClusters[i].getAllChildMarkers(storageArray);\r\n\t\t}\r\n\r\n\t\tfor (var j = this._markers.length - 1; j >= 0; j--) {\r\n\t\t\tif (ignoreDraggedMarker && this._markers[j].__dragStart) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tstorageArray.push(this._markers[j]);\r\n\t\t}\r\n\r\n\t\treturn storageArray;\r\n\t},\r\n\r\n\t//Returns the count of how many child markers we have\r\n\tgetChildCount: function () {\r\n\t\treturn this._childCount;\r\n\t},\r\n\r\n\t//Zoom to the minimum of showing all of the child markers, or the extents of this cluster\r\n\tzoomToBounds: function (fitBoundsOptions) {\r\n\t\tvar childClusters = this._childClusters.slice(),\r\n\t\t\tmap = this._group._map,\r\n\t\t\tboundsZoom = map.getBoundsZoom(this._bounds),\r\n\t\t\tzoom = this._zoom + 1,\r\n\t\t\tmapZoom = map.getZoom(),\r\n\t\t\ti;\r\n\r\n\t\t//calculate how far we need to zoom down to see all of the markers\r\n\t\twhile (childClusters.length > 0 && boundsZoom > zoom) {\r\n\t\t\tzoom++;\r\n\t\t\tvar newClusters = [];\r\n\t\t\tfor (i = 0; i < childClusters.length; i++) {\r\n\t\t\t\tnewClusters = newClusters.concat(childClusters[i]._childClusters);\r\n\t\t\t}\r\n\t\t\tchildClusters = newClusters;\r\n\t\t}\r\n\r\n\t\tif (boundsZoom > zoom) {\r\n\t\t\tthis._group._map.setView(this._latlng, zoom);\r\n\t\t} else if (boundsZoom <= mapZoom) { //If fitBounds wouldn't zoom us down, zoom us down instead\r\n\t\t\tthis._group._map.setView(this._latlng, mapZoom + 1);\r\n\t\t} else {\r\n\t\t\tthis._group._map.fitBounds(this._bounds, fitBoundsOptions);\r\n\t\t}\r\n\t},\r\n\r\n\tgetBounds: function () {\r\n\t\tvar bounds = new L.LatLngBounds();\r\n\t\tbounds.extend(this._bounds);\r\n\t\treturn bounds;\r\n\t},\r\n\r\n\t_updateIcon: function () {\r\n\t\tthis._iconNeedsUpdate = true;\r\n\t\tif (this._icon) {\r\n\t\t\tthis.setIcon(this);\r\n\t\t}\r\n\t},\r\n\r\n\t//Cludge for Icon, we pretend to be an icon for performance\r\n\tcreateIcon: function () {\r\n\t\tif (this._iconNeedsUpdate) {\r\n\t\t\tthis._iconObj = this._group.options.iconCreateFunction(this);\r\n\t\t\tthis._iconNeedsUpdate = false;\r\n\t\t}\r\n\t\treturn this._iconObj.createIcon();\r\n\t},\r\n\tcreateShadow: function () {\r\n\t\treturn this._iconObj.createShadow();\r\n\t},\r\n\r\n\r\n\t_addChild: function (new1, isNotificationFromChild) {\r\n\r\n\t\tthis._iconNeedsUpdate = true;\r\n\r\n\t\tthis._boundsNeedUpdate = true;\r\n\t\tthis._setClusterCenter(new1);\r\n\r\n\t\tif (new1 instanceof L.MarkerCluster) {\r\n\t\t\tif (!isNotificationFromChild) {\r\n\t\t\t\tthis._childClusters.push(new1);\r\n\t\t\t\tnew1.__parent = this;\r\n\t\t\t}\r\n\t\t\tthis._childCount += new1._childCount;\r\n\t\t} else {\r\n\t\t\tif (!isNotificationFromChild) {\r\n\t\t\t\tthis._markers.push(new1);\r\n\t\t\t}\r\n\t\t\tthis._childCount++;\r\n\t\t}\r\n\r\n\t\tif (this.__parent) {\r\n\t\t\tthis.__parent._addChild(new1, true);\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t * Makes sure the cluster center is set. If not, uses the child center if it is a cluster, or the marker position.\r\n\t * @param child L.MarkerCluster|L.Marker that will be used as cluster center if not defined yet.\r\n\t * @private\r\n\t */\r\n\t_setClusterCenter: function (child) {\r\n\t\tif (!this._cLatLng) {\r\n\t\t\t// when clustering, take position of the first point as the cluster center\r\n\t\t\tthis._cLatLng = child._cLatLng || child._latlng;\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t * Assigns impossible bounding values so that the next extend entirely determines the new bounds.\r\n\t * This method avoids having to trash the previous L.LatLngBounds object and to create a new one, which is much slower for this class.\r\n\t * As long as the bounds are not extended, most other methods would probably fail, as they would with bounds initialized but not extended.\r\n\t * @private\r\n\t */\r\n\t_resetBounds: function () {\r\n\t\tvar bounds = this._bounds;\r\n\r\n\t\tif (bounds._southWest) {\r\n\t\t\tbounds._southWest.lat = Infinity;\r\n\t\t\tbounds._southWest.lng = Infinity;\r\n\t\t}\r\n\t\tif (bounds._northEast) {\r\n\t\t\tbounds._northEast.lat = -Infinity;\r\n\t\t\tbounds._northEast.lng = -Infinity;\r\n\t\t}\r\n\t},\r\n\r\n\t_recalculateBounds: function () {\r\n\t\tvar markers = this._markers,\r\n\t\t    childClusters = this._childClusters,\r\n\t\t    latSum = 0,\r\n\t\t    lngSum = 0,\r\n\t\t    totalCount = this._childCount,\r\n\t\t    i, child, childLatLng, childCount;\r\n\r\n\t\t// Case where all markers are removed from the map and we are left with just an empty _topClusterLevel.\r\n\t\tif (totalCount === 0) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Reset rather than creating a new object, for performance.\r\n\t\tthis._resetBounds();\r\n\r\n\t\t// Child markers.\r\n\t\tfor (i = 0; i < markers.length; i++) {\r\n\t\t\tchildLatLng = markers[i]._latlng;\r\n\r\n\t\t\tthis._bounds.extend(childLatLng);\r\n\r\n\t\t\tlatSum += childLatLng.lat;\r\n\t\t\tlngSum += childLatLng.lng;\r\n\t\t}\r\n\r\n\t\t// Child clusters.\r\n\t\tfor (i = 0; i < childClusters.length; i++) {\r\n\t\t\tchild = childClusters[i];\r\n\r\n\t\t\t// Re-compute child bounds and weighted position first if necessary.\r\n\t\t\tif (child._boundsNeedUpdate) {\r\n\t\t\t\tchild._recalculateBounds();\r\n\t\t\t}\r\n\r\n\t\t\tthis._bounds.extend(child._bounds);\r\n\r\n\t\t\tchildLatLng = child._wLatLng;\r\n\t\t\tchildCount = child._childCount;\r\n\r\n\t\t\tlatSum += childLatLng.lat * childCount;\r\n\t\t\tlngSum += childLatLng.lng * childCount;\r\n\t\t}\r\n\r\n\t\tthis._latlng = this._wLatLng = new L.LatLng(latSum / totalCount, lngSum / totalCount);\r\n\r\n\t\t// Reset dirty flag.\r\n\t\tthis._boundsNeedUpdate = false;\r\n\t},\r\n\r\n\t//Set our markers position as given and add it to the map\r\n\t_addToMap: function (startPos) {\r\n\t\tif (startPos) {\r\n\t\t\tthis._backupLatlng = this._latlng;\r\n\t\t\tthis.setLatLng(startPos);\r\n\t\t}\r\n\t\tthis._group._featureGroup.addLayer(this);\r\n\t},\r\n\r\n\t_recursivelyAnimateChildrenIn: function (bounds, center, maxZoom) {\r\n\t\tthis._recursively(bounds, this._group._map.getMinZoom(), maxZoom - 1,\r\n\t\t\tfunction (c) {\r\n\t\t\t\tvar markers = c._markers,\r\n\t\t\t\t\ti, m;\r\n\t\t\t\tfor (i = markers.length - 1; i >= 0; i--) {\r\n\t\t\t\t\tm = markers[i];\r\n\r\n\t\t\t\t\t//Only do it if the icon is still on the map\r\n\t\t\t\t\tif (m._icon) {\r\n\t\t\t\t\t\tm._setPos(center);\r\n\t\t\t\t\t\tm.clusterHide();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tfunction (c) {\r\n\t\t\t\tvar childClusters = c._childClusters,\r\n\t\t\t\t\tj, cm;\r\n\t\t\t\tfor (j = childClusters.length - 1; j >= 0; j--) {\r\n\t\t\t\t\tcm = childClusters[j];\r\n\t\t\t\t\tif (cm._icon) {\r\n\t\t\t\t\t\tcm._setPos(center);\r\n\t\t\t\t\t\tcm.clusterHide();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\t},\r\n\r\n\t_recursivelyAnimateChildrenInAndAddSelfToMap: function (bounds, mapMinZoom, previousZoomLevel, newZoomLevel) {\r\n\t\tthis._recursively(bounds, newZoomLevel, mapMinZoom,\r\n\t\t\tfunction (c) {\r\n\t\t\t\tc._recursivelyAnimateChildrenIn(bounds, c._group._map.latLngToLayerPoint(c.getLatLng()).round(), previousZoomLevel);\r\n\r\n\t\t\t\t//TODO: depthToAnimateIn affects _isSingleParent, if there is a multizoom we may/may not be.\r\n\t\t\t\t//As a hack we only do a animation free zoom on a single level zoom, if someone does multiple levels then we always animate\r\n\t\t\t\tif (c._isSingleParent() && previousZoomLevel - 1 === newZoomLevel) {\r\n\t\t\t\t\tc.clusterShow();\r\n\t\t\t\t\tc._recursivelyRemoveChildrenFromMap(bounds, mapMinZoom, previousZoomLevel); //Immediately remove our children as we are replacing them. TODO previousBounds not bounds\r\n\t\t\t\t} else {\r\n\t\t\t\t\tc.clusterHide();\r\n\t\t\t\t}\r\n\r\n\t\t\t\tc._addToMap();\r\n\t\t\t}\r\n\t\t);\r\n\t},\r\n\r\n\t_recursivelyBecomeVisible: function (bounds, zoomLevel) {\r\n\t\tthis._recursively(bounds, this._group._map.getMinZoom(), zoomLevel, null, function (c) {\r\n\t\t\tc.clusterShow();\r\n\t\t});\r\n\t},\r\n\r\n\t_recursivelyAddChildrenToMap: function (startPos, zoomLevel, bounds) {\r\n\t\tthis._recursively(bounds, this._group._map.getMinZoom() - 1, zoomLevel,\r\n\t\t\tfunction (c) {\r\n\t\t\t\tif (zoomLevel === c._zoom) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t//Add our child markers at startPos (so they can be animated out)\r\n\t\t\t\tfor (var i = c._markers.length - 1; i >= 0; i--) {\r\n\t\t\t\t\tvar nm = c._markers[i];\r\n\r\n\t\t\t\t\tif (!bounds.contains(nm._latlng)) {\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (startPos) {\r\n\t\t\t\t\t\tnm._backupLatlng = nm.getLatLng();\r\n\r\n\t\t\t\t\t\tnm.setLatLng(startPos);\r\n\t\t\t\t\t\tif (nm.clusterHide) {\r\n\t\t\t\t\t\t\tnm.clusterHide();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tc._group._featureGroup.addLayer(nm);\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tfunction (c) {\r\n\t\t\t\tc._addToMap(startPos);\r\n\t\t\t}\r\n\t\t);\r\n\t},\r\n\r\n\t_recursivelyRestoreChildPositions: function (zoomLevel) {\r\n\t\t//Fix positions of child markers\r\n\t\tfor (var i = this._markers.length - 1; i >= 0; i--) {\r\n\t\t\tvar nm = this._markers[i];\r\n\t\t\tif (nm._backupLatlng) {\r\n\t\t\t\tnm.setLatLng(nm._backupLatlng);\r\n\t\t\t\tdelete nm._backupLatlng;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (zoomLevel - 1 === this._zoom) {\r\n\t\t\t//Reposition child clusters\r\n\t\t\tfor (var j = this._childClusters.length - 1; j >= 0; j--) {\r\n\t\t\t\tthis._childClusters[j]._restorePosition();\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tfor (var k = this._childClusters.length - 1; k >= 0; k--) {\r\n\t\t\t\tthis._childClusters[k]._recursivelyRestoreChildPositions(zoomLevel);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_restorePosition: function () {\r\n\t\tif (this._backupLatlng) {\r\n\t\t\tthis.setLatLng(this._backupLatlng);\r\n\t\t\tdelete this._backupLatlng;\r\n\t\t}\r\n\t},\r\n\r\n\t//exceptBounds: If set, don't remove any markers/clusters in it\r\n\t_recursivelyRemoveChildrenFromMap: function (previousBounds, mapMinZoom, zoomLevel, exceptBounds) {\r\n\t\tvar m, i;\r\n\t\tthis._recursively(previousBounds, mapMinZoom - 1, zoomLevel - 1,\r\n\t\t\tfunction (c) {\r\n\t\t\t\t//Remove markers at every level\r\n\t\t\t\tfor (i = c._markers.length - 1; i >= 0; i--) {\r\n\t\t\t\t\tm = c._markers[i];\r\n\t\t\t\t\tif (!exceptBounds || !exceptBounds.contains(m._latlng)) {\r\n\t\t\t\t\t\tc._group._featureGroup.removeLayer(m);\r\n\t\t\t\t\t\tif (m.clusterShow) {\r\n\t\t\t\t\t\t\tm.clusterShow();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tfunction (c) {\r\n\t\t\t\t//Remove child clusters at just the bottom level\r\n\t\t\t\tfor (i = c._childClusters.length - 1; i >= 0; i--) {\r\n\t\t\t\t\tm = c._childClusters[i];\r\n\t\t\t\t\tif (!exceptBounds || !exceptBounds.contains(m._latlng)) {\r\n\t\t\t\t\t\tc._group._featureGroup.removeLayer(m);\r\n\t\t\t\t\t\tif (m.clusterShow) {\r\n\t\t\t\t\t\t\tm.clusterShow();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\t},\r\n\r\n\t//Run the given functions recursively to this and child clusters\r\n\t// boundsToApplyTo: a L.LatLngBounds representing the bounds of what clusters to recurse in to\r\n\t// zoomLevelToStart: zoom level to start running functions (inclusive)\r\n\t// zoomLevelToStop: zoom level to stop running functions (inclusive)\r\n\t// runAtEveryLevel: function that takes an L.MarkerCluster as an argument that should be applied on every level\r\n\t// runAtBottomLevel: function that takes an L.MarkerCluster as an argument that should be applied at only the bottom level\r\n\t_recursively: function (boundsToApplyTo, zoomLevelToStart, zoomLevelToStop, runAtEveryLevel, runAtBottomLevel) {\r\n\t\tvar childClusters = this._childClusters,\r\n\t\t    zoom = this._zoom,\r\n\t\t    i, c;\r\n\r\n\t\tif (zoomLevelToStart <= zoom) {\r\n\t\t\tif (runAtEveryLevel) {\r\n\t\t\t\trunAtEveryLevel(this);\r\n\t\t\t}\r\n\t\t\tif (runAtBottomLevel && zoom === zoomLevelToStop) {\r\n\t\t\t\trunAtBottomLevel(this);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (zoom < zoomLevelToStart || zoom < zoomLevelToStop) {\r\n\t\t\tfor (i = childClusters.length - 1; i >= 0; i--) {\r\n\t\t\t\tc = childClusters[i];\r\n\t\t\t\tif (c._boundsNeedUpdate) {\r\n\t\t\t\t\tc._recalculateBounds();\r\n\t\t\t\t}\r\n\t\t\t\tif (boundsToApplyTo.intersects(c._bounds)) {\r\n\t\t\t\t\tc._recursively(boundsToApplyTo, zoomLevelToStart, zoomLevelToStop, runAtEveryLevel, runAtBottomLevel);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t//Returns true if we are the parent of only one cluster and that cluster is the same as us\r\n\t_isSingleParent: function () {\r\n\t\t//Don't need to check this._markers as the rest won't work if there are any\r\n\t\treturn this._childClusters.length > 0 && this._childClusters[0]._childCount === this._childCount;\r\n\t}\r\n});\n\n/*\r\n* Extends L.Marker to include two extra methods: clusterHide and clusterShow.\r\n* \r\n* They work as setOpacity(0) and setOpacity(1) respectively, but\r\n* don't overwrite the options.opacity\r\n* \r\n*/\r\n\r\nL.Marker.include({\r\n\tclusterHide: function () {\r\n\t\tvar backup = this.options.opacity;\r\n\t\tthis.setOpacity(0);\r\n\t\tthis.options.opacity = backup;\r\n\t\treturn this;\r\n\t},\r\n\t\r\n\tclusterShow: function () {\r\n\t\treturn this.setOpacity(this.options.opacity);\r\n\t}\r\n});\n\nL.DistanceGrid = function (cellSize) {\r\n\tthis._cellSize = cellSize;\r\n\tthis._sqCellSize = cellSize * cellSize;\r\n\tthis._grid = {};\r\n\tthis._objectPoint = { };\r\n};\r\n\r\nL.DistanceGrid.prototype = {\r\n\r\n\taddObject: function (obj, point) {\r\n\t\tvar x = this._getCoord(point.x),\r\n\t\t    y = this._getCoord(point.y),\r\n\t\t    grid = this._grid,\r\n\t\t    row = grid[y] = grid[y] || {},\r\n\t\t    cell = row[x] = row[x] || [],\r\n\t\t    stamp = L.Util.stamp(obj);\r\n\r\n\t\tthis._objectPoint[stamp] = point;\r\n\r\n\t\tcell.push(obj);\r\n\t},\r\n\r\n\tupdateObject: function (obj, point) {\r\n\t\tthis.removeObject(obj);\r\n\t\tthis.addObject(obj, point);\r\n\t},\r\n\r\n\t//Returns true if the object was found\r\n\tremoveObject: function (obj, point) {\r\n\t\tvar x = this._getCoord(point.x),\r\n\t\t    y = this._getCoord(point.y),\r\n\t\t    grid = this._grid,\r\n\t\t    row = grid[y] = grid[y] || {},\r\n\t\t    cell = row[x] = row[x] || [],\r\n\t\t    i, len;\r\n\r\n\t\tdelete this._objectPoint[L.Util.stamp(obj)];\r\n\r\n\t\tfor (i = 0, len = cell.length; i < len; i++) {\r\n\t\t\tif (cell[i] === obj) {\r\n\r\n\t\t\t\tcell.splice(i, 1);\r\n\r\n\t\t\t\tif (len === 1) {\r\n\t\t\t\t\tdelete row[x];\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t},\r\n\r\n\teachObject: function (fn, context) {\r\n\t\tvar i, j, k, len, row, cell, removed,\r\n\t\t    grid = this._grid;\r\n\r\n\t\tfor (i in grid) {\r\n\t\t\trow = grid[i];\r\n\r\n\t\t\tfor (j in row) {\r\n\t\t\t\tcell = row[j];\r\n\r\n\t\t\t\tfor (k = 0, len = cell.length; k < len; k++) {\r\n\t\t\t\t\tremoved = fn.call(context, cell[k]);\r\n\t\t\t\t\tif (removed) {\r\n\t\t\t\t\t\tk--;\r\n\t\t\t\t\t\tlen--;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\tgetNearObject: function (point) {\r\n\t\tvar x = this._getCoord(point.x),\r\n\t\t    y = this._getCoord(point.y),\r\n\t\t    i, j, k, row, cell, len, obj, dist,\r\n\t\t    objectPoint = this._objectPoint,\r\n\t\t    closestDistSq = this._sqCellSize,\r\n\t\t    closest = null;\r\n\r\n\t\tfor (i = y - 1; i <= y + 1; i++) {\r\n\t\t\trow = this._grid[i];\r\n\t\t\tif (row) {\r\n\r\n\t\t\t\tfor (j = x - 1; j <= x + 1; j++) {\r\n\t\t\t\t\tcell = row[j];\r\n\t\t\t\t\tif (cell) {\r\n\r\n\t\t\t\t\t\tfor (k = 0, len = cell.length; k < len; k++) {\r\n\t\t\t\t\t\t\tobj = cell[k];\r\n\t\t\t\t\t\t\tdist = this._sqDist(objectPoint[L.Util.stamp(obj)], point);\r\n\t\t\t\t\t\t\tif (dist < closestDistSq ||\r\n\t\t\t\t\t\t\t\tdist <= closestDistSq && closest === null) {\r\n\t\t\t\t\t\t\t\tclosestDistSq = dist;\r\n\t\t\t\t\t\t\t\tclosest = obj;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn closest;\r\n\t},\r\n\r\n\t_getCoord: function (x) {\r\n\t\tvar coord = Math.floor(x / this._cellSize);\r\n\t\treturn isFinite(coord) ? coord : x;\r\n\t},\r\n\r\n\t_sqDist: function (p, p2) {\r\n\t\tvar dx = p2.x - p.x,\r\n\t\t    dy = p2.y - p.y;\r\n\t\treturn dx * dx + dy * dy;\r\n\t}\r\n};\n\n/* Copyright (c) 2012 the authors listed at the following URL, and/or\r\nthe authors of referenced articles or incorporated external code:\r\nhttp://en.literateprograms.org/Quickhull_(Javascript)?action=history&offset=20120410175256\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining\r\na copy of this software and associated documentation files (the\r\n\"Software\"), to deal in the Software without restriction, including\r\nwithout limitation the rights to use, copy, modify, merge, publish,\r\ndistribute, sublicense, and/or sell copies of the Software, and to\r\npermit persons to whom the Software is furnished to do so, subject to\r\nthe following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be\r\nincluded in all copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\r\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\r\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\r\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\r\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\nRetrieved from: http://en.literateprograms.org/Quickhull_(Javascript)?oldid=18434\r\n*/\r\n\r\n(function () {\r\n\tL.QuickHull = {\r\n\r\n\t\t/*\r\n\t\t * @param {Object} cpt a point to be measured from the baseline\r\n\t\t * @param {Array} bl the baseline, as represented by a two-element\r\n\t\t *   array of latlng objects.\r\n\t\t * @returns {Number} an approximate distance measure\r\n\t\t */\r\n\t\tgetDistant: function (cpt, bl) {\r\n\t\t\tvar vY = bl[1].lat - bl[0].lat,\r\n\t\t\t\tvX = bl[0].lng - bl[1].lng;\r\n\t\t\treturn (vX * (cpt.lat - bl[0].lat) + vY * (cpt.lng - bl[0].lng));\r\n\t\t},\r\n\r\n\t\t/*\r\n\t\t * @param {Array} baseLine a two-element array of latlng objects\r\n\t\t *   representing the baseline to project from\r\n\t\t * @param {Array} latLngs an array of latlng objects\r\n\t\t * @returns {Object} the maximum point and all new points to stay\r\n\t\t *   in consideration for the hull.\r\n\t\t */\r\n\t\tfindMostDistantPointFromBaseLine: function (baseLine, latLngs) {\r\n\t\t\tvar maxD = 0,\r\n\t\t\t\tmaxPt = null,\r\n\t\t\t\tnewPoints = [],\r\n\t\t\t\ti, pt, d;\r\n\r\n\t\t\tfor (i = latLngs.length - 1; i >= 0; i--) {\r\n\t\t\t\tpt = latLngs[i];\r\n\t\t\t\td = this.getDistant(pt, baseLine);\r\n\r\n\t\t\t\tif (d > 0) {\r\n\t\t\t\t\tnewPoints.push(pt);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (d > maxD) {\r\n\t\t\t\t\tmaxD = d;\r\n\t\t\t\t\tmaxPt = pt;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn { maxPoint: maxPt, newPoints: newPoints };\r\n\t\t},\r\n\r\n\r\n\t\t/*\r\n\t\t * Given a baseline, compute the convex hull of latLngs as an array\r\n\t\t * of latLngs.\r\n\t\t *\r\n\t\t * @param {Array} latLngs\r\n\t\t * @returns {Array}\r\n\t\t */\r\n\t\tbuildConvexHull: function (baseLine, latLngs) {\r\n\t\t\tvar convexHullBaseLines = [],\r\n\t\t\t\tt = this.findMostDistantPointFromBaseLine(baseLine, latLngs);\r\n\r\n\t\t\tif (t.maxPoint) { // if there is still a point \"outside\" the base line\r\n\t\t\t\tconvexHullBaseLines =\r\n\t\t\t\t\tconvexHullBaseLines.concat(\r\n\t\t\t\t\t\tthis.buildConvexHull([baseLine[0], t.maxPoint], t.newPoints)\r\n\t\t\t\t\t);\r\n\t\t\t\tconvexHullBaseLines =\r\n\t\t\t\t\tconvexHullBaseLines.concat(\r\n\t\t\t\t\t\tthis.buildConvexHull([t.maxPoint, baseLine[1]], t.newPoints)\r\n\t\t\t\t\t);\r\n\t\t\t\treturn convexHullBaseLines;\r\n\t\t\t} else {  // if there is no more point \"outside\" the base line, the current base line is part of the convex hull\r\n\t\t\t\treturn [baseLine[0]];\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/*\r\n\t\t * Given an array of latlngs, compute a convex hull as an array\r\n\t\t * of latlngs\r\n\t\t *\r\n\t\t * @param {Array} latLngs\r\n\t\t * @returns {Array}\r\n\t\t */\r\n\t\tgetConvexHull: function (latLngs) {\r\n\t\t\t// find first baseline\r\n\t\t\tvar maxLat = false, minLat = false,\r\n\t\t\t\tmaxLng = false, minLng = false,\r\n\t\t\t\tmaxLatPt = null, minLatPt = null,\r\n\t\t\t\tmaxLngPt = null, minLngPt = null,\r\n\t\t\t\tmaxPt = null, minPt = null,\r\n\t\t\t\ti;\r\n\r\n\t\t\tfor (i = latLngs.length - 1; i >= 0; i--) {\r\n\t\t\t\tvar pt = latLngs[i];\r\n\t\t\t\tif (maxLat === false || pt.lat > maxLat) {\r\n\t\t\t\t\tmaxLatPt = pt;\r\n\t\t\t\t\tmaxLat = pt.lat;\r\n\t\t\t\t}\r\n\t\t\t\tif (minLat === false || pt.lat < minLat) {\r\n\t\t\t\t\tminLatPt = pt;\r\n\t\t\t\t\tminLat = pt.lat;\r\n\t\t\t\t}\r\n\t\t\t\tif (maxLng === false || pt.lng > maxLng) {\r\n\t\t\t\t\tmaxLngPt = pt;\r\n\t\t\t\t\tmaxLng = pt.lng;\r\n\t\t\t\t}\r\n\t\t\t\tif (minLng === false || pt.lng < minLng) {\r\n\t\t\t\t\tminLngPt = pt;\r\n\t\t\t\t\tminLng = pt.lng;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (minLat !== maxLat) {\r\n\t\t\t\tminPt = minLatPt;\r\n\t\t\t\tmaxPt = maxLatPt;\r\n\t\t\t} else {\r\n\t\t\t\tminPt = minLngPt;\r\n\t\t\t\tmaxPt = maxLngPt;\r\n\t\t\t}\r\n\r\n\t\t\tvar ch = [].concat(this.buildConvexHull([minPt, maxPt], latLngs),\r\n\t\t\t\t\t\t\t\tthis.buildConvexHull([maxPt, minPt], latLngs));\r\n\t\t\treturn ch;\r\n\t\t}\r\n\t};\r\n}());\r\n\r\nL.MarkerCluster.include({\r\n\tgetConvexHull: function () {\r\n\t\tvar childMarkers = this.getAllChildMarkers(),\r\n\t\t\tpoints = [],\r\n\t\t\tp, i;\r\n\r\n\t\tfor (i = childMarkers.length - 1; i >= 0; i--) {\r\n\t\t\tp = childMarkers[i].getLatLng();\r\n\t\t\tpoints.push(p);\r\n\t\t}\r\n\r\n\t\treturn L.QuickHull.getConvexHull(points);\r\n\t}\r\n});\n\n//This code is 100% based on https://github.com/jawj/OverlappingMarkerSpiderfier-Leaflet\r\n//Huge thanks to jawj for implementing it first to make my job easy :-)\r\n\r\nL.MarkerCluster.include({\r\n\r\n\t_2PI: Math.PI * 2,\r\n\t_circleFootSeparation: 25, //related to circumference of circle\r\n\t_circleStartAngle: 0,\r\n\r\n\t_spiralFootSeparation:  28, //related to size of spiral (experiment!)\r\n\t_spiralLengthStart: 11,\r\n\t_spiralLengthFactor: 5,\r\n\r\n\t_circleSpiralSwitchover: 9, //show spiral instead of circle from this marker count upwards.\r\n\t\t\t\t\t\t\t\t// 0 -> always spiral; Infinity -> always circle\r\n\r\n\tspiderfy: function () {\r\n\t\tif (this._group._spiderfied === this || this._group._inZoomAnimation) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar childMarkers = this.getAllChildMarkers(null, true),\r\n\t\t\tgroup = this._group,\r\n\t\t\tmap = group._map,\r\n\t\t\tcenter = map.latLngToLayerPoint(this._latlng),\r\n\t\t\tpositions;\r\n\r\n\t\tthis._group._unspiderfy();\r\n\t\tthis._group._spiderfied = this;\r\n\r\n\t\t//TODO Maybe: childMarkers order by distance to center\r\n\r\n\t\tif (childMarkers.length >= this._circleSpiralSwitchover) {\r\n\t\t\tpositions = this._generatePointsSpiral(childMarkers.length, center);\r\n\t\t} else {\r\n\t\t\tcenter.y += 10; // Otherwise circles look wrong => hack for standard blue icon, renders differently for other icons.\r\n\t\t\tpositions = this._generatePointsCircle(childMarkers.length, center);\r\n\t\t}\r\n\r\n\t\tthis._animationSpiderfy(childMarkers, positions);\r\n\t},\r\n\r\n\tunspiderfy: function (zoomDetails) {\r\n\t\t/// <param Name=\"zoomDetails\">Argument from zoomanim if being called in a zoom animation or null otherwise</param>\r\n\t\tif (this._group._inZoomAnimation) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tthis._animationUnspiderfy(zoomDetails);\r\n\r\n\t\tthis._group._spiderfied = null;\r\n\t},\r\n\r\n\t_generatePointsCircle: function (count, centerPt) {\r\n\t\tvar circumference = this._group.options.spiderfyDistanceMultiplier * this._circleFootSeparation * (2 + count),\r\n\t\t\tlegLength = circumference / this._2PI,  //radius from circumference\r\n\t\t\tangleStep = this._2PI / count,\r\n\t\t\tres = [],\r\n\t\t\ti, angle;\r\n\r\n\t\tlegLength = Math.max(legLength, 35); // Minimum distance to get outside the cluster icon.\r\n\r\n\t\tres.length = count;\r\n\r\n\t\tfor (i = 0; i < count; i++) { // Clockwise, like spiral.\r\n\t\t\tangle = this._circleStartAngle + i * angleStep;\r\n\t\t\tres[i] = new L.Point(centerPt.x + legLength * Math.cos(angle), centerPt.y + legLength * Math.sin(angle))._round();\r\n\t\t}\r\n\r\n\t\treturn res;\r\n\t},\r\n\r\n\t_generatePointsSpiral: function (count, centerPt) {\r\n\t\tvar spiderfyDistanceMultiplier = this._group.options.spiderfyDistanceMultiplier,\r\n\t\t\tlegLength = spiderfyDistanceMultiplier * this._spiralLengthStart,\r\n\t\t\tseparation = spiderfyDistanceMultiplier * this._spiralFootSeparation,\r\n\t\t\tlengthFactor = spiderfyDistanceMultiplier * this._spiralLengthFactor * this._2PI,\r\n\t\t\tangle = 0,\r\n\t\t\tres = [],\r\n\t\t\ti;\r\n\r\n\t\tres.length = count;\r\n\r\n\t\t// Higher index, closer position to cluster center.\r\n\t\tfor (i = count; i >= 0; i--) {\r\n\t\t\t// Skip the first position, so that we are already farther from center and we avoid\r\n\t\t\t// being under the default cluster icon (especially important for Circle Markers).\r\n\t\t\tif (i < count) {\r\n\t\t\t\tres[i] = new L.Point(centerPt.x + legLength * Math.cos(angle), centerPt.y + legLength * Math.sin(angle))._round();\r\n\t\t\t}\r\n\t\t\tangle += separation / legLength + i * 0.0005;\r\n\t\t\tlegLength += lengthFactor / angle;\r\n\t\t}\r\n\t\treturn res;\r\n\t},\r\n\r\n\t_noanimationUnspiderfy: function () {\r\n\t\tvar group = this._group,\r\n\t\t\tmap = group._map,\r\n\t\t\tfg = group._featureGroup,\r\n\t\t\tchildMarkers = this.getAllChildMarkers(null, true),\r\n\t\t\tm, i;\r\n\r\n\t\tgroup._ignoreMove = true;\r\n\r\n\t\tthis.setOpacity(1);\r\n\t\tfor (i = childMarkers.length - 1; i >= 0; i--) {\r\n\t\t\tm = childMarkers[i];\r\n\r\n\t\t\tfg.removeLayer(m);\r\n\r\n\t\t\tif (m._preSpiderfyLatlng) {\r\n\t\t\t\tm.setLatLng(m._preSpiderfyLatlng);\r\n\t\t\t\tdelete m._preSpiderfyLatlng;\r\n\t\t\t}\r\n\t\t\tif (m.setZIndexOffset) {\r\n\t\t\t\tm.setZIndexOffset(0);\r\n\t\t\t}\r\n\r\n\t\t\tif (m._spiderLeg) {\r\n\t\t\t\tmap.removeLayer(m._spiderLeg);\r\n\t\t\t\tdelete m._spiderLeg;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tgroup.fire('unspiderfied', {\r\n\t\t\tcluster: this,\r\n\t\t\tmarkers: childMarkers\r\n\t\t});\r\n\t\tgroup._ignoreMove = false;\r\n\t\tgroup._spiderfied = null;\r\n\t}\r\n});\r\n\r\n//Non Animated versions of everything\r\nL.MarkerClusterNonAnimated = L.MarkerCluster.extend({\r\n\t_animationSpiderfy: function (childMarkers, positions) {\r\n\t\tvar group = this._group,\r\n\t\t\tmap = group._map,\r\n\t\t\tfg = group._featureGroup,\r\n\t\t\tlegOptions = this._group.options.spiderLegPolylineOptions,\r\n\t\t\ti, m, leg, newPos;\r\n\r\n\t\tgroup._ignoreMove = true;\r\n\r\n\t\t// Traverse in ascending order to make sure that inner circleMarkers are on top of further legs. Normal markers are re-ordered by newPosition.\r\n\t\t// The reverse order trick no longer improves performance on modern browsers.\r\n\t\tfor (i = 0; i < childMarkers.length; i++) {\r\n\t\t\tnewPos = map.layerPointToLatLng(positions[i]);\r\n\t\t\tm = childMarkers[i];\r\n\r\n\t\t\t// Add the leg before the marker, so that in case the latter is a circleMarker, the leg is behind it.\r\n\t\t\tleg = new L.Polyline([this._latlng, newPos], legOptions);\r\n\t\t\tmap.addLayer(leg);\r\n\t\t\tm._spiderLeg = leg;\r\n\r\n\t\t\t// Now add the marker.\r\n\t\t\tm._preSpiderfyLatlng = m._latlng;\r\n\t\t\tm.setLatLng(newPos);\r\n\t\t\tif (m.setZIndexOffset) {\r\n\t\t\t\tm.setZIndexOffset(1000000); //Make these appear on top of EVERYTHING\r\n\t\t\t}\r\n\r\n\t\t\tfg.addLayer(m);\r\n\t\t}\r\n\t\tthis.setOpacity(0.3);\r\n\r\n\t\tgroup._ignoreMove = false;\r\n\t\tgroup.fire('spiderfied', {\r\n\t\t\tcluster: this,\r\n\t\t\tmarkers: childMarkers\r\n\t\t});\r\n\t},\r\n\r\n\t_animationUnspiderfy: function () {\r\n\t\tthis._noanimationUnspiderfy();\r\n\t}\r\n});\r\n\r\n//Animated versions here\r\nL.MarkerCluster.include({\r\n\r\n\t_animationSpiderfy: function (childMarkers, positions) {\r\n\t\tvar me = this,\r\n\t\t\tgroup = this._group,\r\n\t\t\tmap = group._map,\r\n\t\t\tfg = group._featureGroup,\r\n\t\t\tthisLayerLatLng = this._latlng,\r\n\t\t\tthisLayerPos = map.latLngToLayerPoint(thisLayerLatLng),\r\n\t\t\tsvg = L.Path.SVG,\r\n\t\t\tlegOptions = L.extend({}, this._group.options.spiderLegPolylineOptions), // Copy the options so that we can modify them for animation.\r\n\t\t\tfinalLegOpacity = legOptions.opacity,\r\n\t\t\ti, m, leg, legPath, legLength, newPos;\r\n\r\n\t\tif (finalLegOpacity === undefined) {\r\n\t\t\tfinalLegOpacity = L.MarkerClusterGroup.prototype.options.spiderLegPolylineOptions.opacity;\r\n\t\t}\r\n\r\n\t\tif (svg) {\r\n\t\t\t// If the initial opacity of the spider leg is not 0 then it appears before the animation starts.\r\n\t\t\tlegOptions.opacity = 0;\r\n\r\n\t\t\t// Add the class for CSS transitions.\r\n\t\t\tlegOptions.className = (legOptions.className || '') + ' leaflet-cluster-spider-leg';\r\n\t\t} else {\r\n\t\t\t// Make sure we have a defined opacity.\r\n\t\t\tlegOptions.opacity = finalLegOpacity;\r\n\t\t}\r\n\r\n\t\tgroup._ignoreMove = true;\r\n\r\n\t\t// Add markers and spider legs to map, hidden at our center point.\r\n\t\t// Traverse in ascending order to make sure that inner circleMarkers are on top of further legs. Normal markers are re-ordered by newPosition.\r\n\t\t// The reverse order trick no longer improves performance on modern browsers.\r\n\t\tfor (i = 0; i < childMarkers.length; i++) {\r\n\t\t\tm = childMarkers[i];\r\n\r\n\t\t\tnewPos = map.layerPointToLatLng(positions[i]);\r\n\r\n\t\t\t// Add the leg before the marker, so that in case the latter is a circleMarker, the leg is behind it.\r\n\t\t\tleg = new L.Polyline([thisLayerLatLng, newPos], legOptions);\r\n\t\t\tmap.addLayer(leg);\r\n\t\t\tm._spiderLeg = leg;\r\n\r\n\t\t\t// Explanations: https://jakearchibald.com/2013/animated-line-drawing-svg/\r\n\t\t\t// In our case the transition property is declared in the CSS file.\r\n\t\t\tif (svg) {\r\n\t\t\t\tlegPath = leg._path;\r\n\t\t\t\tlegLength = legPath.getTotalLength() + 0.1; // Need a small extra length to avoid remaining dot in Firefox.\r\n\t\t\t\tlegPath.style.strokeDasharray = legLength; // Just 1 length is enough, it will be duplicated.\r\n\t\t\t\tlegPath.style.strokeDashoffset = legLength;\r\n\t\t\t}\r\n\r\n\t\t\t// If it is a marker, add it now and we'll animate it out\r\n\t\t\tif (m.setZIndexOffset) {\r\n\t\t\t\tm.setZIndexOffset(1000000); // Make normal markers appear on top of EVERYTHING\r\n\t\t\t}\r\n\t\t\tif (m.clusterHide) {\r\n\t\t\t\tm.clusterHide();\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// Vectors just get immediately added\r\n\t\t\tfg.addLayer(m);\r\n\r\n\t\t\tif (m._setPos) {\r\n\t\t\t\tm._setPos(thisLayerPos);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tgroup._forceLayout();\r\n\t\tgroup._animationStart();\r\n\r\n\t\t// Reveal markers and spider legs.\r\n\t\tfor (i = childMarkers.length - 1; i >= 0; i--) {\r\n\t\t\tnewPos = map.layerPointToLatLng(positions[i]);\r\n\t\t\tm = childMarkers[i];\r\n\r\n\t\t\t//Move marker to new position\r\n\t\t\tm._preSpiderfyLatlng = m._latlng;\r\n\t\t\tm.setLatLng(newPos);\r\n\t\t\t\r\n\t\t\tif (m.clusterShow) {\r\n\t\t\t\tm.clusterShow();\r\n\t\t\t}\r\n\r\n\t\t\t// Animate leg (animation is actually delegated to CSS transition).\r\n\t\t\tif (svg) {\r\n\t\t\t\tleg = m._spiderLeg;\r\n\t\t\t\tlegPath = leg._path;\r\n\t\t\t\tlegPath.style.strokeDashoffset = 0;\r\n\t\t\t\t//legPath.style.strokeOpacity = finalLegOpacity;\r\n\t\t\t\tleg.setStyle({opacity: finalLegOpacity});\r\n\t\t\t}\r\n\t\t}\r\n\t\tthis.setOpacity(0.3);\r\n\r\n\t\tgroup._ignoreMove = false;\r\n\r\n\t\tsetTimeout(function () {\r\n\t\t\tgroup._animationEnd();\r\n\t\t\tgroup.fire('spiderfied', {\r\n\t\t\t\tcluster: me,\r\n\t\t\t\tmarkers: childMarkers\r\n\t\t\t});\r\n\t\t}, 200);\r\n\t},\r\n\r\n\t_animationUnspiderfy: function (zoomDetails) {\r\n\t\tvar me = this,\r\n\t\t\tgroup = this._group,\r\n\t\t\tmap = group._map,\r\n\t\t\tfg = group._featureGroup,\r\n\t\t\tthisLayerPos = zoomDetails ? map._latLngToNewLayerPoint(this._latlng, zoomDetails.zoom, zoomDetails.center) : map.latLngToLayerPoint(this._latlng),\r\n\t\t\tchildMarkers = this.getAllChildMarkers(null, true),\r\n\t\t\tsvg = L.Path.SVG,\r\n\t\t\tm, i, leg, legPath, legLength, nonAnimatable;\r\n\r\n\t\tgroup._ignoreMove = true;\r\n\t\tgroup._animationStart();\r\n\r\n\t\t//Make us visible and bring the child markers back in\r\n\t\tthis.setOpacity(1);\r\n\t\tfor (i = childMarkers.length - 1; i >= 0; i--) {\r\n\t\t\tm = childMarkers[i];\r\n\r\n\t\t\t//Marker was added to us after we were spiderfied\r\n\t\t\tif (!m._preSpiderfyLatlng) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\t//Close any popup on the marker first, otherwise setting the location of the marker will make the map scroll\r\n\t\t\tm.closePopup();\r\n\r\n\t\t\t//Fix up the location to the real one\r\n\t\t\tm.setLatLng(m._preSpiderfyLatlng);\r\n\t\t\tdelete m._preSpiderfyLatlng;\r\n\r\n\t\t\t//Hack override the location to be our center\r\n\t\t\tnonAnimatable = true;\r\n\t\t\tif (m._setPos) {\r\n\t\t\t\tm._setPos(thisLayerPos);\r\n\t\t\t\tnonAnimatable = false;\r\n\t\t\t}\r\n\t\t\tif (m.clusterHide) {\r\n\t\t\t\tm.clusterHide();\r\n\t\t\t\tnonAnimatable = false;\r\n\t\t\t}\r\n\t\t\tif (nonAnimatable) {\r\n\t\t\t\tfg.removeLayer(m);\r\n\t\t\t}\r\n\r\n\t\t\t// Animate the spider leg back in (animation is actually delegated to CSS transition).\r\n\t\t\tif (svg) {\r\n\t\t\t\tleg = m._spiderLeg;\r\n\t\t\t\tlegPath = leg._path;\r\n\t\t\t\tlegLength = legPath.getTotalLength() + 0.1;\r\n\t\t\t\tlegPath.style.strokeDashoffset = legLength;\r\n\t\t\t\tleg.setStyle({opacity: 0});\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tgroup._ignoreMove = false;\r\n\r\n\t\tsetTimeout(function () {\r\n\t\t\t//If we have only <= one child left then that marker will be shown on the map so don't remove it!\r\n\t\t\tvar stillThereChildCount = 0;\r\n\t\t\tfor (i = childMarkers.length - 1; i >= 0; i--) {\r\n\t\t\t\tm = childMarkers[i];\r\n\t\t\t\tif (m._spiderLeg) {\r\n\t\t\t\t\tstillThereChildCount++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\r\n\t\t\tfor (i = childMarkers.length - 1; i >= 0; i--) {\r\n\t\t\t\tm = childMarkers[i];\r\n\r\n\t\t\t\tif (!m._spiderLeg) { //Has already been unspiderfied\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (m.clusterShow) {\r\n\t\t\t\t\tm.clusterShow();\r\n\t\t\t\t}\r\n\t\t\t\tif (m.setZIndexOffset) {\r\n\t\t\t\t\tm.setZIndexOffset(0);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (stillThereChildCount > 1) {\r\n\t\t\t\t\tfg.removeLayer(m);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tmap.removeLayer(m._spiderLeg);\r\n\t\t\t\tdelete m._spiderLeg;\r\n\t\t\t}\r\n\t\t\tgroup._animationEnd();\r\n\t\t\tgroup.fire('unspiderfied', {\r\n\t\t\t\tcluster: me,\r\n\t\t\t\tmarkers: childMarkers\r\n\t\t\t});\r\n\t\t}, 200);\r\n\t}\r\n});\r\n\r\n\r\nL.MarkerClusterGroup.include({\r\n\t//The MarkerCluster currently spiderfied (if any)\r\n\t_spiderfied: null,\r\n\r\n\tunspiderfy: function () {\r\n\t\tthis._unspiderfy.apply(this, arguments);\r\n\t},\r\n\r\n\t_spiderfierOnAdd: function () {\r\n\t\tthis._map.on('click', this._unspiderfyWrapper, this);\r\n\r\n\t\tif (this._map.options.zoomAnimation) {\r\n\t\t\tthis._map.on('zoomstart', this._unspiderfyZoomStart, this);\r\n\t\t}\r\n\t\t//Browsers without zoomAnimation or a big zoom don't fire zoomstart\r\n\t\tthis._map.on('zoomend', this._noanimationUnspiderfy, this);\r\n\r\n\t\tif (!L.Browser.touch) {\r\n\t\t\tthis._map.getRenderer(this);\r\n\t\t\t//Needs to happen in the pageload, not after, or animations don't work in webkit\r\n\t\t\t//  http://stackoverflow.com/questions/8455200/svg-animate-with-dynamically-added-elements\r\n\t\t\t//Disable on touch browsers as the animation messes up on a touch zoom and isn't very noticable\r\n\t\t}\r\n\t},\r\n\r\n\t_spiderfierOnRemove: function () {\r\n\t\tthis._map.off('click', this._unspiderfyWrapper, this);\r\n\t\tthis._map.off('zoomstart', this._unspiderfyZoomStart, this);\r\n\t\tthis._map.off('zoomanim', this._unspiderfyZoomAnim, this);\r\n\t\tthis._map.off('zoomend', this._noanimationUnspiderfy, this);\r\n\r\n\t\t//Ensure that markers are back where they should be\r\n\t\t// Use no animation to avoid a sticky leaflet-cluster-anim class on mapPane\r\n\t\tthis._noanimationUnspiderfy();\r\n\t},\r\n\r\n\t//On zoom start we add a zoomanim handler so that we are guaranteed to be last (after markers are animated)\r\n\t//This means we can define the animation they do rather than Markers doing an animation to their actual location\r\n\t_unspiderfyZoomStart: function () {\r\n\t\tif (!this._map) { //May have been removed from the map by a zoomEnd handler\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis._map.on('zoomanim', this._unspiderfyZoomAnim, this);\r\n\t},\r\n\r\n\t_unspiderfyZoomAnim: function (zoomDetails) {\r\n\t\t//Wait until the first zoomanim after the user has finished touch-zooming before running the animation\r\n\t\tif (L.DomUtil.hasClass(this._map._mapPane, 'leaflet-touching')) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis._map.off('zoomanim', this._unspiderfyZoomAnim, this);\r\n\t\tthis._unspiderfy(zoomDetails);\r\n\t},\r\n\r\n\t_unspiderfyWrapper: function () {\r\n\t\t/// <summary>_unspiderfy but passes no arguments</summary>\r\n\t\tthis._unspiderfy();\r\n\t},\r\n\r\n\t_unspiderfy: function (zoomDetails) {\r\n\t\tif (this._spiderfied) {\r\n\t\t\tthis._spiderfied.unspiderfy(zoomDetails);\r\n\t\t}\r\n\t},\r\n\r\n\t_noanimationUnspiderfy: function () {\r\n\t\tif (this._spiderfied) {\r\n\t\t\tthis._spiderfied._noanimationUnspiderfy();\r\n\t\t}\r\n\t},\r\n\r\n\t//If the given layer is currently being spiderfied then we unspiderfy it so it isn't on the map anymore etc\r\n\t_unspiderfyLayer: function (layer) {\r\n\t\tif (layer._spiderLeg) {\r\n\t\t\tthis._featureGroup.removeLayer(layer);\r\n\r\n\t\t\tif (layer.clusterShow) {\r\n\t\t\t\tlayer.clusterShow();\r\n\t\t\t}\r\n\t\t\t\t//Position will be fixed up immediately in _animationUnspiderfy\r\n\t\t\tif (layer.setZIndexOffset) {\r\n\t\t\t\tlayer.setZIndexOffset(0);\r\n\t\t\t}\r\n\r\n\t\t\tthis._map.removeLayer(layer._spiderLeg);\r\n\t\t\tdelete layer._spiderLeg;\r\n\t\t}\r\n\t}\r\n});\n\n/**\r\n * Adds 1 public method to MCG and 1 to L.Marker to facilitate changing\r\n * markers' icon options and refreshing their icon and their parent clusters\r\n * accordingly (case where their iconCreateFunction uses data of childMarkers\r\n * to make up the cluster icon).\r\n */\r\n\r\n\r\nL.MarkerClusterGroup.include({\r\n\t/**\r\n\t * Updates the icon of all clusters which are parents of the given marker(s).\r\n\t * In singleMarkerMode, also updates the given marker(s) icon.\r\n\t * @param layers L.MarkerClusterGroup|L.LayerGroup|Array(L.Marker)|Map(L.Marker)|\r\n\t * L.MarkerCluster|L.Marker (optional) list of markers (or single marker) whose parent\r\n\t * clusters need to be updated. If not provided, retrieves all child markers of this.\r\n\t * @returns {L.MarkerClusterGroup}\r\n\t */\r\n\trefreshClusters: function (layers) {\r\n\t\tif (!layers) {\r\n\t\t\tlayers = this._topClusterLevel.getAllChildMarkers();\r\n\t\t} else if (layers instanceof L.MarkerClusterGroup) {\r\n\t\t\tlayers = layers._topClusterLevel.getAllChildMarkers();\r\n\t\t} else if (layers instanceof L.LayerGroup) {\r\n\t\t\tlayers = layers._layers;\r\n\t\t} else if (layers instanceof L.MarkerCluster) {\r\n\t\t\tlayers = layers.getAllChildMarkers();\r\n\t\t} else if (layers instanceof L.Marker) {\r\n\t\t\tlayers = [layers];\r\n\t\t} // else: must be an Array(L.Marker)|Map(L.Marker)\r\n\t\tthis._flagParentsIconsNeedUpdate(layers);\r\n\t\tthis._refreshClustersIcons();\r\n\r\n\t\t// In case of singleMarkerMode, also re-draw the markers.\r\n\t\tif (this.options.singleMarkerMode) {\r\n\t\t\tthis._refreshSingleMarkerModeMarkers(layers);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\t/**\r\n\t * Simply flags all parent clusters of the given markers as having a \"dirty\" icon.\r\n\t * @param layers Array(L.Marker)|Map(L.Marker) list of markers.\r\n\t * @private\r\n\t */\r\n\t_flagParentsIconsNeedUpdate: function (layers) {\r\n\t\tvar id, parent;\r\n\r\n\t\t// Assumes layers is an Array or an Object whose prototype is non-enumerable.\r\n\t\tfor (id in layers) {\r\n\t\t\t// Flag parent clusters' icon as \"dirty\", all the way up.\r\n\t\t\t// Dumb process that flags multiple times upper parents, but still\r\n\t\t\t// much more efficient than trying to be smart and make short lists,\r\n\t\t\t// at least in the case of a hierarchy following a power law:\r\n\t\t\t// http://jsperf.com/flag-nodes-in-power-hierarchy/2\r\n\t\t\tparent = layers[id].__parent;\r\n\t\t\twhile (parent) {\r\n\t\t\t\tparent._iconNeedsUpdate = true;\r\n\t\t\t\tparent = parent.__parent;\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t * Re-draws the icon of the supplied markers.\r\n\t * To be used in singleMarkerMode only.\r\n\t * @param layers Array(L.Marker)|Map(L.Marker) list of markers.\r\n\t * @private\r\n\t */\r\n\t_refreshSingleMarkerModeMarkers: function (layers) {\r\n\t\tvar id, layer;\r\n\r\n\t\tfor (id in layers) {\r\n\t\t\tlayer = layers[id];\r\n\r\n\t\t\t// Make sure we do not override markers that do not belong to THIS group.\r\n\t\t\tif (this.hasLayer(layer)) {\r\n\t\t\t\t// Need to re-create the icon first, then re-draw the marker.\r\n\t\t\t\tlayer.setIcon(this._overrideMarkerIcon(layer));\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n});\r\n\r\nL.Marker.include({\r\n\t/**\r\n\t * Updates the given options in the marker's icon and refreshes the marker.\r\n\t * @param options map object of icon options.\r\n\t * @param directlyRefreshClusters boolean (optional) true to trigger\r\n\t * MCG.refreshClustersOf() right away with this single marker.\r\n\t * @returns {L.Marker}\r\n\t */\r\n\trefreshIconOptions: function (options, directlyRefreshClusters) {\r\n\t\tvar icon = this.options.icon;\r\n\r\n\t\tL.setOptions(icon, options);\r\n\r\n\t\tthis.setIcon(icon);\r\n\r\n\t\t// Shortcut to refresh the associated MCG clusters right away.\r\n\t\t// To be used when refreshing a single marker.\r\n\t\t// Otherwise, better use MCG.refreshClusters() once at the end with\r\n\t\t// the list of modified markers.\r\n\t\tif (directlyRefreshClusters && this.__parent) {\r\n\t\t\tthis.__parent._group.refreshClusters(this);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n});\n\nexports.MarkerClusterGroup = MarkerClusterGroup;\nexports.MarkerCluster = MarkerCluster;\n\n})));\n//# sourceMappingURL=leaflet.markercluster-src.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbGVhZmxldC5tYXJrZXJjbHVzdGVyL2Rpc3QvbGVhZmxldC5tYXJrZXJjbHVzdGVyLXNyYy5qcz8yNTczIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxLQUE0RDtBQUM3RCxDQUFDLENBQ3FIO0FBQ3RILENBQUMsNEJBQTRCOztBQUU3QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLDJDQUEyQzs7QUFFeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGVBQWU7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCLGVBQWU7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QixlQUFlOztBQUV4QztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGVBQWU7QUFDNUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCLHNDQUFzQztBQUNwRTtBQUNBLDZCQUE2QixlQUFlO0FBQzVDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsZUFBZTs7QUFFM0M7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFdBQVc7QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCLFdBQVc7QUFDeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBLEdBQUc7QUFDSDs7QUFFQSxTQUFTLFlBQVk7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztB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dEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLCtEQUErRDtBQUNuRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUEsd0JBQXdCLHFIQUFxSDtBQUM3SSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FB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QTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx3RUFBd0U7QUFDeEU7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDLFFBQVE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxJQUFJO0FBQ0osR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTs7QUFFTixLQUFLLE9BQU87QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsYUFBYSw4Q0FBOEM7O0FBRTNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFF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QUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUEsQ0FBQztBQUNEIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2xlYWZsZXQubWFya2VyY2x1c3Rlci9kaXN0L2xlYWZsZXQubWFya2VyY2x1c3Rlci1zcmMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogTGVhZmxldC5tYXJrZXJjbHVzdGVyIDEuNC4xK21hc3Rlci45NGY5ODE1LFxuICogUHJvdmlkZXMgQmVhdXRpZnVsIEFuaW1hdGVkIE1hcmtlciBDbHVzdGVyaW5nIGZ1bmN0aW9uYWxpdHkgZm9yIExlYWZsZXQsIGEgSlMgbGlicmFyeSBmb3IgaW50ZXJhY3RpdmUgbWFwcy5cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQubWFya2VyY2x1c3RlclxuICogKGMpIDIwMTItMjAxNywgRGF2ZSBMZWF2ZXIsIHNtYXJ0cmFrXG4gKi9cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcblx0KGZhY3RvcnkoKGdsb2JhbC5MZWFmbGV0ID0gZ2xvYmFsLkxlYWZsZXQgfHwge30sIGdsb2JhbC5MZWFmbGV0Lm1hcmtlcmNsdXN0ZXIgPSBnbG9iYWwuTGVhZmxldC5tYXJrZXJjbHVzdGVyIHx8IHt9KSkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG4vKlxyXG4gKiBMLk1hcmtlckNsdXN0ZXJHcm91cCBleHRlbmRzIEwuRmVhdHVyZUdyb3VwIGJ5IGNsdXN0ZXJpbmcgdGhlIG1hcmtlcnMgY29udGFpbmVkIHdpdGhpblxyXG4gKi9cclxuXHJcbnZhciBNYXJrZXJDbHVzdGVyR3JvdXAgPSBMLk1hcmtlckNsdXN0ZXJHcm91cCA9IEwuRmVhdHVyZUdyb3VwLmV4dGVuZCh7XHJcblxyXG5cdG9wdGlvbnM6IHtcclxuXHRcdG1heENsdXN0ZXJSYWRpdXM6IDgwLCAvL0EgY2x1c3RlciB3aWxsIGNvdmVyIGF0IG1vc3QgdGhpcyBtYW55IHBpeGVscyBmcm9tIGl0cyBjZW50ZXJcclxuXHRcdGljb25DcmVhdGVGdW5jdGlvbjogbnVsbCxcclxuXHRcdGNsdXN0ZXJQYW5lOiBMLk1hcmtlci5wcm90b3R5cGUub3B0aW9ucy5wYW5lLFxyXG5cclxuXHRcdHNwaWRlcmZ5T25NYXhab29tOiB0cnVlLFxyXG5cdFx0c2hvd0NvdmVyYWdlT25Ib3ZlcjogdHJ1ZSxcclxuXHRcdHpvb21Ub0JvdW5kc09uQ2xpY2s6IHRydWUsXHJcblx0XHRzaW5nbGVNYXJrZXJNb2RlOiBmYWxzZSxcclxuXHJcblx0XHRkaXNhYmxlQ2x1c3RlcmluZ0F0Wm9vbTogbnVsbCxcclxuXHJcblx0XHQvLyBTZXR0aW5nIHRoaXMgdG8gZmFsc2UgcHJldmVudHMgdGhlIHJlbW92YWwgb2YgYW55IGNsdXN0ZXJzIG91dHNpZGUgb2YgdGhlIHZpZXdwb2ludCwgd2hpY2hcclxuXHRcdC8vIGlzIHRoZSBkZWZhdWx0IGJlaGF2aW91ciBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy5cclxuXHRcdHJlbW92ZU91dHNpZGVWaXNpYmxlQm91bmRzOiB0cnVlLFxyXG5cclxuXHRcdC8vIFNldCB0byBmYWxzZSB0byBkaXNhYmxlIGFsbCBhbmltYXRpb25zICh6b29tIGFuZCBzcGlkZXJmeSkuXHJcblx0XHQvLyBJZiBmYWxzZSwgb3B0aW9uIGFuaW1hdGVBZGRpbmdNYXJrZXJzIGJlbG93IGhhcyBubyBlZmZlY3QuXHJcblx0XHQvLyBJZiBMLkRvbVV0aWwuVFJBTlNJVElPTiBpcyBmYWxzeSwgdGhpcyBvcHRpb24gaGFzIG5vIGVmZmVjdC5cclxuXHRcdGFuaW1hdGU6IHRydWUsXHJcblxyXG5cdFx0Ly9XaGV0aGVyIHRvIGFuaW1hdGUgYWRkaW5nIG1hcmtlcnMgYWZ0ZXIgYWRkaW5nIHRoZSBNYXJrZXJDbHVzdGVyR3JvdXAgdG8gdGhlIG1hcFxyXG5cdFx0Ly8gSWYgeW91IGFyZSBhZGRpbmcgaW5kaXZpZHVhbCBtYXJrZXJzIHNldCB0byB0cnVlLCBpZiBhZGRpbmcgYnVsayBtYXJrZXJzIGxlYXZlIGZhbHNlIGZvciBtYXNzaXZlIHBlcmZvcm1hbmNlIGdhaW5zLlxyXG5cdFx0YW5pbWF0ZUFkZGluZ01hcmtlcnM6IGZhbHNlLFxyXG5cclxuXHRcdC8vSW5jcmVhc2UgdG8gaW5jcmVhc2UgdGhlIGRpc3RhbmNlIGF3YXkgdGhhdCBzcGlkZXJmaWVkIG1hcmtlcnMgYXBwZWFyIGZyb20gdGhlIGNlbnRlclxyXG5cdFx0c3BpZGVyZnlEaXN0YW5jZU11bHRpcGxpZXI6IDEsXHJcblxyXG5cdFx0Ly8gTWFrZSBpdCBwb3NzaWJsZSB0byBzcGVjaWZ5IGEgcG9seWxpbmUgb3B0aW9ucyBvbiBhIHNwaWRlciBsZWdcclxuXHRcdHNwaWRlckxlZ1BvbHlsaW5lT3B0aW9uczogeyB3ZWlnaHQ6IDEuNSwgY29sb3I6ICcjMjIyJywgb3BhY2l0eTogMC41IH0sXHJcblxyXG5cdFx0Ly8gV2hlbiBidWxrIGFkZGluZyBsYXllcnMsIGFkZHMgbWFya2VycyBpbiBjaHVua3MuIE1lYW5zIGFkZExheWVycyBtYXkgbm90IGFkZCBhbGwgdGhlIGxheWVycyBpbiB0aGUgY2FsbCwgb3RoZXJzIHdpbGwgYmUgbG9hZGVkIGR1cmluZyBzZXRUaW1lb3V0c1xyXG5cdFx0Y2h1bmtlZExvYWRpbmc6IGZhbHNlLFxyXG5cdFx0Y2h1bmtJbnRlcnZhbDogMjAwLCAvLyBwcm9jZXNzIG1hcmtlcnMgZm9yIGEgbWF4aW11bSBvZiB+IG4gbWlsbGlzZWNvbmRzICh0aGVuIHRyaWdnZXIgdGhlIGNodW5rUHJvZ3Jlc3MgY2FsbGJhY2spXHJcblx0XHRjaHVua0RlbGF5OiA1MCwgLy8gYXQgdGhlIGVuZCBvZiBlYWNoIGludGVydmFsLCBnaXZlIG4gbWlsbGlzZWNvbmRzIGJhY2sgdG8gc3lzdGVtL2Jyb3dzZXJcclxuXHRcdGNodW5rUHJvZ3Jlc3M6IG51bGwsIC8vIHByb2dyZXNzIGNhbGxiYWNrOiBmdW5jdGlvbihwcm9jZXNzZWQsIHRvdGFsLCBlbGFwc2VkKSAoZS5nLiBmb3IgYSBwcm9ncmVzcyBpbmRpY2F0b3IpXHJcblxyXG5cdFx0Ly9PcHRpb25zIHRvIHBhc3MgdG8gdGhlIEwuUG9seWdvbiBjb25zdHJ1Y3RvclxyXG5cdFx0cG9seWdvbk9wdGlvbnM6IHt9XHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRcdEwuVXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMuaWNvbkNyZWF0ZUZ1bmN0aW9uKSB7XHJcblx0XHRcdHRoaXMub3B0aW9ucy5pY29uQ3JlYXRlRnVuY3Rpb24gPSB0aGlzLl9kZWZhdWx0SWNvbkNyZWF0ZUZ1bmN0aW9uO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2ZlYXR1cmVHcm91cCA9IEwuZmVhdHVyZUdyb3VwKCk7XHJcblx0XHR0aGlzLl9mZWF0dXJlR3JvdXAuYWRkRXZlbnRQYXJlbnQodGhpcyk7XHJcblxyXG5cdFx0dGhpcy5fbm9uUG9pbnRHcm91cCA9IEwuZmVhdHVyZUdyb3VwKCk7XHJcblx0XHR0aGlzLl9ub25Qb2ludEdyb3VwLmFkZEV2ZW50UGFyZW50KHRoaXMpO1xyXG5cclxuXHRcdHRoaXMuX2luWm9vbUFuaW1hdGlvbiA9IDA7XHJcblx0XHR0aGlzLl9uZWVkc0NsdXN0ZXJpbmcgPSBbXTtcclxuXHRcdHRoaXMuX25lZWRzUmVtb3ZpbmcgPSBbXTsgLy9NYXJrZXJzIHJlbW92ZWQgd2hpbGUgd2UgYXJlbid0IG9uIHRoZSBtYXAgbmVlZCB0byBiZSBrZXB0IHRyYWNrIG9mXHJcblx0XHQvL1RoZSBib3VuZHMgb2YgdGhlIGN1cnJlbnRseSBzaG93biBhcmVhIChmcm9tIF9nZXRFeHBhbmRlZFZpc2libGVCb3VuZHMpIFVwZGF0ZWQgb24gem9vbS9tb3ZlXHJcblx0XHR0aGlzLl9jdXJyZW50U2hvd25Cb3VuZHMgPSBudWxsO1xyXG5cclxuXHRcdHRoaXMuX3F1ZXVlID0gW107XHJcblxyXG5cdFx0dGhpcy5fY2hpbGRNYXJrZXJFdmVudEhhbmRsZXJzID0ge1xyXG5cdFx0XHQnZHJhZ3N0YXJ0JzogdGhpcy5fY2hpbGRNYXJrZXJEcmFnU3RhcnQsXHJcblx0XHRcdCdtb3ZlJzogdGhpcy5fY2hpbGRNYXJrZXJNb3ZlZCxcclxuXHRcdFx0J2RyYWdlbmQnOiB0aGlzLl9jaGlsZE1hcmtlckRyYWdFbmQsXHJcblx0XHR9O1xyXG5cclxuXHRcdC8vIEhvb2sgdGhlIGFwcHJvcHJpYXRlIGFuaW1hdGlvbiBtZXRob2RzLlxyXG5cdFx0dmFyIGFuaW1hdGUgPSBMLkRvbVV0aWwuVFJBTlNJVElPTiAmJiB0aGlzLm9wdGlvbnMuYW5pbWF0ZTtcclxuXHRcdEwuZXh0ZW5kKHRoaXMsIGFuaW1hdGUgPyB0aGlzLl93aXRoQW5pbWF0aW9uIDogdGhpcy5fbm9BbmltYXRpb24pO1xyXG5cdFx0Ly8gUmVtZW1iZXIgd2hpY2ggTWFya2VyQ2x1c3RlciBjbGFzcyB0byBpbnN0YW50aWF0ZSAoYW5pbWF0ZWQgb3Igbm90KS5cclxuXHRcdHRoaXMuX21hcmtlckNsdXN0ZXIgPSBhbmltYXRlID8gTC5NYXJrZXJDbHVzdGVyIDogTC5NYXJrZXJDbHVzdGVyTm9uQW5pbWF0ZWQ7XHJcblx0fSxcclxuXHJcblx0YWRkTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cclxuXHRcdGlmIChsYXllciBpbnN0YW5jZW9mIEwuTGF5ZXJHcm91cCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5hZGRMYXllcnMoW2xheWVyXSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly9Eb24ndCBjbHVzdGVyIG5vbiBwb2ludCBkYXRhXHJcblx0XHRpZiAoIWxheWVyLmdldExhdExuZykge1xyXG5cdFx0XHR0aGlzLl9ub25Qb2ludEdyb3VwLmFkZExheWVyKGxheWVyKTtcclxuXHRcdFx0dGhpcy5maXJlKCdsYXllcmFkZCcsIHsgbGF5ZXI6IGxheWVyIH0pO1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIXRoaXMuX21hcCkge1xyXG5cdFx0XHR0aGlzLl9uZWVkc0NsdXN0ZXJpbmcucHVzaChsYXllcik7XHJcblx0XHRcdHRoaXMuZmlyZSgnbGF5ZXJhZGQnLCB7IGxheWVyOiBsYXllciB9KTtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMuaGFzTGF5ZXIobGF5ZXIpKSB7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHJcblx0XHQvL0lmIHdlIGhhdmUgYWxyZWFkeSBjbHVzdGVyZWQgd2UnbGwgbmVlZCB0byBhZGQgdGhpcyBvbmUgdG8gYSBjbHVzdGVyXHJcblxyXG5cdFx0aWYgKHRoaXMuX3Vuc3BpZGVyZnkpIHtcclxuXHRcdFx0dGhpcy5fdW5zcGlkZXJmeSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2FkZExheWVyKGxheWVyLCB0aGlzLl9tYXhab29tKTtcclxuXHRcdHRoaXMuZmlyZSgnbGF5ZXJhZGQnLCB7IGxheWVyOiBsYXllciB9KTtcclxuXHJcblx0XHQvLyBSZWZyZXNoIGJvdW5kcyBhbmQgd2VpZ2h0ZWQgcG9zaXRpb25zLlxyXG5cdFx0dGhpcy5fdG9wQ2x1c3RlckxldmVsLl9yZWNhbGN1bGF0ZUJvdW5kcygpO1xyXG5cclxuXHRcdHRoaXMuX3JlZnJlc2hDbHVzdGVyc0ljb25zKCk7XHJcblxyXG5cdFx0Ly9Xb3JrIG91dCB3aGF0IGlzIHZpc2libGVcclxuXHRcdHZhciB2aXNpYmxlTGF5ZXIgPSBsYXllcixcclxuXHRcdCAgICBjdXJyZW50Wm9vbSA9IHRoaXMuX3pvb207XHJcblx0XHRpZiAobGF5ZXIuX19wYXJlbnQpIHtcclxuXHRcdFx0d2hpbGUgKHZpc2libGVMYXllci5fX3BhcmVudC5fem9vbSA+PSBjdXJyZW50Wm9vbSkge1xyXG5cdFx0XHRcdHZpc2libGVMYXllciA9IHZpc2libGVMYXllci5fX3BhcmVudDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLl9jdXJyZW50U2hvd25Cb3VuZHMuY29udGFpbnModmlzaWJsZUxheWVyLmdldExhdExuZygpKSkge1xyXG5cdFx0XHRpZiAodGhpcy5vcHRpb25zLmFuaW1hdGVBZGRpbmdNYXJrZXJzKSB7XHJcblx0XHRcdFx0dGhpcy5fYW5pbWF0aW9uQWRkTGF5ZXIobGF5ZXIsIHZpc2libGVMYXllcik7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhpcy5fYW5pbWF0aW9uQWRkTGF5ZXJOb25BbmltYXRlZChsYXllciwgdmlzaWJsZUxheWVyKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0cmVtb3ZlTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cclxuXHRcdGlmIChsYXllciBpbnN0YW5jZW9mIEwuTGF5ZXJHcm91cCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5yZW1vdmVMYXllcnMoW2xheWVyXSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly9Ob24gcG9pbnQgbGF5ZXJzXHJcblx0XHRpZiAoIWxheWVyLmdldExhdExuZykge1xyXG5cdFx0XHR0aGlzLl9ub25Qb2ludEdyb3VwLnJlbW92ZUxheWVyKGxheWVyKTtcclxuXHRcdFx0dGhpcy5maXJlKCdsYXllcnJlbW92ZScsIHsgbGF5ZXI6IGxheWVyIH0pO1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIXRoaXMuX21hcCkge1xyXG5cdFx0XHRpZiAoIXRoaXMuX2FycmF5U3BsaWNlKHRoaXMuX25lZWRzQ2x1c3RlcmluZywgbGF5ZXIpICYmIHRoaXMuaGFzTGF5ZXIobGF5ZXIpKSB7XHJcblx0XHRcdFx0dGhpcy5fbmVlZHNSZW1vdmluZy5wdXNoKHsgbGF5ZXI6IGxheWVyLCBsYXRsbmc6IGxheWVyLl9sYXRsbmcgfSk7XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy5maXJlKCdsYXllcnJlbW92ZScsIHsgbGF5ZXI6IGxheWVyIH0pO1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIWxheWVyLl9fcGFyZW50KSB7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLl91bnNwaWRlcmZ5KSB7XHJcblx0XHRcdHRoaXMuX3Vuc3BpZGVyZnkoKTtcclxuXHRcdFx0dGhpcy5fdW5zcGlkZXJmeUxheWVyKGxheWVyKTtcclxuXHRcdH1cclxuXHJcblx0XHQvL1JlbW92ZSB0aGUgbWFya2VyIGZyb20gY2x1c3RlcnNcclxuXHRcdHRoaXMuX3JlbW92ZUxheWVyKGxheWVyLCB0cnVlKTtcclxuXHRcdHRoaXMuZmlyZSgnbGF5ZXJyZW1vdmUnLCB7IGxheWVyOiBsYXllciB9KTtcclxuXHJcblx0XHQvLyBSZWZyZXNoIGJvdW5kcyBhbmQgd2VpZ2h0ZWQgcG9zaXRpb25zLlxyXG5cdFx0dGhpcy5fdG9wQ2x1c3RlckxldmVsLl9yZWNhbGN1bGF0ZUJvdW5kcygpO1xyXG5cclxuXHRcdHRoaXMuX3JlZnJlc2hDbHVzdGVyc0ljb25zKCk7XHJcblxyXG5cdFx0bGF5ZXIub2ZmKHRoaXMuX2NoaWxkTWFya2VyRXZlbnRIYW5kbGVycywgdGhpcyk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2ZlYXR1cmVHcm91cC5oYXNMYXllcihsYXllcikpIHtcclxuXHRcdFx0dGhpcy5fZmVhdHVyZUdyb3VwLnJlbW92ZUxheWVyKGxheWVyKTtcclxuXHRcdFx0aWYgKGxheWVyLmNsdXN0ZXJTaG93KSB7XHJcblx0XHRcdFx0bGF5ZXIuY2x1c3RlclNob3coKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vVGFrZXMgYW4gYXJyYXkgb2YgbWFya2VycyBhbmQgYWRkcyB0aGVtIGluIGJ1bGtcclxuXHRhZGRMYXllcnM6IGZ1bmN0aW9uIChsYXllcnNBcnJheSwgc2tpcExheWVyQWRkRXZlbnQpIHtcclxuXHRcdGlmICghTC5VdGlsLmlzQXJyYXkobGF5ZXJzQXJyYXkpKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLmFkZExheWVyKGxheWVyc0FycmF5KTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZmcgPSB0aGlzLl9mZWF0dXJlR3JvdXAsXHJcblx0XHQgICAgbnBnID0gdGhpcy5fbm9uUG9pbnRHcm91cCxcclxuXHRcdCAgICBjaHVua2VkID0gdGhpcy5vcHRpb25zLmNodW5rZWRMb2FkaW5nLFxyXG5cdFx0ICAgIGNodW5rSW50ZXJ2YWwgPSB0aGlzLm9wdGlvbnMuY2h1bmtJbnRlcnZhbCxcclxuXHRcdCAgICBjaHVua1Byb2dyZXNzID0gdGhpcy5vcHRpb25zLmNodW5rUHJvZ3Jlc3MsXHJcblx0XHQgICAgbCA9IGxheWVyc0FycmF5Lmxlbmd0aCxcclxuXHRcdCAgICBvZmZzZXQgPSAwLFxyXG5cdFx0ICAgIG9yaWdpbmFsQXJyYXkgPSB0cnVlLFxyXG5cdFx0ICAgIG07XHJcblxyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR2YXIgc3RhcnRlZCA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XHJcblx0XHRcdHZhciBwcm9jZXNzID0gTC5iaW5kKGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0XHR2YXIgc3RhcnQgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xyXG5cdFx0XHRcdGZvciAoOyBvZmZzZXQgPCBsOyBvZmZzZXQrKykge1xyXG5cdFx0XHRcdFx0aWYgKGNodW5rZWQgJiYgb2Zmc2V0ICUgMjAwID09PSAwKSB7XHJcblx0XHRcdFx0XHRcdC8vIGV2ZXJ5IGNvdXBsZSBodW5kcmVkIG1hcmtlcnMsIGluc3RydW1lbnQgdGhlIHRpbWUgZWxhcHNlZCBzaW5jZSBwcm9jZXNzaW5nIHN0YXJ0ZWQ6XHJcblx0XHRcdFx0XHRcdHZhciBlbGFwc2VkID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKSAtIHN0YXJ0O1xyXG5cdFx0XHRcdFx0XHRpZiAoZWxhcHNlZCA+IGNodW5rSW50ZXJ2YWwpIHtcclxuXHRcdFx0XHRcdFx0XHRicmVhazsgLy8gYmVlbiB3b3JraW5nIHRvbyBoYXJkLCB0aW1lIHRvIHRha2UgYSBicmVhayA6LSlcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdG0gPSBsYXllcnNBcnJheVtvZmZzZXRdO1xyXG5cclxuXHRcdFx0XHRcdC8vIEdyb3VwIG9mIGxheWVycywgYXBwZW5kIGNoaWxkcmVuIHRvIGxheWVyc0FycmF5IGFuZCBza2lwLlxyXG5cdFx0XHRcdFx0Ly8gU2lkZSBlZmZlY3RzOlxyXG5cdFx0XHRcdFx0Ly8gLSBUb3RhbCBpbmNyZWFzZXMsIHNvIGNodW5rUHJvZ3Jlc3MgcmF0aW8ganVtcHMgYmFja3dhcmQuXHJcblx0XHRcdFx0XHQvLyAtIEdyb3VwcyBhcmUgbm90IGluY2x1ZGVkIGluIHRoaXMgZ3JvdXAsIG9ubHkgdGhlaXIgbm9uLWdyb3VwIGNoaWxkIGxheWVycyAoaGFzTGF5ZXIpLlxyXG5cdFx0XHRcdFx0Ly8gQ2hhbmdpbmcgYXJyYXkgbGVuZ3RoIHdoaWxlIGxvb3BpbmcgZG9lcyBub3QgYWZmZWN0IHBlcmZvcm1hbmNlIGluIGN1cnJlbnQgYnJvd3NlcnM6XHJcblx0XHRcdFx0XHQvLyBodHRwOi8vanNwZXJmLmNvbS9mb3ItbG9vcC1jaGFuZ2luZy1sZW5ndGgvNlxyXG5cdFx0XHRcdFx0aWYgKG0gaW5zdGFuY2VvZiBMLkxheWVyR3JvdXApIHtcclxuXHRcdFx0XHRcdFx0aWYgKG9yaWdpbmFsQXJyYXkpIHtcclxuXHRcdFx0XHRcdFx0XHRsYXllcnNBcnJheSA9IGxheWVyc0FycmF5LnNsaWNlKCk7XHJcblx0XHRcdFx0XHRcdFx0b3JpZ2luYWxBcnJheSA9IGZhbHNlO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdHRoaXMuX2V4dHJhY3ROb25Hcm91cExheWVycyhtLCBsYXllcnNBcnJheSk7XHJcblx0XHRcdFx0XHRcdGwgPSBsYXllcnNBcnJheS5sZW5ndGg7XHJcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdC8vTm90IHBvaW50IGRhdGEsIGNhbid0IGJlIGNsdXN0ZXJlZFxyXG5cdFx0XHRcdFx0aWYgKCFtLmdldExhdExuZykge1xyXG5cdFx0XHRcdFx0XHRucGcuYWRkTGF5ZXIobSk7XHJcblx0XHRcdFx0XHRcdGlmICghc2tpcExheWVyQWRkRXZlbnQpIHtcclxuXHRcdFx0XHRcdFx0XHR0aGlzLmZpcmUoJ2xheWVyYWRkJywgeyBsYXllcjogbSB9KTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRpZiAodGhpcy5oYXNMYXllcihtKSkge1xyXG5cdFx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR0aGlzLl9hZGRMYXllcihtLCB0aGlzLl9tYXhab29tKTtcclxuXHRcdFx0XHRcdGlmICghc2tpcExheWVyQWRkRXZlbnQpIHtcclxuXHRcdFx0XHRcdFx0dGhpcy5maXJlKCdsYXllcmFkZCcsIHsgbGF5ZXI6IG0gfSk7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Ly9JZiB3ZSBqdXN0IG1hZGUgYSBjbHVzdGVyIG9mIHNpemUgMiB0aGVuIHdlIG5lZWQgdG8gcmVtb3ZlIHRoZSBvdGhlciBtYXJrZXIgZnJvbSB0aGUgbWFwIChpZiBpdCBpcykgb3Igd2UgbmV2ZXIgd2lsbFxyXG5cdFx0XHRcdFx0aWYgKG0uX19wYXJlbnQpIHtcclxuXHRcdFx0XHRcdFx0aWYgKG0uX19wYXJlbnQuZ2V0Q2hpbGRDb3VudCgpID09PSAyKSB7XHJcblx0XHRcdFx0XHRcdFx0dmFyIG1hcmtlcnMgPSBtLl9fcGFyZW50LmdldEFsbENoaWxkTWFya2VycygpLFxyXG5cdFx0XHRcdFx0XHRcdCAgICBvdGhlck1hcmtlciA9IG1hcmtlcnNbMF0gPT09IG0gPyBtYXJrZXJzWzFdIDogbWFya2Vyc1swXTtcclxuXHRcdFx0XHRcdFx0XHRmZy5yZW1vdmVMYXllcihvdGhlck1hcmtlcik7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmIChjaHVua1Byb2dyZXNzKSB7XHJcblx0XHRcdFx0XHQvLyByZXBvcnQgcHJvZ3Jlc3MgYW5kIHRpbWUgZWxhcHNlZDpcclxuXHRcdFx0XHRcdGNodW5rUHJvZ3Jlc3Mob2Zmc2V0LCBsLCAobmV3IERhdGUoKSkuZ2V0VGltZSgpIC0gc3RhcnRlZCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBDb21wbGV0ZWQgcHJvY2Vzc2luZyBhbGwgbWFya2Vycy5cclxuXHRcdFx0XHRpZiAob2Zmc2V0ID09PSBsKSB7XHJcblxyXG5cdFx0XHRcdFx0Ly8gUmVmcmVzaCBib3VuZHMgYW5kIHdlaWdodGVkIHBvc2l0aW9ucy5cclxuXHRcdFx0XHRcdHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5fcmVjYWxjdWxhdGVCb3VuZHMoKTtcclxuXHJcblx0XHRcdFx0XHR0aGlzLl9yZWZyZXNoQ2x1c3RlcnNJY29ucygpO1xyXG5cclxuXHRcdFx0XHRcdHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5fcmVjdXJzaXZlbHlBZGRDaGlsZHJlblRvTWFwKG51bGwsIHRoaXMuX3pvb20sIHRoaXMuX2N1cnJlbnRTaG93bkJvdW5kcyk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHNldFRpbWVvdXQocHJvY2VzcywgdGhpcy5vcHRpb25zLmNodW5rRGVsYXkpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSwgdGhpcyk7XHJcblxyXG5cdFx0XHRwcm9jZXNzKCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR2YXIgbmVlZHNDbHVzdGVyaW5nID0gdGhpcy5fbmVlZHNDbHVzdGVyaW5nO1xyXG5cclxuXHRcdFx0Zm9yICg7IG9mZnNldCA8IGw7IG9mZnNldCsrKSB7XHJcblx0XHRcdFx0bSA9IGxheWVyc0FycmF5W29mZnNldF07XHJcblxyXG5cdFx0XHRcdC8vIEdyb3VwIG9mIGxheWVycywgYXBwZW5kIGNoaWxkcmVuIHRvIGxheWVyc0FycmF5IGFuZCBza2lwLlxyXG5cdFx0XHRcdGlmIChtIGluc3RhbmNlb2YgTC5MYXllckdyb3VwKSB7XHJcblx0XHRcdFx0XHRpZiAob3JpZ2luYWxBcnJheSkge1xyXG5cdFx0XHRcdFx0XHRsYXllcnNBcnJheSA9IGxheWVyc0FycmF5LnNsaWNlKCk7XHJcblx0XHRcdFx0XHRcdG9yaWdpbmFsQXJyYXkgPSBmYWxzZTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHRoaXMuX2V4dHJhY3ROb25Hcm91cExheWVycyhtLCBsYXllcnNBcnJheSk7XHJcblx0XHRcdFx0XHRsID0gbGF5ZXJzQXJyYXkubGVuZ3RoO1xyXG5cdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvL05vdCBwb2ludCBkYXRhLCBjYW4ndCBiZSBjbHVzdGVyZWRcclxuXHRcdFx0XHRpZiAoIW0uZ2V0TGF0TG5nKSB7XHJcblx0XHRcdFx0XHRucGcuYWRkTGF5ZXIobSk7XHJcblx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICh0aGlzLmhhc0xheWVyKG0pKSB7XHJcblx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdG5lZWRzQ2x1c3RlcmluZy5wdXNoKG0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvL1Rha2VzIGFuIGFycmF5IG9mIG1hcmtlcnMgYW5kIHJlbW92ZXMgdGhlbSBpbiBidWxrXHJcblx0cmVtb3ZlTGF5ZXJzOiBmdW5jdGlvbiAobGF5ZXJzQXJyYXkpIHtcclxuXHRcdHZhciBpLCBtLFxyXG5cdFx0ICAgIGwgPSBsYXllcnNBcnJheS5sZW5ndGgsXHJcblx0XHQgICAgZmcgPSB0aGlzLl9mZWF0dXJlR3JvdXAsXHJcblx0XHQgICAgbnBnID0gdGhpcy5fbm9uUG9pbnRHcm91cCxcclxuXHRcdCAgICBvcmlnaW5hbEFycmF5ID0gdHJ1ZTtcclxuXHJcblx0XHRpZiAoIXRoaXMuX21hcCkge1xyXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XHJcblx0XHRcdFx0bSA9IGxheWVyc0FycmF5W2ldO1xyXG5cclxuXHRcdFx0XHQvLyBHcm91cCBvZiBsYXllcnMsIGFwcGVuZCBjaGlsZHJlbiB0byBsYXllcnNBcnJheSBhbmQgc2tpcC5cclxuXHRcdFx0XHRpZiAobSBpbnN0YW5jZW9mIEwuTGF5ZXJHcm91cCkge1xyXG5cdFx0XHRcdFx0aWYgKG9yaWdpbmFsQXJyYXkpIHtcclxuXHRcdFx0XHRcdFx0bGF5ZXJzQXJyYXkgPSBsYXllcnNBcnJheS5zbGljZSgpO1xyXG5cdFx0XHRcdFx0XHRvcmlnaW5hbEFycmF5ID0gZmFsc2U7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR0aGlzLl9leHRyYWN0Tm9uR3JvdXBMYXllcnMobSwgbGF5ZXJzQXJyYXkpO1xyXG5cdFx0XHRcdFx0bCA9IGxheWVyc0FycmF5Lmxlbmd0aDtcclxuXHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGhpcy5fYXJyYXlTcGxpY2UodGhpcy5fbmVlZHNDbHVzdGVyaW5nLCBtKTtcclxuXHRcdFx0XHRucGcucmVtb3ZlTGF5ZXIobSk7XHJcblx0XHRcdFx0aWYgKHRoaXMuaGFzTGF5ZXIobSkpIHtcclxuXHRcdFx0XHRcdHRoaXMuX25lZWRzUmVtb3ZpbmcucHVzaCh7IGxheWVyOiBtLCBsYXRsbmc6IG0uX2xhdGxuZyB9KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dGhpcy5maXJlKCdsYXllcnJlbW92ZScsIHsgbGF5ZXI6IG0gfSk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMuX3Vuc3BpZGVyZnkpIHtcclxuXHRcdFx0dGhpcy5fdW5zcGlkZXJmeSgpO1xyXG5cclxuXHRcdFx0Ly8gV29yayBvbiBhIGNvcHkgb2YgdGhlIGFycmF5LCBzbyB0aGF0IG5leHQgbG9vcCBpcyBub3QgYWZmZWN0ZWQuXHJcblx0XHRcdHZhciBsYXllcnNBcnJheTIgPSBsYXllcnNBcnJheS5zbGljZSgpLFxyXG5cdFx0XHQgICAgbDIgPSBsO1xyXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbDI7IGkrKykge1xyXG5cdFx0XHRcdG0gPSBsYXllcnNBcnJheTJbaV07XHJcblxyXG5cdFx0XHRcdC8vIEdyb3VwIG9mIGxheWVycywgYXBwZW5kIGNoaWxkcmVuIHRvIGxheWVyc0FycmF5IGFuZCBza2lwLlxyXG5cdFx0XHRcdGlmIChtIGluc3RhbmNlb2YgTC5MYXllckdyb3VwKSB7XHJcblx0XHRcdFx0XHR0aGlzLl9leHRyYWN0Tm9uR3JvdXBMYXllcnMobSwgbGF5ZXJzQXJyYXkyKTtcclxuXHRcdFx0XHRcdGwyID0gbGF5ZXJzQXJyYXkyLmxlbmd0aDtcclxuXHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGhpcy5fdW5zcGlkZXJmeUxheWVyKG0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xyXG5cdFx0XHRtID0gbGF5ZXJzQXJyYXlbaV07XHJcblxyXG5cdFx0XHQvLyBHcm91cCBvZiBsYXllcnMsIGFwcGVuZCBjaGlsZHJlbiB0byBsYXllcnNBcnJheSBhbmQgc2tpcC5cclxuXHRcdFx0aWYgKG0gaW5zdGFuY2VvZiBMLkxheWVyR3JvdXApIHtcclxuXHRcdFx0XHRpZiAob3JpZ2luYWxBcnJheSkge1xyXG5cdFx0XHRcdFx0bGF5ZXJzQXJyYXkgPSBsYXllcnNBcnJheS5zbGljZSgpO1xyXG5cdFx0XHRcdFx0b3JpZ2luYWxBcnJheSA9IGZhbHNlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR0aGlzLl9leHRyYWN0Tm9uR3JvdXBMYXllcnMobSwgbGF5ZXJzQXJyYXkpO1xyXG5cdFx0XHRcdGwgPSBsYXllcnNBcnJheS5sZW5ndGg7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICghbS5fX3BhcmVudCkge1xyXG5cdFx0XHRcdG5wZy5yZW1vdmVMYXllcihtKTtcclxuXHRcdFx0XHR0aGlzLmZpcmUoJ2xheWVycmVtb3ZlJywgeyBsYXllcjogbSB9KTtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5fcmVtb3ZlTGF5ZXIobSwgdHJ1ZSwgdHJ1ZSk7XHJcblx0XHRcdHRoaXMuZmlyZSgnbGF5ZXJyZW1vdmUnLCB7IGxheWVyOiBtIH0pO1xyXG5cclxuXHRcdFx0aWYgKGZnLmhhc0xheWVyKG0pKSB7XHJcblx0XHRcdFx0ZmcucmVtb3ZlTGF5ZXIobSk7XHJcblx0XHRcdFx0aWYgKG0uY2x1c3RlclNob3cpIHtcclxuXHRcdFx0XHRcdG0uY2x1c3RlclNob3coKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBSZWZyZXNoIGJvdW5kcyBhbmQgd2VpZ2h0ZWQgcG9zaXRpb25zLlxyXG5cdFx0dGhpcy5fdG9wQ2x1c3RlckxldmVsLl9yZWNhbGN1bGF0ZUJvdW5kcygpO1xyXG5cclxuXHRcdHRoaXMuX3JlZnJlc2hDbHVzdGVyc0ljb25zKCk7XHJcblxyXG5cdFx0Ly9GaXggdXAgdGhlIGNsdXN0ZXJzIGFuZCBtYXJrZXJzIG9uIHRoZSBtYXBcclxuXHRcdHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5fcmVjdXJzaXZlbHlBZGRDaGlsZHJlblRvTWFwKG51bGwsIHRoaXMuX3pvb20sIHRoaXMuX2N1cnJlbnRTaG93bkJvdW5kcyk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly9SZW1vdmVzIGFsbCBsYXllcnMgZnJvbSB0aGUgTWFya2VyQ2x1c3Rlckdyb3VwXHJcblx0Y2xlYXJMYXllcnM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdC8vTmVlZCBvdXIgb3duIHNwZWNpYWwgaW1wbGVtZW50YXRpb24gYXMgdGhlIExheWVyR3JvdXAgb25lIGRvZXNuJ3Qgd29yayBmb3IgdXNcclxuXHJcblx0XHQvL0lmIHdlIGFyZW4ndCBvbiB0aGUgbWFwICh5ZXQpLCBibG93IGF3YXkgdGhlIG1hcmtlcnMgd2Uga25vdyBvZlxyXG5cdFx0aWYgKCF0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5fbmVlZHNDbHVzdGVyaW5nID0gW107XHJcblx0XHRcdHRoaXMuX25lZWRzUmVtb3ZpbmcgPSBbXTtcclxuXHRcdFx0ZGVsZXRlIHRoaXMuX2dyaWRDbHVzdGVycztcclxuXHRcdFx0ZGVsZXRlIHRoaXMuX2dyaWRVbmNsdXN0ZXJlZDtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5fbm9hbmltYXRpb25VbnNwaWRlcmZ5KSB7XHJcblx0XHRcdHRoaXMuX25vYW5pbWF0aW9uVW5zcGlkZXJmeSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vUmVtb3ZlIGFsbCB0aGUgdmlzaWJsZSBsYXllcnNcclxuXHRcdHRoaXMuX2ZlYXR1cmVHcm91cC5jbGVhckxheWVycygpO1xyXG5cdFx0dGhpcy5fbm9uUG9pbnRHcm91cC5jbGVhckxheWVycygpO1xyXG5cclxuXHRcdHRoaXMuZWFjaExheWVyKGZ1bmN0aW9uIChtYXJrZXIpIHtcclxuXHRcdFx0bWFya2VyLm9mZih0aGlzLl9jaGlsZE1hcmtlckV2ZW50SGFuZGxlcnMsIHRoaXMpO1xyXG5cdFx0XHRkZWxldGUgbWFya2VyLl9fcGFyZW50O1xyXG5cdFx0fSwgdGhpcyk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHQvL1Jlc2V0IF90b3BDbHVzdGVyTGV2ZWwgYW5kIHRoZSBEaXN0YW5jZUdyaWRzXHJcblx0XHRcdHRoaXMuX2dlbmVyYXRlSW5pdGlhbENsdXN0ZXJzKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly9PdmVycmlkZSBGZWF0dXJlR3JvdXAuZ2V0Qm91bmRzIGFzIGl0IGRvZXNuJ3Qgd29ya1xyXG5cdGdldEJvdW5kczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGJvdW5kcyA9IG5ldyBMLkxhdExuZ0JvdW5kcygpO1xyXG5cclxuXHRcdGlmICh0aGlzLl90b3BDbHVzdGVyTGV2ZWwpIHtcclxuXHRcdFx0Ym91bmRzLmV4dGVuZCh0aGlzLl90b3BDbHVzdGVyTGV2ZWwuX2JvdW5kcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IHRoaXMuX25lZWRzQ2x1c3RlcmluZy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG5cdFx0XHRib3VuZHMuZXh0ZW5kKHRoaXMuX25lZWRzQ2x1c3RlcmluZ1tpXS5nZXRMYXRMbmcoKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ym91bmRzLmV4dGVuZCh0aGlzLl9ub25Qb2ludEdyb3VwLmdldEJvdW5kcygpKTtcclxuXHJcblx0XHRyZXR1cm4gYm91bmRzO1xyXG5cdH0sXHJcblxyXG5cdC8vT3ZlcnJpZGVzIExheWVyR3JvdXAuZWFjaExheWVyXHJcblx0ZWFjaExheWVyOiBmdW5jdGlvbiAobWV0aG9kLCBjb250ZXh0KSB7XHJcblx0XHR2YXIgbWFya2VycyA9IHRoaXMuX25lZWRzQ2x1c3RlcmluZy5zbGljZSgpLFxyXG5cdFx0XHRuZWVkc1JlbW92aW5nID0gdGhpcy5fbmVlZHNSZW1vdmluZyxcclxuXHRcdFx0dGhpc05lZWRzUmVtb3ZpbmcsIGksIGo7XHJcblxyXG5cdFx0aWYgKHRoaXMuX3RvcENsdXN0ZXJMZXZlbCkge1xyXG5cdFx0XHR0aGlzLl90b3BDbHVzdGVyTGV2ZWwuZ2V0QWxsQ2hpbGRNYXJrZXJzKG1hcmtlcnMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoaSA9IG1hcmtlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuXHRcdFx0dGhpc05lZWRzUmVtb3ZpbmcgPSB0cnVlO1xyXG5cclxuXHRcdFx0Zm9yIChqID0gbmVlZHNSZW1vdmluZy5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xyXG5cdFx0XHRcdGlmIChuZWVkc1JlbW92aW5nW2pdLmxheWVyID09PSBtYXJrZXJzW2ldKSB7XHJcblx0XHRcdFx0XHR0aGlzTmVlZHNSZW1vdmluZyA9IGZhbHNlO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAodGhpc05lZWRzUmVtb3ZpbmcpIHtcclxuXHRcdFx0XHRtZXRob2QuY2FsbChjb250ZXh0LCBtYXJrZXJzW2ldKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX25vblBvaW50R3JvdXAuZWFjaExheWVyKG1ldGhvZCwgY29udGV4dCk7XHJcblx0fSxcclxuXHJcblx0Ly9PdmVycmlkZXMgTGF5ZXJHcm91cC5nZXRMYXllcnNcclxuXHRnZXRMYXllcnM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBsYXllcnMgPSBbXTtcclxuXHRcdHRoaXMuZWFjaExheWVyKGZ1bmN0aW9uIChsKSB7XHJcblx0XHRcdGxheWVycy5wdXNoKGwpO1xyXG5cdFx0fSk7XHJcblx0XHRyZXR1cm4gbGF5ZXJzO1xyXG5cdH0sXHJcblxyXG5cdC8vT3ZlcnJpZGVzIExheWVyR3JvdXAuZ2V0TGF5ZXIsIFdBUk5JTkc6IFJlYWxseSBiYWQgcGVyZm9ybWFuY2VcclxuXHRnZXRMYXllcjogZnVuY3Rpb24gKGlkKSB7XHJcblx0XHR2YXIgcmVzdWx0ID0gbnVsbDtcclxuXHJcblx0XHRpZCA9IHBhcnNlSW50KGlkLCAxMCk7XHJcblxyXG5cdFx0dGhpcy5lYWNoTGF5ZXIoZnVuY3Rpb24gKGwpIHtcclxuXHRcdFx0aWYgKEwuc3RhbXAobCkgPT09IGlkKSB7XHJcblx0XHRcdFx0cmVzdWx0ID0gbDtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0cmV0dXJuIHJlc3VsdDtcclxuXHR9LFxyXG5cclxuXHQvL1JldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbGF5ZXIgaXMgaW4gdGhpcyBNYXJrZXJDbHVzdGVyR3JvdXBcclxuXHRoYXNMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRpZiAoIWxheWVyKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgaSwgYW5BcnJheSA9IHRoaXMuX25lZWRzQ2x1c3RlcmluZztcclxuXHJcblx0XHRmb3IgKGkgPSBhbkFycmF5Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdGlmIChhbkFycmF5W2ldID09PSBsYXllcikge1xyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0YW5BcnJheSA9IHRoaXMuX25lZWRzUmVtb3Zpbmc7XHJcblx0XHRmb3IgKGkgPSBhbkFycmF5Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdGlmIChhbkFycmF5W2ldLmxheWVyID09PSBsYXllcikge1xyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiAhIShsYXllci5fX3BhcmVudCAmJiBsYXllci5fX3BhcmVudC5fZ3JvdXAgPT09IHRoaXMpIHx8IHRoaXMuX25vblBvaW50R3JvdXAuaGFzTGF5ZXIobGF5ZXIpO1xyXG5cdH0sXHJcblxyXG5cdC8vWm9vbSBkb3duIHRvIHNob3cgdGhlIGdpdmVuIGxheWVyIChzcGlkZXJmeWluZyBpZiBuZWNlc3NhcnkpIHRoZW4gY2FsbHMgdGhlIGNhbGxiYWNrXHJcblx0em9vbVRvU2hvd0xheWVyOiBmdW5jdGlvbiAobGF5ZXIsIGNhbGxiYWNrKSB7XHJcblxyXG5cdFx0aWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHRjYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBzaG93TWFya2VyID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRpZiAoKGxheWVyLl9pY29uIHx8IGxheWVyLl9fcGFyZW50Ll9pY29uKSAmJiAhdGhpcy5faW5ab29tQW5pbWF0aW9uKSB7XHJcblx0XHRcdFx0dGhpcy5fbWFwLm9mZignbW92ZWVuZCcsIHNob3dNYXJrZXIsIHRoaXMpO1xyXG5cdFx0XHRcdHRoaXMub2ZmKCdhbmltYXRpb25lbmQnLCBzaG93TWFya2VyLCB0aGlzKTtcclxuXHJcblx0XHRcdFx0aWYgKGxheWVyLl9pY29uKSB7XHJcblx0XHRcdFx0XHRjYWxsYmFjaygpO1xyXG5cdFx0XHRcdH0gZWxzZSBpZiAobGF5ZXIuX19wYXJlbnQuX2ljb24pIHtcclxuXHRcdFx0XHRcdHRoaXMub25jZSgnc3BpZGVyZmllZCcsIGNhbGxiYWNrLCB0aGlzKTtcclxuXHRcdFx0XHRcdGxheWVyLl9fcGFyZW50LnNwaWRlcmZ5KCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9O1xyXG5cclxuXHRcdGlmIChsYXllci5faWNvbiAmJiB0aGlzLl9tYXAuZ2V0Qm91bmRzKCkuY29udGFpbnMobGF5ZXIuZ2V0TGF0TG5nKCkpKSB7XHJcblx0XHRcdC8vTGF5ZXIgaXMgdmlzaWJsZSBvbmQgb24gc2NyZWVuLCBpbW1lZGlhdGUgcmV0dXJuXHJcblx0XHRcdGNhbGxiYWNrKCk7XHJcblx0XHR9IGVsc2UgaWYgKGxheWVyLl9fcGFyZW50Ll96b29tIDwgTWF0aC5yb3VuZCh0aGlzLl9tYXAuX3pvb20pKSB7XHJcblx0XHRcdC8vTGF5ZXIgc2hvdWxkIGJlIHZpc2libGUgYXQgdGhpcyB6b29tIGxldmVsLiBJdCBtdXN0IG5vdCBiZSBvbiBzY3JlZW4gc28ganVzdCBwYW4gb3ZlciB0byBpdFxyXG5cdFx0XHR0aGlzLl9tYXAub24oJ21vdmVlbmQnLCBzaG93TWFya2VyLCB0aGlzKTtcclxuXHRcdFx0dGhpcy5fbWFwLnBhblRvKGxheWVyLmdldExhdExuZygpKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMuX21hcC5vbignbW92ZWVuZCcsIHNob3dNYXJrZXIsIHRoaXMpO1xyXG5cdFx0XHR0aGlzLm9uKCdhbmltYXRpb25lbmQnLCBzaG93TWFya2VyLCB0aGlzKTtcclxuXHRcdFx0bGF5ZXIuX19wYXJlbnQuem9vbVRvQm91bmRzKCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly9PdmVycmlkZXMgRmVhdHVyZUdyb3VwLm9uQWRkXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHRoaXMuX21hcCA9IG1hcDtcclxuXHRcdHZhciBpLCBsLCBsYXllcjtcclxuXHJcblx0XHRpZiAoIWlzRmluaXRlKHRoaXMuX21hcC5nZXRNYXhab29tKCkpKSB7XHJcblx0XHRcdHRocm93IFwiTWFwIGhhcyBubyBtYXhab29tIHNwZWNpZmllZFwiO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2ZlYXR1cmVHcm91cC5hZGRUbyhtYXApO1xyXG5cdFx0dGhpcy5fbm9uUG9pbnRHcm91cC5hZGRUbyhtYXApO1xyXG5cclxuXHRcdGlmICghdGhpcy5fZ3JpZENsdXN0ZXJzKSB7XHJcblx0XHRcdHRoaXMuX2dlbmVyYXRlSW5pdGlhbENsdXN0ZXJzKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fbWF4TGF0ID0gbWFwLm9wdGlvbnMuY3JzLnByb2plY3Rpb24uTUFYX0xBVElUVURFO1xyXG5cclxuXHRcdC8vUmVzdG9yZSBhbGwgdGhlIHBvc2l0aW9ucyBhcyB0aGV5IGFyZSBpbiB0aGUgTUNHIGJlZm9yZSByZW1vdmluZyB0aGVtXHJcblx0XHRmb3IgKGkgPSAwLCBsID0gdGhpcy5fbmVlZHNSZW1vdmluZy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuXHRcdFx0bGF5ZXIgPSB0aGlzLl9uZWVkc1JlbW92aW5nW2ldO1xyXG5cdFx0XHRsYXllci5uZXdsYXRsbmcgPSBsYXllci5sYXllci5fbGF0bG5nO1xyXG5cdFx0XHRsYXllci5sYXllci5fbGF0bG5nID0gbGF5ZXIubGF0bG5nO1xyXG5cdFx0fVxyXG5cdFx0Ly9SZW1vdmUgdGhlbSwgdGhlbiByZXN0b3JlIHRoZWlyIG5ldyBwb3NpdGlvbnNcclxuXHRcdGZvciAoaSA9IDAsIGwgPSB0aGlzLl9uZWVkc1JlbW92aW5nLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG5cdFx0XHRsYXllciA9IHRoaXMuX25lZWRzUmVtb3ZpbmdbaV07XHJcblx0XHRcdHRoaXMuX3JlbW92ZUxheWVyKGxheWVyLmxheWVyLCB0cnVlKTtcclxuXHRcdFx0bGF5ZXIubGF5ZXIuX2xhdGxuZyA9IGxheWVyLm5ld2xhdGxuZztcclxuXHRcdH1cclxuXHRcdHRoaXMuX25lZWRzUmVtb3ZpbmcgPSBbXTtcclxuXHJcblx0XHQvL1JlbWVtYmVyIHRoZSBjdXJyZW50IHpvb20gbGV2ZWwgYW5kIGJvdW5kc1xyXG5cdFx0dGhpcy5fem9vbSA9IE1hdGgucm91bmQodGhpcy5fbWFwLl96b29tKTtcclxuXHRcdHRoaXMuX2N1cnJlbnRTaG93bkJvdW5kcyA9IHRoaXMuX2dldEV4cGFuZGVkVmlzaWJsZUJvdW5kcygpO1xyXG5cclxuXHRcdHRoaXMuX21hcC5vbignem9vbWVuZCcsIHRoaXMuX3pvb21FbmQsIHRoaXMpO1xyXG5cdFx0dGhpcy5fbWFwLm9uKCdtb3ZlZW5kJywgdGhpcy5fbW92ZUVuZCwgdGhpcyk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX3NwaWRlcmZpZXJPbkFkZCkgeyAvL1RPRE8gRklYTUU6IE5vdCBzdXJlIGhvdyB0byBoYXZlIHNwaWRlcmZpZXIgYWRkIHNvbWV0aGluZyBvbiBoZXJlIG5pY2VseVxyXG5cdFx0XHR0aGlzLl9zcGlkZXJmaWVyT25BZGQoKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9iaW5kRXZlbnRzKCk7XHJcblxyXG5cdFx0Ly9BY3R1YWxseSBhZGQgb3VyIG1hcmtlcnMgdG8gdGhlIG1hcDpcclxuXHRcdGwgPSB0aGlzLl9uZWVkc0NsdXN0ZXJpbmc7XHJcblx0XHR0aGlzLl9uZWVkc0NsdXN0ZXJpbmcgPSBbXTtcclxuXHRcdHRoaXMuYWRkTGF5ZXJzKGwsIHRydWUpO1xyXG5cdH0sXHJcblxyXG5cdC8vT3ZlcnJpZGVzIEZlYXR1cmVHcm91cC5vblJlbW92ZVxyXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHRtYXAub2ZmKCd6b29tZW5kJywgdGhpcy5fem9vbUVuZCwgdGhpcyk7XHJcblx0XHRtYXAub2ZmKCdtb3ZlZW5kJywgdGhpcy5fbW92ZUVuZCwgdGhpcyk7XHJcblxyXG5cdFx0dGhpcy5fdW5iaW5kRXZlbnRzKCk7XHJcblxyXG5cdFx0Ly9JbiBjYXNlIHdlIGFyZSBpbiBhIGNsdXN0ZXIgYW5pbWF0aW9uXHJcblx0XHR0aGlzLl9tYXAuX21hcFBhbmUuY2xhc3NOYW1lID0gdGhpcy5fbWFwLl9tYXBQYW5lLmNsYXNzTmFtZS5yZXBsYWNlKCcgbGVhZmxldC1jbHVzdGVyLWFuaW0nLCAnJyk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX3NwaWRlcmZpZXJPblJlbW92ZSkgeyAvL1RPRE8gRklYTUU6IE5vdCBzdXJlIGhvdyB0byBoYXZlIHNwaWRlcmZpZXIgYWRkIHNvbWV0aGluZyBvbiBoZXJlIG5pY2VseVxyXG5cdFx0XHR0aGlzLl9zcGlkZXJmaWVyT25SZW1vdmUoKTtcclxuXHRcdH1cclxuXHJcblx0XHRkZWxldGUgdGhpcy5fbWF4TGF0O1xyXG5cclxuXHRcdC8vQ2xlYW4gdXAgYWxsIHRoZSBsYXllcnMgd2UgYWRkZWQgdG8gdGhlIG1hcFxyXG5cdFx0dGhpcy5faGlkZUNvdmVyYWdlKCk7XHJcblx0XHR0aGlzLl9mZWF0dXJlR3JvdXAucmVtb3ZlKCk7XHJcblx0XHR0aGlzLl9ub25Qb2ludEdyb3VwLnJlbW92ZSgpO1xyXG5cclxuXHRcdHRoaXMuX2ZlYXR1cmVHcm91cC5jbGVhckxheWVycygpO1xyXG5cclxuXHRcdHRoaXMuX21hcCA9IG51bGw7XHJcblx0fSxcclxuXHJcblx0Z2V0VmlzaWJsZVBhcmVudDogZnVuY3Rpb24gKG1hcmtlcikge1xyXG5cdFx0dmFyIHZNYXJrZXIgPSBtYXJrZXI7XHJcblx0XHR3aGlsZSAodk1hcmtlciAmJiAhdk1hcmtlci5faWNvbikge1xyXG5cdFx0XHR2TWFya2VyID0gdk1hcmtlci5fX3BhcmVudDtcclxuXHRcdH1cclxuXHRcdHJldHVybiB2TWFya2VyIHx8IG51bGw7XHJcblx0fSxcclxuXHJcblx0Ly9SZW1vdmUgdGhlIGdpdmVuIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBhcnJheVxyXG5cdF9hcnJheVNwbGljZTogZnVuY3Rpb24gKGFuQXJyYXksIG9iaikge1xyXG5cdFx0Zm9yICh2YXIgaSA9IGFuQXJyYXkubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuXHRcdFx0aWYgKGFuQXJyYXlbaV0gPT09IG9iaikge1xyXG5cdFx0XHRcdGFuQXJyYXkuc3BsaWNlKGksIDEpO1xyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogUmVtb3ZlcyBhIG1hcmtlciBmcm9tIGFsbCBfZ3JpZFVuY2x1c3RlcmVkIHpvb20gbGV2ZWxzLCBzdGFydGluZyBhdCB0aGUgc3VwcGxpZWQgem9vbS5cclxuXHQgKiBAcGFyYW0gbWFya2VyIHRvIGJlIHJlbW92ZWQgZnJvbSBfZ3JpZFVuY2x1c3RlcmVkLlxyXG5cdCAqIEBwYXJhbSB6IGludGVnZXIgYm90dG9tIHN0YXJ0IHpvb20gbGV2ZWwgKGluY2x1ZGVkKVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X3JlbW92ZUZyb21HcmlkVW5jbHVzdGVyZWQ6IGZ1bmN0aW9uIChtYXJrZXIsIHopIHtcclxuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXHJcblx0XHQgICAgZ3JpZFVuY2x1c3RlcmVkID0gdGhpcy5fZ3JpZFVuY2x1c3RlcmVkLFxyXG5cdFx0XHRtaW5ab29tID0gTWF0aC5mbG9vcih0aGlzLl9tYXAuZ2V0TWluWm9vbSgpKTtcclxuXHJcblx0XHRmb3IgKDsgeiA+PSBtaW5ab29tOyB6LS0pIHtcclxuXHRcdFx0aWYgKCFncmlkVW5jbHVzdGVyZWRbel0ucmVtb3ZlT2JqZWN0KG1hcmtlciwgbWFwLnByb2plY3QobWFya2VyLmdldExhdExuZygpLCB6KSkpIHtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9jaGlsZE1hcmtlckRyYWdTdGFydDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGUudGFyZ2V0Ll9fZHJhZ1N0YXJ0ID0gZS50YXJnZXQuX2xhdGxuZztcclxuXHR9LFxyXG5cclxuXHRfY2hpbGRNYXJrZXJNb3ZlZDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGlmICghdGhpcy5faWdub3JlTW92ZSAmJiAhZS50YXJnZXQuX19kcmFnU3RhcnQpIHtcclxuXHRcdFx0dmFyIGlzUG9wdXBPcGVuID0gZS50YXJnZXQuX3BvcHVwICYmIGUudGFyZ2V0Ll9wb3B1cC5pc09wZW4oKTtcclxuXHJcblx0XHRcdHRoaXMuX21vdmVDaGlsZChlLnRhcmdldCwgZS5vbGRMYXRMbmcsIGUubGF0bG5nKTtcclxuXHJcblx0XHRcdGlmIChpc1BvcHVwT3Blbikge1xyXG5cdFx0XHRcdGUudGFyZ2V0Lm9wZW5Qb3B1cCgpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X21vdmVDaGlsZDogZnVuY3Rpb24gKGxheWVyLCBmcm9tLCB0bykge1xyXG5cdFx0bGF5ZXIuX2xhdGxuZyA9IGZyb207XHJcblx0XHR0aGlzLnJlbW92ZUxheWVyKGxheWVyKTtcclxuXHJcblx0XHRsYXllci5fbGF0bG5nID0gdG87XHJcblx0XHR0aGlzLmFkZExheWVyKGxheWVyKTtcclxuXHR9LFxyXG5cclxuXHRfY2hpbGRNYXJrZXJEcmFnRW5kOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0dmFyIGRyYWdTdGFydCA9IGUudGFyZ2V0Ll9fZHJhZ1N0YXJ0O1xyXG5cdFx0ZGVsZXRlIGUudGFyZ2V0Ll9fZHJhZ1N0YXJ0O1xyXG5cdFx0aWYgKGRyYWdTdGFydCkge1xyXG5cdFx0XHR0aGlzLl9tb3ZlQ2hpbGQoZS50YXJnZXQsIGRyYWdTdGFydCwgZS50YXJnZXQuX2xhdGxuZyk7XHJcblx0XHR9XHRcdFxyXG5cdH0sXHJcblxyXG5cclxuXHQvL0ludGVybmFsIGZ1bmN0aW9uIGZvciByZW1vdmluZyBhIG1hcmtlciBmcm9tIGV2ZXJ5dGhpbmcuXHJcblx0Ly9kb250VXBkYXRlTWFwOiBzZXQgdG8gdHJ1ZSBpZiB5b3Ugd2lsbCBoYW5kbGUgdXBkYXRpbmcgdGhlIG1hcCBtYW51YWxseSAoZm9yIGJ1bGsgZnVuY3Rpb25zKVxyXG5cdF9yZW1vdmVMYXllcjogZnVuY3Rpb24gKG1hcmtlciwgcmVtb3ZlRnJvbURpc3RhbmNlR3JpZCwgZG9udFVwZGF0ZU1hcCkge1xyXG5cdFx0dmFyIGdyaWRDbHVzdGVycyA9IHRoaXMuX2dyaWRDbHVzdGVycyxcclxuXHRcdFx0Z3JpZFVuY2x1c3RlcmVkID0gdGhpcy5fZ3JpZFVuY2x1c3RlcmVkLFxyXG5cdFx0XHRmZyA9IHRoaXMuX2ZlYXR1cmVHcm91cCxcclxuXHRcdFx0bWFwID0gdGhpcy5fbWFwLFxyXG5cdFx0XHRtaW5ab29tID0gTWF0aC5mbG9vcih0aGlzLl9tYXAuZ2V0TWluWm9vbSgpKTtcclxuXHJcblx0XHQvL1JlbW92ZSB0aGUgbWFya2VyIGZyb20gZGlzdGFuY2UgY2x1c3RlcnMgaXQgbWlnaHQgYmUgaW5cclxuXHRcdGlmIChyZW1vdmVGcm9tRGlzdGFuY2VHcmlkKSB7XHJcblx0XHRcdHRoaXMuX3JlbW92ZUZyb21HcmlkVW5jbHVzdGVyZWQobWFya2VyLCB0aGlzLl9tYXhab29tKTtcclxuXHRcdH1cclxuXHJcblx0XHQvL1dvcmsgb3VyIHdheSB1cCB0aGUgY2x1c3RlcnMgcmVtb3ZpbmcgdGhlbSBhcyB3ZSBnbyBpZiByZXF1aXJlZFxyXG5cdFx0dmFyIGNsdXN0ZXIgPSBtYXJrZXIuX19wYXJlbnQsXHJcblx0XHRcdG1hcmtlcnMgPSBjbHVzdGVyLl9tYXJrZXJzLFxyXG5cdFx0XHRvdGhlck1hcmtlcjtcclxuXHJcblx0XHQvL1JlbW92ZSB0aGUgbWFya2VyIGZyb20gdGhlIGltbWVkaWF0ZSBwYXJlbnRzIG1hcmtlciBsaXN0XHJcblx0XHR0aGlzLl9hcnJheVNwbGljZShtYXJrZXJzLCBtYXJrZXIpO1xyXG5cclxuXHRcdHdoaWxlIChjbHVzdGVyKSB7XHJcblx0XHRcdGNsdXN0ZXIuX2NoaWxkQ291bnQtLTtcclxuXHRcdFx0Y2x1c3Rlci5fYm91bmRzTmVlZFVwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0XHRpZiAoY2x1c3Rlci5fem9vbSA8IG1pblpvb20pIHtcclxuXHRcdFx0XHQvL1RvcCBsZXZlbCwgZG8gbm90aGluZ1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHR9IGVsc2UgaWYgKHJlbW92ZUZyb21EaXN0YW5jZUdyaWQgJiYgY2x1c3Rlci5fY2hpbGRDb3VudCA8PSAxKSB7IC8vQ2x1c3RlciBubyBsb25nZXIgcmVxdWlyZWRcclxuXHRcdFx0XHQvL1dlIG5lZWQgdG8gcHVzaCB0aGUgb3RoZXIgbWFya2VyIHVwIHRvIHRoZSBwYXJlbnRcclxuXHRcdFx0XHRvdGhlck1hcmtlciA9IGNsdXN0ZXIuX21hcmtlcnNbMF0gPT09IG1hcmtlciA/IGNsdXN0ZXIuX21hcmtlcnNbMV0gOiBjbHVzdGVyLl9tYXJrZXJzWzBdO1xyXG5cclxuXHRcdFx0XHQvL1VwZGF0ZSBkaXN0YW5jZSBncmlkXHJcblx0XHRcdFx0Z3JpZENsdXN0ZXJzW2NsdXN0ZXIuX3pvb21dLnJlbW92ZU9iamVjdChjbHVzdGVyLCBtYXAucHJvamVjdChjbHVzdGVyLl9jTGF0TG5nLCBjbHVzdGVyLl96b29tKSk7XHJcblx0XHRcdFx0Z3JpZFVuY2x1c3RlcmVkW2NsdXN0ZXIuX3pvb21dLmFkZE9iamVjdChvdGhlck1hcmtlciwgbWFwLnByb2plY3Qob3RoZXJNYXJrZXIuZ2V0TGF0TG5nKCksIGNsdXN0ZXIuX3pvb20pKTtcclxuXHJcblx0XHRcdFx0Ly9Nb3ZlIG90aGVyTWFya2VyIHVwIHRvIHBhcmVudFxyXG5cdFx0XHRcdHRoaXMuX2FycmF5U3BsaWNlKGNsdXN0ZXIuX19wYXJlbnQuX2NoaWxkQ2x1c3RlcnMsIGNsdXN0ZXIpO1xyXG5cdFx0XHRcdGNsdXN0ZXIuX19wYXJlbnQuX21hcmtlcnMucHVzaChvdGhlck1hcmtlcik7XHJcblx0XHRcdFx0b3RoZXJNYXJrZXIuX19wYXJlbnQgPSBjbHVzdGVyLl9fcGFyZW50O1xyXG5cclxuXHRcdFx0XHRpZiAoY2x1c3Rlci5faWNvbikge1xyXG5cdFx0XHRcdFx0Ly9DbHVzdGVyIGlzIGN1cnJlbnRseSBvbiB0aGUgbWFwLCBuZWVkIHRvIHB1dCB0aGUgbWFya2VyIG9uIHRoZSBtYXAgaW5zdGVhZFxyXG5cdFx0XHRcdFx0ZmcucmVtb3ZlTGF5ZXIoY2x1c3Rlcik7XHJcblx0XHRcdFx0XHRpZiAoIWRvbnRVcGRhdGVNYXApIHtcclxuXHRcdFx0XHRcdFx0ZmcuYWRkTGF5ZXIob3RoZXJNYXJrZXIpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRjbHVzdGVyLl9pY29uTmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRjbHVzdGVyID0gY2x1c3Rlci5fX3BhcmVudDtcclxuXHRcdH1cclxuXHJcblx0XHRkZWxldGUgbWFya2VyLl9fcGFyZW50O1xyXG5cdH0sXHJcblxyXG5cdF9pc09ySXNQYXJlbnQ6IGZ1bmN0aW9uIChlbCwgb2VsKSB7XHJcblx0XHR3aGlsZSAob2VsKSB7XHJcblx0XHRcdGlmIChlbCA9PT0gb2VsKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdH1cclxuXHRcdFx0b2VsID0gb2VsLnBhcmVudE5vZGU7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fSxcclxuXHJcblx0Ly9PdmVycmlkZSBMLkV2ZW50ZWQuZmlyZVxyXG5cdGZpcmU6IGZ1bmN0aW9uICh0eXBlLCBkYXRhLCBwcm9wYWdhdGUpIHtcclxuXHRcdGlmIChkYXRhICYmIGRhdGEubGF5ZXIgaW5zdGFuY2VvZiBMLk1hcmtlckNsdXN0ZXIpIHtcclxuXHRcdFx0Ly9QcmV2ZW50IG11bHRpcGxlIGNsdXN0ZXJtb3VzZW92ZXIvb2ZmIGV2ZW50cyBpZiB0aGUgaWNvbiBpcyBtYWRlIHVwIG9mIHN0YWNrZWQgZGl2cyAoRG9lc24ndCB3b3JrIGluIGllIDw9IDgsIG5vIHJlbGF0ZWRUYXJnZXQpXHJcblx0XHRcdGlmIChkYXRhLm9yaWdpbmFsRXZlbnQgJiYgdGhpcy5faXNPcklzUGFyZW50KGRhdGEubGF5ZXIuX2ljb24sIGRhdGEub3JpZ2luYWxFdmVudC5yZWxhdGVkVGFyZ2V0KSkge1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cdFx0XHR0eXBlID0gJ2NsdXN0ZXInICsgdHlwZTtcclxuXHRcdH1cclxuXHJcblx0XHRMLkZlYXR1cmVHcm91cC5wcm90b3R5cGUuZmlyZS5jYWxsKHRoaXMsIHR5cGUsIGRhdGEsIHByb3BhZ2F0ZSk7XHJcblx0fSxcclxuXHJcblx0Ly9PdmVycmlkZSBMLkV2ZW50ZWQubGlzdGVuc1xyXG5cdGxpc3RlbnM6IGZ1bmN0aW9uICh0eXBlLCBwcm9wYWdhdGUpIHtcclxuXHRcdHJldHVybiBMLkZlYXR1cmVHcm91cC5wcm90b3R5cGUubGlzdGVucy5jYWxsKHRoaXMsIHR5cGUsIHByb3BhZ2F0ZSkgfHwgTC5GZWF0dXJlR3JvdXAucHJvdG90eXBlLmxpc3RlbnMuY2FsbCh0aGlzLCAnY2x1c3RlcicgKyB0eXBlLCBwcm9wYWdhdGUpO1xyXG5cdH0sXHJcblxyXG5cdC8vRGVmYXVsdCBmdW5jdGlvbmFsaXR5XHJcblx0X2RlZmF1bHRJY29uQ3JlYXRlRnVuY3Rpb246IGZ1bmN0aW9uIChjbHVzdGVyKSB7XHJcblx0XHR2YXIgY2hpbGRDb3VudCA9IGNsdXN0ZXIuZ2V0Q2hpbGRDb3VudCgpO1xyXG5cclxuXHRcdHZhciBjID0gJyBtYXJrZXItY2x1c3Rlci0nO1xyXG5cdFx0aWYgKGNoaWxkQ291bnQgPCAxMCkge1xyXG5cdFx0XHRjICs9ICdzbWFsbCc7XHJcblx0XHR9IGVsc2UgaWYgKGNoaWxkQ291bnQgPCAxMDApIHtcclxuXHRcdFx0YyArPSAnbWVkaXVtJztcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGMgKz0gJ2xhcmdlJztcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbmV3IEwuRGl2SWNvbih7IGh0bWw6ICc8ZGl2PjxzcGFuPicgKyBjaGlsZENvdW50ICsgJzwvc3Bhbj48L2Rpdj4nLCBjbGFzc05hbWU6ICdtYXJrZXItY2x1c3RlcicgKyBjLCBpY29uU2l6ZTogbmV3IEwuUG9pbnQoNDAsIDQwKSB9KTtcclxuXHR9LFxyXG5cclxuXHRfYmluZEV2ZW50czogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcclxuXHRcdCAgICBzcGlkZXJmeU9uTWF4Wm9vbSA9IHRoaXMub3B0aW9ucy5zcGlkZXJmeU9uTWF4Wm9vbSxcclxuXHRcdCAgICBzaG93Q292ZXJhZ2VPbkhvdmVyID0gdGhpcy5vcHRpb25zLnNob3dDb3ZlcmFnZU9uSG92ZXIsXHJcblx0XHQgICAgem9vbVRvQm91bmRzT25DbGljayA9IHRoaXMub3B0aW9ucy56b29tVG9Cb3VuZHNPbkNsaWNrO1xyXG5cclxuXHRcdC8vWm9vbSBvbiBjbHVzdGVyIGNsaWNrIG9yIHNwaWRlcmZ5IGlmIHdlIGFyZSBhdCB0aGUgbG93ZXN0IGxldmVsXHJcblx0XHRpZiAoc3BpZGVyZnlPbk1heFpvb20gfHwgem9vbVRvQm91bmRzT25DbGljaykge1xyXG5cdFx0XHR0aGlzLm9uKCdjbHVzdGVyY2xpY2snLCB0aGlzLl96b29tT3JTcGlkZXJmeSwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly9TaG93IGNvbnZleCBodWxsIChib3VuZGFyeSkgcG9seWdvbiBvbiBtb3VzZSBvdmVyXHJcblx0XHRpZiAoc2hvd0NvdmVyYWdlT25Ib3Zlcikge1xyXG5cdFx0XHR0aGlzLm9uKCdjbHVzdGVybW91c2VvdmVyJywgdGhpcy5fc2hvd0NvdmVyYWdlLCB0aGlzKTtcclxuXHRcdFx0dGhpcy5vbignY2x1c3Rlcm1vdXNlb3V0JywgdGhpcy5faGlkZUNvdmVyYWdlLCB0aGlzKTtcclxuXHRcdFx0bWFwLm9uKCd6b29tZW5kJywgdGhpcy5faGlkZUNvdmVyYWdlLCB0aGlzKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfem9vbU9yU3BpZGVyZnk6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHR2YXIgY2x1c3RlciA9IGUubGF5ZXIsXHJcblx0XHQgICAgYm90dG9tQ2x1c3RlciA9IGNsdXN0ZXI7XHJcblxyXG5cdFx0d2hpbGUgKGJvdHRvbUNsdXN0ZXIuX2NoaWxkQ2x1c3RlcnMubGVuZ3RoID09PSAxKSB7XHJcblx0XHRcdGJvdHRvbUNsdXN0ZXIgPSBib3R0b21DbHVzdGVyLl9jaGlsZENsdXN0ZXJzWzBdO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChib3R0b21DbHVzdGVyLl96b29tID09PSB0aGlzLl9tYXhab29tICYmXHJcblx0XHRcdGJvdHRvbUNsdXN0ZXIuX2NoaWxkQ291bnQgPT09IGNsdXN0ZXIuX2NoaWxkQ291bnQgJiZcclxuXHRcdFx0dGhpcy5vcHRpb25zLnNwaWRlcmZ5T25NYXhab29tKSB7XHJcblxyXG5cdFx0XHQvLyBBbGwgY2hpbGQgbWFya2VycyBhcmUgY29udGFpbmVkIGluIGEgc2luZ2xlIGNsdXN0ZXIgZnJvbSB0aGlzLl9tYXhab29tIHRvIHRoaXMgY2x1c3Rlci5cclxuXHRcdFx0Y2x1c3Rlci5zcGlkZXJmeSgpO1xyXG5cdFx0fSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuem9vbVRvQm91bmRzT25DbGljaykge1xyXG5cdFx0XHRjbHVzdGVyLnpvb21Ub0JvdW5kcygpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEZvY3VzIHRoZSBtYXAgYWdhaW4gZm9yIGtleWJvYXJkIHVzZXJzLlxyXG5cdFx0aWYgKGUub3JpZ2luYWxFdmVudCAmJiBlLm9yaWdpbmFsRXZlbnQua2V5Q29kZSA9PT0gMTMpIHtcclxuXHRcdFx0dGhpcy5fbWFwLl9jb250YWluZXIuZm9jdXMoKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfc2hvd0NvdmVyYWdlOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcclxuXHRcdGlmICh0aGlzLl9pblpvb21BbmltYXRpb24pIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHRoaXMuX3Nob3duUG9seWdvbikge1xyXG5cdFx0XHRtYXAucmVtb3ZlTGF5ZXIodGhpcy5fc2hvd25Qb2x5Z29uKTtcclxuXHRcdH1cclxuXHRcdGlmIChlLmxheWVyLmdldENoaWxkQ291bnQoKSA+IDIgJiYgZS5sYXllciAhPT0gdGhpcy5fc3BpZGVyZmllZCkge1xyXG5cdFx0XHR0aGlzLl9zaG93blBvbHlnb24gPSBuZXcgTC5Qb2x5Z29uKGUubGF5ZXIuZ2V0Q29udmV4SHVsbCgpLCB0aGlzLm9wdGlvbnMucG9seWdvbk9wdGlvbnMpO1xyXG5cdFx0XHRtYXAuYWRkTGF5ZXIodGhpcy5fc2hvd25Qb2x5Z29uKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfaGlkZUNvdmVyYWdlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fc2hvd25Qb2x5Z29uKSB7XHJcblx0XHRcdHRoaXMuX21hcC5yZW1vdmVMYXllcih0aGlzLl9zaG93blBvbHlnb24pO1xyXG5cdFx0XHR0aGlzLl9zaG93blBvbHlnb24gPSBudWxsO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF91bmJpbmRFdmVudHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBzcGlkZXJmeU9uTWF4Wm9vbSA9IHRoaXMub3B0aW9ucy5zcGlkZXJmeU9uTWF4Wm9vbSxcclxuXHRcdFx0c2hvd0NvdmVyYWdlT25Ib3ZlciA9IHRoaXMub3B0aW9ucy5zaG93Q292ZXJhZ2VPbkhvdmVyLFxyXG5cdFx0XHR6b29tVG9Cb3VuZHNPbkNsaWNrID0gdGhpcy5vcHRpb25zLnpvb21Ub0JvdW5kc09uQ2xpY2ssXHJcblx0XHRcdG1hcCA9IHRoaXMuX21hcDtcclxuXHJcblx0XHRpZiAoc3BpZGVyZnlPbk1heFpvb20gfHwgem9vbVRvQm91bmRzT25DbGljaykge1xyXG5cdFx0XHR0aGlzLm9mZignY2x1c3RlcmNsaWNrJywgdGhpcy5fem9vbU9yU3BpZGVyZnksIHRoaXMpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHNob3dDb3ZlcmFnZU9uSG92ZXIpIHtcclxuXHRcdFx0dGhpcy5vZmYoJ2NsdXN0ZXJtb3VzZW92ZXInLCB0aGlzLl9zaG93Q292ZXJhZ2UsIHRoaXMpO1xyXG5cdFx0XHR0aGlzLm9mZignY2x1c3Rlcm1vdXNlb3V0JywgdGhpcy5faGlkZUNvdmVyYWdlLCB0aGlzKTtcclxuXHRcdFx0bWFwLm9mZignem9vbWVuZCcsIHRoaXMuX2hpZGVDb3ZlcmFnZSwgdGhpcyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3pvb21FbmQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fbWFwKSB7IC8vTWF5IGhhdmUgYmVlbiByZW1vdmVkIGZyb20gdGhlIG1hcCBieSBhIHpvb21FbmQgaGFuZGxlclxyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblx0XHR0aGlzLl9tZXJnZVNwbGl0Q2x1c3RlcnMoKTtcclxuXHJcblx0XHR0aGlzLl96b29tID0gTWF0aC5yb3VuZCh0aGlzLl9tYXAuX3pvb20pO1xyXG5cdFx0dGhpcy5fY3VycmVudFNob3duQm91bmRzID0gdGhpcy5fZ2V0RXhwYW5kZWRWaXNpYmxlQm91bmRzKCk7XHJcblx0fSxcclxuXHJcblx0X21vdmVFbmQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9pblpvb21BbmltYXRpb24pIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBuZXdCb3VuZHMgPSB0aGlzLl9nZXRFeHBhbmRlZFZpc2libGVCb3VuZHMoKTtcclxuXHJcblx0XHR0aGlzLl90b3BDbHVzdGVyTGV2ZWwuX3JlY3Vyc2l2ZWx5UmVtb3ZlQ2hpbGRyZW5Gcm9tTWFwKHRoaXMuX2N1cnJlbnRTaG93bkJvdW5kcywgTWF0aC5mbG9vcih0aGlzLl9tYXAuZ2V0TWluWm9vbSgpKSwgdGhpcy5fem9vbSwgbmV3Qm91bmRzKTtcclxuXHRcdHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5fcmVjdXJzaXZlbHlBZGRDaGlsZHJlblRvTWFwKG51bGwsIE1hdGgucm91bmQodGhpcy5fbWFwLl96b29tKSwgbmV3Qm91bmRzKTtcclxuXHJcblx0XHR0aGlzLl9jdXJyZW50U2hvd25Cb3VuZHMgPSBuZXdCb3VuZHM7XHJcblx0XHRyZXR1cm47XHJcblx0fSxcclxuXHJcblx0X2dlbmVyYXRlSW5pdGlhbENsdXN0ZXJzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgbWF4Wm9vbSA9IE1hdGguY2VpbCh0aGlzLl9tYXAuZ2V0TWF4Wm9vbSgpKSxcclxuXHRcdFx0bWluWm9vbSA9IE1hdGguZmxvb3IodGhpcy5fbWFwLmdldE1pblpvb20oKSksXHJcblx0XHRcdHJhZGl1cyA9IHRoaXMub3B0aW9ucy5tYXhDbHVzdGVyUmFkaXVzLFxyXG5cdFx0XHRyYWRpdXNGbiA9IHJhZGl1cztcclxuXHJcblx0XHQvL0lmIHdlIGp1c3Qgc2V0IG1heENsdXN0ZXJSYWRpdXMgdG8gYSBzaW5nbGUgbnVtYmVyLCB3ZSBuZWVkIHRvIGNyZWF0ZVxyXG5cdFx0Ly9hIHNpbXBsZSBmdW5jdGlvbiB0byByZXR1cm4gdGhhdCBudW1iZXIuIE90aGVyd2lzZSwgd2UganVzdCBoYXZlIHRvXHJcblx0XHQvL3VzZSB0aGUgZnVuY3Rpb24gd2UndmUgcGFzc2VkIGluLlxyXG5cdFx0aWYgKHR5cGVvZiByYWRpdXMgIT09IFwiZnVuY3Rpb25cIikge1xyXG5cdFx0XHRyYWRpdXNGbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJhZGl1czsgfTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmRpc2FibGVDbHVzdGVyaW5nQXRab29tICE9PSBudWxsKSB7XHJcblx0XHRcdG1heFpvb20gPSB0aGlzLm9wdGlvbnMuZGlzYWJsZUNsdXN0ZXJpbmdBdFpvb20gLSAxO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5fbWF4Wm9vbSA9IG1heFpvb207XHJcblx0XHR0aGlzLl9ncmlkQ2x1c3RlcnMgPSB7fTtcclxuXHRcdHRoaXMuX2dyaWRVbmNsdXN0ZXJlZCA9IHt9O1xyXG5cclxuXHRcdC8vU2V0IHVwIERpc3RhbmNlR3JpZHMgZm9yIGVhY2ggem9vbVxyXG5cdFx0Zm9yICh2YXIgem9vbSA9IG1heFpvb207IHpvb20gPj0gbWluWm9vbTsgem9vbS0tKSB7XHJcblx0XHRcdHRoaXMuX2dyaWRDbHVzdGVyc1t6b29tXSA9IG5ldyBMLkRpc3RhbmNlR3JpZChyYWRpdXNGbih6b29tKSk7XHJcblx0XHRcdHRoaXMuX2dyaWRVbmNsdXN0ZXJlZFt6b29tXSA9IG5ldyBMLkRpc3RhbmNlR3JpZChyYWRpdXNGbih6b29tKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gSW5zdGFudGlhdGUgdGhlIGFwcHJvcHJpYXRlIEwuTWFya2VyQ2x1c3RlciBjbGFzcyAoYW5pbWF0ZWQgb3Igbm90KS5cclxuXHRcdHRoaXMuX3RvcENsdXN0ZXJMZXZlbCA9IG5ldyB0aGlzLl9tYXJrZXJDbHVzdGVyKHRoaXMsIG1pblpvb20gLSAxKTtcclxuXHR9LFxyXG5cclxuXHQvL1pvb206IFpvb20gdG8gc3RhcnQgYWRkaW5nIGF0IChQYXNzIHRoaXMuX21heFpvb20gdG8gc3RhcnQgYXQgdGhlIGJvdHRvbSlcclxuXHRfYWRkTGF5ZXI6IGZ1bmN0aW9uIChsYXllciwgem9vbSkge1xyXG5cdFx0dmFyIGdyaWRDbHVzdGVycyA9IHRoaXMuX2dyaWRDbHVzdGVycyxcclxuXHRcdCAgICBncmlkVW5jbHVzdGVyZWQgPSB0aGlzLl9ncmlkVW5jbHVzdGVyZWQsXHJcblx0XHRcdG1pblpvb20gPSBNYXRoLmZsb29yKHRoaXMuX21hcC5nZXRNaW5ab29tKCkpLFxyXG5cdFx0ICAgIG1hcmtlclBvaW50LCB6O1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuc2luZ2xlTWFya2VyTW9kZSkge1xyXG5cdFx0XHR0aGlzLl9vdmVycmlkZU1hcmtlckljb24obGF5ZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxheWVyLm9uKHRoaXMuX2NoaWxkTWFya2VyRXZlbnRIYW5kbGVycywgdGhpcyk7XHJcblxyXG5cdFx0Ly9GaW5kIHRoZSBsb3dlc3Qgem9vbSBsZXZlbCB0byBzbG90IHRoaXMgb25lIGluXHJcblx0XHRmb3IgKDsgem9vbSA+PSBtaW5ab29tOyB6b29tLS0pIHtcclxuXHRcdFx0bWFya2VyUG9pbnQgPSB0aGlzLl9tYXAucHJvamVjdChsYXllci5nZXRMYXRMbmcoKSwgem9vbSk7IC8vIGNhbGN1bGF0ZSBwaXhlbCBwb3NpdGlvblxyXG5cclxuXHRcdFx0Ly9UcnkgZmluZCBhIGNsdXN0ZXIgY2xvc2UgYnlcclxuXHRcdFx0dmFyIGNsb3Nlc3QgPSBncmlkQ2x1c3RlcnNbem9vbV0uZ2V0TmVhck9iamVjdChtYXJrZXJQb2ludCk7XHJcblx0XHRcdGlmIChjbG9zZXN0KSB7XHJcblx0XHRcdFx0Y2xvc2VzdC5fYWRkQ2hpbGQobGF5ZXIpO1xyXG5cdFx0XHRcdGxheWVyLl9fcGFyZW50ID0gY2xvc2VzdDtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vVHJ5IGZpbmQgYSBtYXJrZXIgY2xvc2UgYnkgdG8gZm9ybSBhIG5ldyBjbHVzdGVyIHdpdGhcclxuXHRcdFx0Y2xvc2VzdCA9IGdyaWRVbmNsdXN0ZXJlZFt6b29tXS5nZXROZWFyT2JqZWN0KG1hcmtlclBvaW50KTtcclxuXHRcdFx0aWYgKGNsb3Nlc3QpIHtcclxuXHRcdFx0XHR2YXIgcGFyZW50ID0gY2xvc2VzdC5fX3BhcmVudDtcclxuXHRcdFx0XHRpZiAocGFyZW50KSB7XHJcblx0XHRcdFx0XHR0aGlzLl9yZW1vdmVMYXllcihjbG9zZXN0LCBmYWxzZSk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvL0NyZWF0ZSBuZXcgY2x1c3RlciB3aXRoIHRoZXNlIDIgaW4gaXRcclxuXHJcblx0XHRcdFx0dmFyIG5ld0NsdXN0ZXIgPSBuZXcgdGhpcy5fbWFya2VyQ2x1c3Rlcih0aGlzLCB6b29tLCBjbG9zZXN0LCBsYXllcik7XHJcblx0XHRcdFx0Z3JpZENsdXN0ZXJzW3pvb21dLmFkZE9iamVjdChuZXdDbHVzdGVyLCB0aGlzLl9tYXAucHJvamVjdChuZXdDbHVzdGVyLl9jTGF0TG5nLCB6b29tKSk7XHJcblx0XHRcdFx0Y2xvc2VzdC5fX3BhcmVudCA9IG5ld0NsdXN0ZXI7XHJcblx0XHRcdFx0bGF5ZXIuX19wYXJlbnQgPSBuZXdDbHVzdGVyO1xyXG5cclxuXHRcdFx0XHQvL0ZpcnN0IGNyZWF0ZSBhbnkgbmV3IGludGVybWVkaWF0ZSBwYXJlbnQgY2x1c3RlcnMgdGhhdCBkb24ndCBleGlzdFxyXG5cdFx0XHRcdHZhciBsYXN0UGFyZW50ID0gbmV3Q2x1c3RlcjtcclxuXHRcdFx0XHRmb3IgKHogPSB6b29tIC0gMTsgeiA+IHBhcmVudC5fem9vbTsgei0tKSB7XHJcblx0XHRcdFx0XHRsYXN0UGFyZW50ID0gbmV3IHRoaXMuX21hcmtlckNsdXN0ZXIodGhpcywgeiwgbGFzdFBhcmVudCk7XHJcblx0XHRcdFx0XHRncmlkQ2x1c3RlcnNbel0uYWRkT2JqZWN0KGxhc3RQYXJlbnQsIHRoaXMuX21hcC5wcm9qZWN0KGNsb3Nlc3QuZ2V0TGF0TG5nKCksIHopKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cGFyZW50Ll9hZGRDaGlsZChsYXN0UGFyZW50KTtcclxuXHJcblx0XHRcdFx0Ly9SZW1vdmUgY2xvc2VzdCBmcm9tIHRoaXMgem9vbSBsZXZlbCBhbmQgYW55IGFib3ZlIHRoYXQgaXQgaXMgaW4sIHJlcGxhY2Ugd2l0aCBuZXdDbHVzdGVyXHJcblx0XHRcdFx0dGhpcy5fcmVtb3ZlRnJvbUdyaWRVbmNsdXN0ZXJlZChjbG9zZXN0LCB6b29tKTtcclxuXHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvL0RpZG4ndCBtYW5hZ2UgdG8gY2x1c3RlciBpbiBhdCB0aGlzIHpvb20sIHJlY29yZCB1cyBhcyBhIG1hcmtlciBoZXJlIGFuZCBjb250aW51ZSB1cHdhcmRzXHJcblx0XHRcdGdyaWRVbmNsdXN0ZXJlZFt6b29tXS5hZGRPYmplY3QobGF5ZXIsIG1hcmtlclBvaW50KTtcclxuXHRcdH1cclxuXHJcblx0XHQvL0RpZG4ndCBnZXQgaW4gYW55dGhpbmcsIGFkZCB1cyB0byB0aGUgdG9wXHJcblx0XHR0aGlzLl90b3BDbHVzdGVyTGV2ZWwuX2FkZENoaWxkKGxheWVyKTtcclxuXHRcdGxheWVyLl9fcGFyZW50ID0gdGhpcy5fdG9wQ2x1c3RlckxldmVsO1xyXG5cdFx0cmV0dXJuO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlZnJlc2hlcyB0aGUgaWNvbiBvZiBhbGwgXCJkaXJ0eVwiIHZpc2libGUgY2x1c3RlcnMuXHJcblx0ICogTm9uLXZpc2libGUgXCJkaXJ0eVwiIGNsdXN0ZXJzIHdpbGwgYmUgdXBkYXRlZCB3aGVuIHRoZXkgYXJlIGFkZGVkIHRvIHRoZSBtYXAuXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfcmVmcmVzaENsdXN0ZXJzSWNvbnM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX2ZlYXR1cmVHcm91cC5lYWNoTGF5ZXIoZnVuY3Rpb24gKGMpIHtcclxuXHRcdFx0aWYgKGMgaW5zdGFuY2VvZiBMLk1hcmtlckNsdXN0ZXIgJiYgYy5faWNvbk5lZWRzVXBkYXRlKSB7XHJcblx0XHRcdFx0Yy5fdXBkYXRlSWNvbigpO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHQvL0VucXVldWUgY29kZSB0byBmaXJlIGFmdGVyIHRoZSBtYXJrZXIgZXhwYW5kL2NvbnRyYWN0IGhhcyBoYXBwZW5lZFxyXG5cdF9lbnF1ZXVlOiBmdW5jdGlvbiAoZm4pIHtcclxuXHRcdHRoaXMuX3F1ZXVlLnB1c2goZm4pO1xyXG5cdFx0aWYgKCF0aGlzLl9xdWV1ZVRpbWVvdXQpIHtcclxuXHRcdFx0dGhpcy5fcXVldWVUaW1lb3V0ID0gc2V0VGltZW91dChMLmJpbmQodGhpcy5fcHJvY2Vzc1F1ZXVlLCB0aGlzKSwgMzAwKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cdF9wcm9jZXNzUXVldWU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fcXVldWUubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dGhpcy5fcXVldWVbaV0uY2FsbCh0aGlzKTtcclxuXHRcdH1cclxuXHRcdHRoaXMuX3F1ZXVlLmxlbmd0aCA9IDA7XHJcblx0XHRjbGVhclRpbWVvdXQodGhpcy5fcXVldWVUaW1lb3V0KTtcclxuXHRcdHRoaXMuX3F1ZXVlVGltZW91dCA9IG51bGw7XHJcblx0fSxcclxuXHJcblx0Ly9NZXJnZSBhbmQgc3BsaXQgYW55IGV4aXN0aW5nIGNsdXN0ZXJzIHRoYXQgYXJlIHRvbyBiaWcgb3Igc21hbGxcclxuXHRfbWVyZ2VTcGxpdENsdXN0ZXJzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgbWFwWm9vbSA9IE1hdGgucm91bmQodGhpcy5fbWFwLl96b29tKTtcclxuXHJcblx0XHQvL0luIGNhc2Ugd2UgYXJlIHN0YXJ0aW5nIHRvIHNwbGl0IGJlZm9yZSB0aGUgYW5pbWF0aW9uIGZpbmlzaGVkXHJcblx0XHR0aGlzLl9wcm9jZXNzUXVldWUoKTtcclxuXHJcblx0XHRpZiAodGhpcy5fem9vbSA8IG1hcFpvb20gJiYgdGhpcy5fY3VycmVudFNob3duQm91bmRzLmludGVyc2VjdHModGhpcy5fZ2V0RXhwYW5kZWRWaXNpYmxlQm91bmRzKCkpKSB7IC8vWm9vbSBpbiwgc3BsaXRcclxuXHRcdFx0dGhpcy5fYW5pbWF0aW9uU3RhcnQoKTtcclxuXHRcdFx0Ly9SZW1vdmUgY2x1c3RlcnMgbm93IG9mZiBzY3JlZW5cclxuXHRcdFx0dGhpcy5fdG9wQ2x1c3RlckxldmVsLl9yZWN1cnNpdmVseVJlbW92ZUNoaWxkcmVuRnJvbU1hcCh0aGlzLl9jdXJyZW50U2hvd25Cb3VuZHMsIE1hdGguZmxvb3IodGhpcy5fbWFwLmdldE1pblpvb20oKSksIHRoaXMuX3pvb20sIHRoaXMuX2dldEV4cGFuZGVkVmlzaWJsZUJvdW5kcygpKTtcclxuXHJcblx0XHRcdHRoaXMuX2FuaW1hdGlvblpvb21Jbih0aGlzLl96b29tLCBtYXBab29tKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKHRoaXMuX3pvb20gPiBtYXBab29tKSB7IC8vWm9vbSBvdXQsIG1lcmdlXHJcblx0XHRcdHRoaXMuX2FuaW1hdGlvblN0YXJ0KCk7XHJcblxyXG5cdFx0XHR0aGlzLl9hbmltYXRpb25ab29tT3V0KHRoaXMuX3pvb20sIG1hcFpvb20pO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5fbW92ZUVuZCgpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vR2V0cyB0aGUgbWFwcyB2aXNpYmxlIGJvdW5kcyBleHBhbmRlZCBpbiBlYWNoIGRpcmVjdGlvbiBieSB0aGUgc2l6ZSBvZiB0aGUgc2NyZWVuIChzbyB0aGUgdXNlciBjYW5ub3Qgc2VlIGFuIGFyZWEgd2UgZG8gbm90IGNvdmVyIGluIG9uZSBwYW4pXHJcblx0X2dldEV4cGFuZGVkVmlzaWJsZUJvdW5kczogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMucmVtb3ZlT3V0c2lkZVZpc2libGVCb3VuZHMpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuX21hcEJvdW5kc0luZmluaXRlO1xyXG5cdFx0fSBlbHNlIGlmIChMLkJyb3dzZXIubW9iaWxlKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLl9jaGVja0JvdW5kc01heExhdCh0aGlzLl9tYXAuZ2V0Qm91bmRzKCkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLl9jaGVja0JvdW5kc01heExhdCh0aGlzLl9tYXAuZ2V0Qm91bmRzKCkucGFkKDEpKTsgLy8gUGFkZGluZyBleHBhbmRzIHRoZSBib3VuZHMgYnkgaXRzIG93biBkaW1lbnNpb25zIGJ1dCBzY2FsZWQgd2l0aCB0aGUgZ2l2ZW4gZmFjdG9yLlxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEV4cGFuZHMgdGhlIGxhdGl0dWRlIHRvIEluZmluaXR5IChvciAtSW5maW5pdHkpIGlmIHRoZSBpbnB1dCBib3VuZHMgcmVhY2ggdGhlIG1hcCBwcm9qZWN0aW9uIG1heGltdW0gZGVmaW5lZCBsYXRpdHVkZVxyXG5cdCAqIChpbiB0aGUgY2FzZSBvZiBXZWIvU3BoZXJpY2FsIE1lcmNhdG9yLCBpdCBpcyA4NS4wNTExMjg3Nzk4IC8gc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1dlYl9NZXJjYXRvciNGb3JtdWxhcykuXHJcblx0ICogT3RoZXJ3aXNlLCB0aGUgcmVtb3ZlT3V0c2lkZVZpc2libGVCb3VuZHMgb3B0aW9uIHdpbGwgcmVtb3ZlIG1hcmtlcnMgYmV5b25kIHRoYXQgbGltaXQsIHdoZXJlYXMgdGhlIHNhbWUgbWFya2VycyB3aXRob3V0XHJcblx0ICogdGhpcyBvcHRpb24gKG9yIG91dHNpZGUgTUNHKSB3aWxsIGhhdmUgdGhlaXIgcG9zaXRpb24gZmxvb3JlZCAoY2VpbGVkKSBieSB0aGUgcHJvamVjdGlvbiBhbmQgcmVuZGVyZWQgYXQgdGhhdCBsaW1pdCxcclxuXHQgKiBtYWtpbmcgdGhlIHVzZXIgdGhpbmsgdGhhdCBNQ0cgXCJlYXRzXCIgdGhlbSBhbmQgbmV2ZXIgZGlzcGxheXMgdGhlbSBhZ2Fpbi5cclxuXHQgKiBAcGFyYW0gYm91bmRzIEwuTGF0TG5nQm91bmRzXHJcblx0ICogQHJldHVybnMge0wuTGF0TG5nQm91bmRzfVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X2NoZWNrQm91bmRzTWF4TGF0OiBmdW5jdGlvbiAoYm91bmRzKSB7XHJcblx0XHR2YXIgbWF4TGF0ID0gdGhpcy5fbWF4TGF0O1xyXG5cclxuXHRcdGlmIChtYXhMYXQgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRpZiAoYm91bmRzLmdldE5vcnRoKCkgPj0gbWF4TGF0KSB7XHJcblx0XHRcdFx0Ym91bmRzLl9ub3J0aEVhc3QubGF0ID0gSW5maW5pdHk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKGJvdW5kcy5nZXRTb3V0aCgpIDw9IC1tYXhMYXQpIHtcclxuXHRcdFx0XHRib3VuZHMuX3NvdXRoV2VzdC5sYXQgPSAtSW5maW5pdHk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gYm91bmRzO1xyXG5cdH0sXHJcblxyXG5cdC8vU2hhcmVkIGFuaW1hdGlvbiBjb2RlXHJcblx0X2FuaW1hdGlvbkFkZExheWVyTm9uQW5pbWF0ZWQ6IGZ1bmN0aW9uIChsYXllciwgbmV3Q2x1c3Rlcikge1xyXG5cdFx0aWYgKG5ld0NsdXN0ZXIgPT09IGxheWVyKSB7XHJcblx0XHRcdHRoaXMuX2ZlYXR1cmVHcm91cC5hZGRMYXllcihsYXllcik7XHJcblx0XHR9IGVsc2UgaWYgKG5ld0NsdXN0ZXIuX2NoaWxkQ291bnQgPT09IDIpIHtcclxuXHRcdFx0bmV3Q2x1c3Rlci5fYWRkVG9NYXAoKTtcclxuXHJcblx0XHRcdHZhciBtYXJrZXJzID0gbmV3Q2x1c3Rlci5nZXRBbGxDaGlsZE1hcmtlcnMoKTtcclxuXHRcdFx0dGhpcy5fZmVhdHVyZUdyb3VwLnJlbW92ZUxheWVyKG1hcmtlcnNbMF0pO1xyXG5cdFx0XHR0aGlzLl9mZWF0dXJlR3JvdXAucmVtb3ZlTGF5ZXIobWFya2Vyc1sxXSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRuZXdDbHVzdGVyLl91cGRhdGVJY29uKCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogRXh0cmFjdHMgaW5kaXZpZHVhbCAoaS5lLiBub24tZ3JvdXApIGxheWVycyBmcm9tIGEgTGF5ZXIgR3JvdXAuXHJcblx0ICogQHBhcmFtIGdyb3VwIHRvIGV4dHJhY3QgbGF5ZXJzIGZyb20uXHJcblx0ICogQHBhcmFtIG91dHB1dCB7QXJyYXl9IGluIHdoaWNoIHRvIHN0b3JlIHRoZSBleHRyYWN0ZWQgbGF5ZXJzLlxyXG5cdCAqIEByZXR1cm5zIHsqfEFycmF5fVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X2V4dHJhY3ROb25Hcm91cExheWVyczogZnVuY3Rpb24gKGdyb3VwLCBvdXRwdXQpIHtcclxuXHRcdHZhciBsYXllcnMgPSBncm91cC5nZXRMYXllcnMoKSxcclxuXHRcdCAgICBpID0gMCxcclxuXHRcdCAgICBsYXllcjtcclxuXHJcblx0XHRvdXRwdXQgPSBvdXRwdXQgfHwgW107XHJcblxyXG5cdFx0Zm9yICg7IGkgPCBsYXllcnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0bGF5ZXIgPSBsYXllcnNbaV07XHJcblxyXG5cdFx0XHRpZiAobGF5ZXIgaW5zdGFuY2VvZiBMLkxheWVyR3JvdXApIHtcclxuXHRcdFx0XHR0aGlzLl9leHRyYWN0Tm9uR3JvdXBMYXllcnMobGF5ZXIsIG91dHB1dCk7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdG91dHB1dC5wdXNoKGxheWVyKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gb3V0cHV0O1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEltcGxlbWVudHMgdGhlIHNpbmdsZU1hcmtlck1vZGUgb3B0aW9uLlxyXG5cdCAqIEBwYXJhbSBsYXllciBNYXJrZXIgdG8gcmUtc3R5bGUgdXNpbmcgdGhlIENsdXN0ZXJzIGljb25DcmVhdGVGdW5jdGlvbi5cclxuXHQgKiBAcmV0dXJucyB7TC5JY29ufSBUaGUgbmV3bHkgY3JlYXRlZCBpY29uLlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X292ZXJyaWRlTWFya2VySWNvbjogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHR2YXIgaWNvbiA9IGxheWVyLm9wdGlvbnMuaWNvbiA9IHRoaXMub3B0aW9ucy5pY29uQ3JlYXRlRnVuY3Rpb24oe1xyXG5cdFx0XHRnZXRDaGlsZENvdW50OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdFx0cmV0dXJuIDE7XHJcblx0XHRcdH0sXHJcblx0XHRcdGdldEFsbENoaWxkTWFya2VyczogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRcdHJldHVybiBbbGF5ZXJdO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHJcblx0XHRyZXR1cm4gaWNvbjtcclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQ29uc3RhbnQgYm91bmRzIHVzZWQgaW4gY2FzZSBvcHRpb24gXCJyZW1vdmVPdXRzaWRlVmlzaWJsZUJvdW5kc1wiIGlzIHNldCB0byBmYWxzZS5cclxuTC5NYXJrZXJDbHVzdGVyR3JvdXAuaW5jbHVkZSh7XHJcblx0X21hcEJvdW5kc0luZmluaXRlOiBuZXcgTC5MYXRMbmdCb3VuZHMobmV3IEwuTGF0TG5nKC1JbmZpbml0eSwgLUluZmluaXR5KSwgbmV3IEwuTGF0TG5nKEluZmluaXR5LCBJbmZpbml0eSkpXHJcbn0pO1xyXG5cclxuTC5NYXJrZXJDbHVzdGVyR3JvdXAuaW5jbHVkZSh7XHJcblx0X25vQW5pbWF0aW9uOiB7XHJcblx0XHQvL05vbiBBbmltYXRlZCB2ZXJzaW9ucyBvZiBldmVyeXRoaW5nXHJcblx0XHRfYW5pbWF0aW9uU3RhcnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0Ly9EbyBub3RoaW5nLi4uXHJcblx0XHR9LFxyXG5cdFx0X2FuaW1hdGlvblpvb21JbjogZnVuY3Rpb24gKHByZXZpb3VzWm9vbUxldmVsLCBuZXdab29tTGV2ZWwpIHtcclxuXHRcdFx0dGhpcy5fdG9wQ2x1c3RlckxldmVsLl9yZWN1cnNpdmVseVJlbW92ZUNoaWxkcmVuRnJvbU1hcCh0aGlzLl9jdXJyZW50U2hvd25Cb3VuZHMsIE1hdGguZmxvb3IodGhpcy5fbWFwLmdldE1pblpvb20oKSksIHByZXZpb3VzWm9vbUxldmVsKTtcclxuXHRcdFx0dGhpcy5fdG9wQ2x1c3RlckxldmVsLl9yZWN1cnNpdmVseUFkZENoaWxkcmVuVG9NYXAobnVsbCwgbmV3Wm9vbUxldmVsLCB0aGlzLl9nZXRFeHBhbmRlZFZpc2libGVCb3VuZHMoKSk7XHJcblxyXG5cdFx0XHQvL1dlIGRpZG4ndCBhY3R1YWxseSBhbmltYXRlLCBidXQgd2UgdXNlIHRoaXMgZXZlbnQgdG8gbWVhbiBcImNsdXN0ZXJpbmcgYW5pbWF0aW9ucyBoYXZlIGZpbmlzaGVkXCJcclxuXHRcdFx0dGhpcy5maXJlKCdhbmltYXRpb25lbmQnKTtcclxuXHRcdH0sXHJcblx0XHRfYW5pbWF0aW9uWm9vbU91dDogZnVuY3Rpb24gKHByZXZpb3VzWm9vbUxldmVsLCBuZXdab29tTGV2ZWwpIHtcclxuXHRcdFx0dGhpcy5fdG9wQ2x1c3RlckxldmVsLl9yZWN1cnNpdmVseVJlbW92ZUNoaWxkcmVuRnJvbU1hcCh0aGlzLl9jdXJyZW50U2hvd25Cb3VuZHMsIE1hdGguZmxvb3IodGhpcy5fbWFwLmdldE1pblpvb20oKSksIHByZXZpb3VzWm9vbUxldmVsKTtcclxuXHRcdFx0dGhpcy5fdG9wQ2x1c3RlckxldmVsLl9yZWN1cnNpdmVseUFkZENoaWxkcmVuVG9NYXAobnVsbCwgbmV3Wm9vbUxldmVsLCB0aGlzLl9nZXRFeHBhbmRlZFZpc2libGVCb3VuZHMoKSk7XHJcblxyXG5cdFx0XHQvL1dlIGRpZG4ndCBhY3R1YWxseSBhbmltYXRlLCBidXQgd2UgdXNlIHRoaXMgZXZlbnQgdG8gbWVhbiBcImNsdXN0ZXJpbmcgYW5pbWF0aW9ucyBoYXZlIGZpbmlzaGVkXCJcclxuXHRcdFx0dGhpcy5maXJlKCdhbmltYXRpb25lbmQnKTtcclxuXHRcdH0sXHJcblx0XHRfYW5pbWF0aW9uQWRkTGF5ZXI6IGZ1bmN0aW9uIChsYXllciwgbmV3Q2x1c3Rlcikge1xyXG5cdFx0XHR0aGlzLl9hbmltYXRpb25BZGRMYXllck5vbkFuaW1hdGVkKGxheWVyLCBuZXdDbHVzdGVyKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfd2l0aEFuaW1hdGlvbjoge1xyXG5cdFx0Ly9BbmltYXRlZCB2ZXJzaW9ucyBoZXJlXHJcblx0XHRfYW5pbWF0aW9uU3RhcnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0dGhpcy5fbWFwLl9tYXBQYW5lLmNsYXNzTmFtZSArPSAnIGxlYWZsZXQtY2x1c3Rlci1hbmltJztcclxuXHRcdFx0dGhpcy5faW5ab29tQW5pbWF0aW9uKys7XHJcblx0XHR9LFxyXG5cclxuXHRcdF9hbmltYXRpb25ab29tSW46IGZ1bmN0aW9uIChwcmV2aW91c1pvb21MZXZlbCwgbmV3Wm9vbUxldmVsKSB7XHJcblx0XHRcdHZhciBib3VuZHMgPSB0aGlzLl9nZXRFeHBhbmRlZFZpc2libGVCb3VuZHMoKSxcclxuXHRcdFx0ICAgIGZnID0gdGhpcy5fZmVhdHVyZUdyb3VwLFxyXG5cdFx0XHRcdG1pblpvb20gPSBNYXRoLmZsb29yKHRoaXMuX21hcC5nZXRNaW5ab29tKCkpLFxyXG5cdFx0XHQgICAgaTtcclxuXHJcblx0XHRcdHRoaXMuX2lnbm9yZU1vdmUgPSB0cnVlO1xyXG5cclxuXHRcdFx0Ly9BZGQgYWxsIGNoaWxkcmVuIG9mIGN1cnJlbnQgY2x1c3RlcnMgdG8gbWFwIGFuZCByZW1vdmUgdGhvc2UgY2x1c3RlcnMgZnJvbSBtYXBcclxuXHRcdFx0dGhpcy5fdG9wQ2x1c3RlckxldmVsLl9yZWN1cnNpdmVseShib3VuZHMsIHByZXZpb3VzWm9vbUxldmVsLCBtaW5ab29tLCBmdW5jdGlvbiAoYykge1xyXG5cdFx0XHRcdHZhciBzdGFydFBvcyA9IGMuX2xhdGxuZyxcclxuXHRcdFx0XHQgICAgbWFya2VycyAgPSBjLl9tYXJrZXJzLFxyXG5cdFx0XHRcdCAgICBtO1xyXG5cclxuXHRcdFx0XHRpZiAoIWJvdW5kcy5jb250YWlucyhzdGFydFBvcykpIHtcclxuXHRcdFx0XHRcdHN0YXJ0UG9zID0gbnVsbDtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmIChjLl9pc1NpbmdsZVBhcmVudCgpICYmIHByZXZpb3VzWm9vbUxldmVsICsgMSA9PT0gbmV3Wm9vbUxldmVsKSB7IC8vSW1tZWRpYXRlbHkgYWRkIHRoZSBuZXcgY2hpbGQgYW5kIHJlbW92ZSB1c1xyXG5cdFx0XHRcdFx0ZmcucmVtb3ZlTGF5ZXIoYyk7XHJcblx0XHRcdFx0XHRjLl9yZWN1cnNpdmVseUFkZENoaWxkcmVuVG9NYXAobnVsbCwgbmV3Wm9vbUxldmVsLCBib3VuZHMpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHQvL0ZhZGUgb3V0IG9sZCBjbHVzdGVyXHJcblx0XHRcdFx0XHRjLmNsdXN0ZXJIaWRlKCk7XHJcblx0XHRcdFx0XHRjLl9yZWN1cnNpdmVseUFkZENoaWxkcmVuVG9NYXAoc3RhcnRQb3MsIG5ld1pvb21MZXZlbCwgYm91bmRzKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vUmVtb3ZlIGFsbCBtYXJrZXJzIHRoYXQgYXJlbid0IHZpc2libGUgYW55IG1vcmVcclxuXHRcdFx0XHQvL1RPRE86IERvIHdlIGFjdHVhbGx5IG5lZWQgdG8gZG8gdGhpcyBvbiB0aGUgaGlnaGVyIGxldmVscyB0b28/XHJcblx0XHRcdFx0Zm9yIChpID0gbWFya2Vycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG5cdFx0XHRcdFx0bSA9IG1hcmtlcnNbaV07XHJcblx0XHRcdFx0XHRpZiAoIWJvdW5kcy5jb250YWlucyhtLl9sYXRsbmcpKSB7XHJcblx0XHRcdFx0XHRcdGZnLnJlbW92ZUxheWVyKG0pO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0dGhpcy5fZm9yY2VMYXlvdXQoKTtcclxuXHJcblx0XHRcdC8vVXBkYXRlIG9wYWNpdGllc1xyXG5cdFx0XHR0aGlzLl90b3BDbHVzdGVyTGV2ZWwuX3JlY3Vyc2l2ZWx5QmVjb21lVmlzaWJsZShib3VuZHMsIG5ld1pvb21MZXZlbCk7XHJcblx0XHRcdC8vVE9ETyBNYXliZT8gVXBkYXRlIG1hcmtlcnMgaW4gX3JlY3Vyc2l2ZWx5QmVjb21lVmlzaWJsZVxyXG5cdFx0XHRmZy5lYWNoTGF5ZXIoZnVuY3Rpb24gKG4pIHtcclxuXHRcdFx0XHRpZiAoIShuIGluc3RhbmNlb2YgTC5NYXJrZXJDbHVzdGVyKSAmJiBuLl9pY29uKSB7XHJcblx0XHRcdFx0XHRuLmNsdXN0ZXJTaG93KCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdC8vdXBkYXRlIHRoZSBwb3NpdGlvbnMgb2YgdGhlIGp1c3QgYWRkZWQgY2x1c3RlcnMvbWFya2Vyc1xyXG5cdFx0XHR0aGlzLl90b3BDbHVzdGVyTGV2ZWwuX3JlY3Vyc2l2ZWx5KGJvdW5kcywgcHJldmlvdXNab29tTGV2ZWwsIG5ld1pvb21MZXZlbCwgZnVuY3Rpb24gKGMpIHtcclxuXHRcdFx0XHRjLl9yZWN1cnNpdmVseVJlc3RvcmVDaGlsZFBvc2l0aW9ucyhuZXdab29tTGV2ZWwpO1xyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdHRoaXMuX2lnbm9yZU1vdmUgPSBmYWxzZTtcclxuXHJcblx0XHRcdC8vUmVtb3ZlIHRoZSBvbGQgY2x1c3RlcnMgYW5kIGNsb3NlIHRoZSB6b29tIGFuaW1hdGlvblxyXG5cdFx0XHR0aGlzLl9lbnF1ZXVlKGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0XHQvL3VwZGF0ZSB0aGUgcG9zaXRpb25zIG9mIHRoZSBqdXN0IGFkZGVkIGNsdXN0ZXJzL21hcmtlcnNcclxuXHRcdFx0XHR0aGlzLl90b3BDbHVzdGVyTGV2ZWwuX3JlY3Vyc2l2ZWx5KGJvdW5kcywgcHJldmlvdXNab29tTGV2ZWwsIG1pblpvb20sIGZ1bmN0aW9uIChjKSB7XHJcblx0XHRcdFx0XHRmZy5yZW1vdmVMYXllcihjKTtcclxuXHRcdFx0XHRcdGMuY2x1c3RlclNob3coKTtcclxuXHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdFx0dGhpcy5fYW5pbWF0aW9uRW5kKCk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fSxcclxuXHJcblx0XHRfYW5pbWF0aW9uWm9vbU91dDogZnVuY3Rpb24gKHByZXZpb3VzWm9vbUxldmVsLCBuZXdab29tTGV2ZWwpIHtcclxuXHRcdFx0dGhpcy5fYW5pbWF0aW9uWm9vbU91dFNpbmdsZSh0aGlzLl90b3BDbHVzdGVyTGV2ZWwsIHByZXZpb3VzWm9vbUxldmVsIC0gMSwgbmV3Wm9vbUxldmVsKTtcclxuXHJcblx0XHRcdC8vTmVlZCB0byBhZGQgbWFya2VycyBmb3IgdGhvc2UgdGhhdCB3ZXJlbid0IG9uIHRoZSBtYXAgYmVmb3JlIGJ1dCBhcmUgbm93XHJcblx0XHRcdHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5fcmVjdXJzaXZlbHlBZGRDaGlsZHJlblRvTWFwKG51bGwsIG5ld1pvb21MZXZlbCwgdGhpcy5fZ2V0RXhwYW5kZWRWaXNpYmxlQm91bmRzKCkpO1xyXG5cdFx0XHQvL1JlbW92ZSBtYXJrZXJzIHRoYXQgd2VyZSBvbiB0aGUgbWFwIGJlZm9yZSBidXQgd29uJ3QgYmUgbm93XHJcblx0XHRcdHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5fcmVjdXJzaXZlbHlSZW1vdmVDaGlsZHJlbkZyb21NYXAodGhpcy5fY3VycmVudFNob3duQm91bmRzLCBNYXRoLmZsb29yKHRoaXMuX21hcC5nZXRNaW5ab29tKCkpLCBwcmV2aW91c1pvb21MZXZlbCwgdGhpcy5fZ2V0RXhwYW5kZWRWaXNpYmxlQm91bmRzKCkpO1xyXG5cdFx0fSxcclxuXHJcblx0XHRfYW5pbWF0aW9uQWRkTGF5ZXI6IGZ1bmN0aW9uIChsYXllciwgbmV3Q2x1c3Rlcikge1xyXG5cdFx0XHR2YXIgbWUgPSB0aGlzLFxyXG5cdFx0XHQgICAgZmcgPSB0aGlzLl9mZWF0dXJlR3JvdXA7XHJcblxyXG5cdFx0XHRmZy5hZGRMYXllcihsYXllcik7XHJcblx0XHRcdGlmIChuZXdDbHVzdGVyICE9PSBsYXllcikge1xyXG5cdFx0XHRcdGlmIChuZXdDbHVzdGVyLl9jaGlsZENvdW50ID4gMikgeyAvL1dhcyBhbHJlYWR5IGEgY2x1c3RlclxyXG5cclxuXHRcdFx0XHRcdG5ld0NsdXN0ZXIuX3VwZGF0ZUljb24oKTtcclxuXHRcdFx0XHRcdHRoaXMuX2ZvcmNlTGF5b3V0KCk7XHJcblx0XHRcdFx0XHR0aGlzLl9hbmltYXRpb25TdGFydCgpO1xyXG5cclxuXHRcdFx0XHRcdGxheWVyLl9zZXRQb3ModGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludChuZXdDbHVzdGVyLmdldExhdExuZygpKSk7XHJcblx0XHRcdFx0XHRsYXllci5jbHVzdGVySGlkZSgpO1xyXG5cclxuXHRcdFx0XHRcdHRoaXMuX2VucXVldWUoZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRcdFx0XHRmZy5yZW1vdmVMYXllcihsYXllcik7XHJcblx0XHRcdFx0XHRcdGxheWVyLmNsdXN0ZXJTaG93KCk7XHJcblxyXG5cdFx0XHRcdFx0XHRtZS5fYW5pbWF0aW9uRW5kKCk7XHJcblx0XHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHsgLy9KdXN0IGJlY2FtZSBhIGNsdXN0ZXJcclxuXHRcdFx0XHRcdHRoaXMuX2ZvcmNlTGF5b3V0KCk7XHJcblxyXG5cdFx0XHRcdFx0bWUuX2FuaW1hdGlvblN0YXJ0KCk7XHJcblx0XHRcdFx0XHRtZS5fYW5pbWF0aW9uWm9vbU91dFNpbmdsZShuZXdDbHVzdGVyLCB0aGlzLl9tYXAuZ2V0TWF4Wm9vbSgpLCB0aGlzLl96b29tKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBQcml2YXRlIG1ldGhvZHMgZm9yIGFuaW1hdGVkIHZlcnNpb25zLlxyXG5cdF9hbmltYXRpb25ab29tT3V0U2luZ2xlOiBmdW5jdGlvbiAoY2x1c3RlciwgcHJldmlvdXNab29tTGV2ZWwsIG5ld1pvb21MZXZlbCkge1xyXG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuX2dldEV4cGFuZGVkVmlzaWJsZUJvdW5kcygpLFxyXG5cdFx0XHRtaW5ab29tID0gTWF0aC5mbG9vcih0aGlzLl9tYXAuZ2V0TWluWm9vbSgpKTtcclxuXHJcblx0XHQvL0FuaW1hdGUgYWxsIG9mIHRoZSBtYXJrZXJzIGluIHRoZSBjbHVzdGVycyB0byBtb3ZlIHRvIHRoZWlyIGNsdXN0ZXIgY2VudGVyIHBvaW50XHJcblx0XHRjbHVzdGVyLl9yZWN1cnNpdmVseUFuaW1hdGVDaGlsZHJlbkluQW5kQWRkU2VsZlRvTWFwKGJvdW5kcywgbWluWm9vbSwgcHJldmlvdXNab29tTGV2ZWwgKyAxLCBuZXdab29tTGV2ZWwpO1xyXG5cclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblxyXG5cdFx0Ly9VcGRhdGUgdGhlIG9wYWNpdHkgKElmIHdlIGltbWVkaWF0ZWx5IHNldCBpdCB0aGV5IHdvbid0IGFuaW1hdGUpXHJcblx0XHR0aGlzLl9mb3JjZUxheW91dCgpO1xyXG5cdFx0Y2x1c3Rlci5fcmVjdXJzaXZlbHlCZWNvbWVWaXNpYmxlKGJvdW5kcywgbmV3Wm9vbUxldmVsKTtcclxuXHJcblx0XHQvL1RPRE86IE1heWJlIHVzZSB0aGUgdHJhbnNpdGlvbiB0aW1pbmcgc3R1ZmYgdG8gbWFrZSB0aGlzIG1vcmUgcmVsaWFibGVcclxuXHRcdC8vV2hlbiB0aGUgYW5pbWF0aW9ucyBhcmUgZG9uZSwgdGlkeSB1cFxyXG5cdFx0dGhpcy5fZW5xdWV1ZShmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHQvL1RoaXMgY2x1c3RlciBzdG9wcGVkIGJlaW5nIGEgY2x1c3RlciBiZWZvcmUgdGhlIHRpbWVvdXQgZmlyZWRcclxuXHRcdFx0aWYgKGNsdXN0ZXIuX2NoaWxkQ291bnQgPT09IDEpIHtcclxuXHRcdFx0XHR2YXIgbSA9IGNsdXN0ZXIuX21hcmtlcnNbMF07XHJcblx0XHRcdFx0Ly9JZiB3ZSB3ZXJlIGluIGEgY2x1c3RlciBhbmltYXRpb24gYXQgdGhlIHRpbWUgdGhlbiB0aGUgb3BhY2l0eSBhbmQgcG9zaXRpb24gb2Ygb3VyIGNoaWxkIGNvdWxkIGJlIHdyb25nIG5vdywgc28gZml4IGl0XHJcblx0XHRcdFx0dGhpcy5faWdub3JlTW92ZSA9IHRydWU7XHJcblx0XHRcdFx0bS5zZXRMYXRMbmcobS5nZXRMYXRMbmcoKSk7XHJcblx0XHRcdFx0dGhpcy5faWdub3JlTW92ZSA9IGZhbHNlO1xyXG5cdFx0XHRcdGlmIChtLmNsdXN0ZXJTaG93KSB7XHJcblx0XHRcdFx0XHRtLmNsdXN0ZXJTaG93KCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGNsdXN0ZXIuX3JlY3Vyc2l2ZWx5KGJvdW5kcywgbmV3Wm9vbUxldmVsLCBtaW5ab29tLCBmdW5jdGlvbiAoYykge1xyXG5cdFx0XHRcdFx0Yy5fcmVjdXJzaXZlbHlSZW1vdmVDaGlsZHJlbkZyb21NYXAoYm91bmRzLCBtaW5ab29tLCBwcmV2aW91c1pvb21MZXZlbCArIDEpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9XHJcblx0XHRcdG1lLl9hbmltYXRpb25FbmQoKTtcclxuXHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdF9hbmltYXRpb25FbmQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5fbWFwLl9tYXBQYW5lLmNsYXNzTmFtZSA9IHRoaXMuX21hcC5fbWFwUGFuZS5jbGFzc05hbWUucmVwbGFjZSgnIGxlYWZsZXQtY2x1c3Rlci1hbmltJywgJycpO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5faW5ab29tQW5pbWF0aW9uLS07XHJcblx0XHR0aGlzLmZpcmUoJ2FuaW1hdGlvbmVuZCcpO1xyXG5cdH0sXHJcblxyXG5cdC8vRm9yY2UgYSBicm93c2VyIGxheW91dCBvZiBzdHVmZiBpbiB0aGUgbWFwXHJcblx0Ly8gU2hvdWxkIGFwcGx5IHRoZSBjdXJyZW50IG9wYWNpdHkgYW5kIGxvY2F0aW9uIHRvIGFsbCBlbGVtZW50cyBzbyB3ZSBjYW4gdXBkYXRlIHRoZW0gYWdhaW4gZm9yIGFuIGFuaW1hdGlvblxyXG5cdF9mb3JjZUxheW91dDogZnVuY3Rpb24gKCkge1xyXG5cdFx0Ly9JbiBteSB0ZXN0aW5nIHRoaXMgd29ya3MsIGluZmFjdCBvZmZzZXRXaWR0aCBvZiBhbnkgZWxlbWVudCBzZWVtcyB0byB3b3JrLlxyXG5cdFx0Ly9Db3VsZCBsb29wIGFsbCB0aGlzLl9sYXllcnMgYW5kIGRvIHRoaXMgZm9yIGVhY2ggX2ljb24gaWYgaXQgc3RvcHMgd29ya2luZ1xyXG5cclxuXHRcdEwuVXRpbC5mYWxzZUZuKGRvY3VtZW50LmJvZHkub2Zmc2V0V2lkdGgpO1xyXG5cdH1cclxufSk7XHJcblxyXG5MLm1hcmtlckNsdXN0ZXJHcm91cCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBMLk1hcmtlckNsdXN0ZXJHcm91cChvcHRpb25zKTtcclxufTtcblxudmFyIE1hcmtlckNsdXN0ZXIgPSBMLk1hcmtlckNsdXN0ZXIgPSBMLk1hcmtlci5leHRlbmQoe1xyXG5cdG9wdGlvbnM6IEwuSWNvbi5wcm90b3R5cGUub3B0aW9ucyxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGdyb3VwLCB6b29tLCBhLCBiKSB7XHJcblxyXG5cdFx0TC5NYXJrZXIucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCBhID8gKGEuX2NMYXRMbmcgfHwgYS5nZXRMYXRMbmcoKSkgOiBuZXcgTC5MYXRMbmcoMCwgMCksXHJcbiAgICAgICAgICAgIHsgaWNvbjogdGhpcywgcGFuZTogZ3JvdXAub3B0aW9ucy5jbHVzdGVyUGFuZSB9KTtcclxuXHJcblx0XHR0aGlzLl9ncm91cCA9IGdyb3VwO1xyXG5cdFx0dGhpcy5fem9vbSA9IHpvb207XHJcblxyXG5cdFx0dGhpcy5fbWFya2VycyA9IFtdO1xyXG5cdFx0dGhpcy5fY2hpbGRDbHVzdGVycyA9IFtdO1xyXG5cdFx0dGhpcy5fY2hpbGRDb3VudCA9IDA7XHJcblx0XHR0aGlzLl9pY29uTmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cdFx0dGhpcy5fYm91bmRzTmVlZFVwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy5fYm91bmRzID0gbmV3IEwuTGF0TG5nQm91bmRzKCk7XHJcblxyXG5cdFx0aWYgKGEpIHtcclxuXHRcdFx0dGhpcy5fYWRkQ2hpbGQoYSk7XHJcblx0XHR9XHJcblx0XHRpZiAoYikge1xyXG5cdFx0XHR0aGlzLl9hZGRDaGlsZChiKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvL1JlY3Vyc2l2ZWx5IHJldHJpZXZlIGFsbCBjaGlsZCBtYXJrZXJzIG9mIHRoaXMgY2x1c3RlclxyXG5cdGdldEFsbENoaWxkTWFya2VyczogZnVuY3Rpb24gKHN0b3JhZ2VBcnJheSwgaWdub3JlRHJhZ2dlZE1hcmtlcikge1xyXG5cdFx0c3RvcmFnZUFycmF5ID0gc3RvcmFnZUFycmF5IHx8IFtdO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSB0aGlzLl9jaGlsZENsdXN0ZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdHRoaXMuX2NoaWxkQ2x1c3RlcnNbaV0uZ2V0QWxsQ2hpbGRNYXJrZXJzKHN0b3JhZ2VBcnJheSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICh2YXIgaiA9IHRoaXMuX21hcmtlcnMubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcclxuXHRcdFx0aWYgKGlnbm9yZURyYWdnZWRNYXJrZXIgJiYgdGhpcy5fbWFya2Vyc1tqXS5fX2RyYWdTdGFydCkge1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblx0XHRcdHN0b3JhZ2VBcnJheS5wdXNoKHRoaXMuX21hcmtlcnNbal0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBzdG9yYWdlQXJyYXk7XHJcblx0fSxcclxuXHJcblx0Ly9SZXR1cm5zIHRoZSBjb3VudCBvZiBob3cgbWFueSBjaGlsZCBtYXJrZXJzIHdlIGhhdmVcclxuXHRnZXRDaGlsZENvdW50OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fY2hpbGRDb3VudDtcclxuXHR9LFxyXG5cclxuXHQvL1pvb20gdG8gdGhlIG1pbmltdW0gb2Ygc2hvd2luZyBhbGwgb2YgdGhlIGNoaWxkIG1hcmtlcnMsIG9yIHRoZSBleHRlbnRzIG9mIHRoaXMgY2x1c3RlclxyXG5cdHpvb21Ub0JvdW5kczogZnVuY3Rpb24gKGZpdEJvdW5kc09wdGlvbnMpIHtcclxuXHRcdHZhciBjaGlsZENsdXN0ZXJzID0gdGhpcy5fY2hpbGRDbHVzdGVycy5zbGljZSgpLFxyXG5cdFx0XHRtYXAgPSB0aGlzLl9ncm91cC5fbWFwLFxyXG5cdFx0XHRib3VuZHNab29tID0gbWFwLmdldEJvdW5kc1pvb20odGhpcy5fYm91bmRzKSxcclxuXHRcdFx0em9vbSA9IHRoaXMuX3pvb20gKyAxLFxyXG5cdFx0XHRtYXBab29tID0gbWFwLmdldFpvb20oKSxcclxuXHRcdFx0aTtcclxuXHJcblx0XHQvL2NhbGN1bGF0ZSBob3cgZmFyIHdlIG5lZWQgdG8gem9vbSBkb3duIHRvIHNlZSBhbGwgb2YgdGhlIG1hcmtlcnNcclxuXHRcdHdoaWxlIChjaGlsZENsdXN0ZXJzLmxlbmd0aCA+IDAgJiYgYm91bmRzWm9vbSA+IHpvb20pIHtcclxuXHRcdFx0em9vbSsrO1xyXG5cdFx0XHR2YXIgbmV3Q2x1c3RlcnMgPSBbXTtcclxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGNoaWxkQ2x1c3RlcnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRuZXdDbHVzdGVycyA9IG5ld0NsdXN0ZXJzLmNvbmNhdChjaGlsZENsdXN0ZXJzW2ldLl9jaGlsZENsdXN0ZXJzKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRjaGlsZENsdXN0ZXJzID0gbmV3Q2x1c3RlcnM7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGJvdW5kc1pvb20gPiB6b29tKSB7XHJcblx0XHRcdHRoaXMuX2dyb3VwLl9tYXAuc2V0Vmlldyh0aGlzLl9sYXRsbmcsIHpvb20pO1xyXG5cdFx0fSBlbHNlIGlmIChib3VuZHNab29tIDw9IG1hcFpvb20pIHsgLy9JZiBmaXRCb3VuZHMgd291bGRuJ3Qgem9vbSB1cyBkb3duLCB6b29tIHVzIGRvd24gaW5zdGVhZFxyXG5cdFx0XHR0aGlzLl9ncm91cC5fbWFwLnNldFZpZXcodGhpcy5fbGF0bG5nLCBtYXBab29tICsgMSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLl9ncm91cC5fbWFwLmZpdEJvdW5kcyh0aGlzLl9ib3VuZHMsIGZpdEJvdW5kc09wdGlvbnMpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdGdldEJvdW5kczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGJvdW5kcyA9IG5ldyBMLkxhdExuZ0JvdW5kcygpO1xyXG5cdFx0Ym91bmRzLmV4dGVuZCh0aGlzLl9ib3VuZHMpO1xyXG5cdFx0cmV0dXJuIGJvdW5kcztcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlSWNvbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5faWNvbk5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHRcdGlmICh0aGlzLl9pY29uKSB7XHJcblx0XHRcdHRoaXMuc2V0SWNvbih0aGlzKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvL0NsdWRnZSBmb3IgSWNvbiwgd2UgcHJldGVuZCB0byBiZSBhbiBpY29uIGZvciBwZXJmb3JtYW5jZVxyXG5cdGNyZWF0ZUljb246IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9pY29uTmVlZHNVcGRhdGUpIHtcclxuXHRcdFx0dGhpcy5faWNvbk9iaiA9IHRoaXMuX2dyb3VwLm9wdGlvbnMuaWNvbkNyZWF0ZUZ1bmN0aW9uKHRoaXMpO1xyXG5cdFx0XHR0aGlzLl9pY29uTmVlZHNVcGRhdGUgPSBmYWxzZTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzLl9pY29uT2JqLmNyZWF0ZUljb24oKTtcclxuXHR9LFxyXG5cdGNyZWF0ZVNoYWRvdzogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2ljb25PYmouY3JlYXRlU2hhZG93KCk7XHJcblx0fSxcclxuXHJcblxyXG5cdF9hZGRDaGlsZDogZnVuY3Rpb24gKG5ldzEsIGlzTm90aWZpY2F0aW9uRnJvbUNoaWxkKSB7XHJcblxyXG5cdFx0dGhpcy5faWNvbk5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLl9ib3VuZHNOZWVkVXBkYXRlID0gdHJ1ZTtcclxuXHRcdHRoaXMuX3NldENsdXN0ZXJDZW50ZXIobmV3MSk7XHJcblxyXG5cdFx0aWYgKG5ldzEgaW5zdGFuY2VvZiBMLk1hcmtlckNsdXN0ZXIpIHtcclxuXHRcdFx0aWYgKCFpc05vdGlmaWNhdGlvbkZyb21DaGlsZCkge1xyXG5cdFx0XHRcdHRoaXMuX2NoaWxkQ2x1c3RlcnMucHVzaChuZXcxKTtcclxuXHRcdFx0XHRuZXcxLl9fcGFyZW50ID0gdGhpcztcclxuXHRcdFx0fVxyXG5cdFx0XHR0aGlzLl9jaGlsZENvdW50ICs9IG5ldzEuX2NoaWxkQ291bnQ7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRpZiAoIWlzTm90aWZpY2F0aW9uRnJvbUNoaWxkKSB7XHJcblx0XHRcdFx0dGhpcy5fbWFya2Vycy5wdXNoKG5ldzEpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMuX2NoaWxkQ291bnQrKztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5fX3BhcmVudCkge1xyXG5cdFx0XHR0aGlzLl9fcGFyZW50Ll9hZGRDaGlsZChuZXcxLCB0cnVlKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBNYWtlcyBzdXJlIHRoZSBjbHVzdGVyIGNlbnRlciBpcyBzZXQuIElmIG5vdCwgdXNlcyB0aGUgY2hpbGQgY2VudGVyIGlmIGl0IGlzIGEgY2x1c3Rlciwgb3IgdGhlIG1hcmtlciBwb3NpdGlvbi5cclxuXHQgKiBAcGFyYW0gY2hpbGQgTC5NYXJrZXJDbHVzdGVyfEwuTWFya2VyIHRoYXQgd2lsbCBiZSB1c2VkIGFzIGNsdXN0ZXIgY2VudGVyIGlmIG5vdCBkZWZpbmVkIHlldC5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9zZXRDbHVzdGVyQ2VudGVyOiBmdW5jdGlvbiAoY2hpbGQpIHtcclxuXHRcdGlmICghdGhpcy5fY0xhdExuZykge1xyXG5cdFx0XHQvLyB3aGVuIGNsdXN0ZXJpbmcsIHRha2UgcG9zaXRpb24gb2YgdGhlIGZpcnN0IHBvaW50IGFzIHRoZSBjbHVzdGVyIGNlbnRlclxyXG5cdFx0XHR0aGlzLl9jTGF0TG5nID0gY2hpbGQuX2NMYXRMbmcgfHwgY2hpbGQuX2xhdGxuZztcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBBc3NpZ25zIGltcG9zc2libGUgYm91bmRpbmcgdmFsdWVzIHNvIHRoYXQgdGhlIG5leHQgZXh0ZW5kIGVudGlyZWx5IGRldGVybWluZXMgdGhlIG5ldyBib3VuZHMuXHJcblx0ICogVGhpcyBtZXRob2QgYXZvaWRzIGhhdmluZyB0byB0cmFzaCB0aGUgcHJldmlvdXMgTC5MYXRMbmdCb3VuZHMgb2JqZWN0IGFuZCB0byBjcmVhdGUgYSBuZXcgb25lLCB3aGljaCBpcyBtdWNoIHNsb3dlciBmb3IgdGhpcyBjbGFzcy5cclxuXHQgKiBBcyBsb25nIGFzIHRoZSBib3VuZHMgYXJlIG5vdCBleHRlbmRlZCwgbW9zdCBvdGhlciBtZXRob2RzIHdvdWxkIHByb2JhYmx5IGZhaWwsIGFzIHRoZXkgd291bGQgd2l0aCBib3VuZHMgaW5pdGlhbGl6ZWQgYnV0IG5vdCBleHRlbmRlZC5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9yZXNldEJvdW5kczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuX2JvdW5kcztcclxuXHJcblx0XHRpZiAoYm91bmRzLl9zb3V0aFdlc3QpIHtcclxuXHRcdFx0Ym91bmRzLl9zb3V0aFdlc3QubGF0ID0gSW5maW5pdHk7XHJcblx0XHRcdGJvdW5kcy5fc291dGhXZXN0LmxuZyA9IEluZmluaXR5O1xyXG5cdFx0fVxyXG5cdFx0aWYgKGJvdW5kcy5fbm9ydGhFYXN0KSB7XHJcblx0XHRcdGJvdW5kcy5fbm9ydGhFYXN0LmxhdCA9IC1JbmZpbml0eTtcclxuXHRcdFx0Ym91bmRzLl9ub3J0aEVhc3QubG5nID0gLUluZmluaXR5O1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9yZWNhbGN1bGF0ZUJvdW5kczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIG1hcmtlcnMgPSB0aGlzLl9tYXJrZXJzLFxyXG5cdFx0ICAgIGNoaWxkQ2x1c3RlcnMgPSB0aGlzLl9jaGlsZENsdXN0ZXJzLFxyXG5cdFx0ICAgIGxhdFN1bSA9IDAsXHJcblx0XHQgICAgbG5nU3VtID0gMCxcclxuXHRcdCAgICB0b3RhbENvdW50ID0gdGhpcy5fY2hpbGRDb3VudCxcclxuXHRcdCAgICBpLCBjaGlsZCwgY2hpbGRMYXRMbmcsIGNoaWxkQ291bnQ7XHJcblxyXG5cdFx0Ly8gQ2FzZSB3aGVyZSBhbGwgbWFya2VycyBhcmUgcmVtb3ZlZCBmcm9tIHRoZSBtYXAgYW5kIHdlIGFyZSBsZWZ0IHdpdGgganVzdCBhbiBlbXB0eSBfdG9wQ2x1c3RlckxldmVsLlxyXG5cdFx0aWYgKHRvdGFsQ291bnQgPT09IDApIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFJlc2V0IHJhdGhlciB0aGFuIGNyZWF0aW5nIGEgbmV3IG9iamVjdCwgZm9yIHBlcmZvcm1hbmNlLlxyXG5cdFx0dGhpcy5fcmVzZXRCb3VuZHMoKTtcclxuXHJcblx0XHQvLyBDaGlsZCBtYXJrZXJzLlxyXG5cdFx0Zm9yIChpID0gMDsgaSA8IG1hcmtlcnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0Y2hpbGRMYXRMbmcgPSBtYXJrZXJzW2ldLl9sYXRsbmc7XHJcblxyXG5cdFx0XHR0aGlzLl9ib3VuZHMuZXh0ZW5kKGNoaWxkTGF0TG5nKTtcclxuXHJcblx0XHRcdGxhdFN1bSArPSBjaGlsZExhdExuZy5sYXQ7XHJcblx0XHRcdGxuZ1N1bSArPSBjaGlsZExhdExuZy5sbmc7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQ2hpbGQgY2x1c3RlcnMuXHJcblx0XHRmb3IgKGkgPSAwOyBpIDwgY2hpbGRDbHVzdGVycy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRjaGlsZCA9IGNoaWxkQ2x1c3RlcnNbaV07XHJcblxyXG5cdFx0XHQvLyBSZS1jb21wdXRlIGNoaWxkIGJvdW5kcyBhbmQgd2VpZ2h0ZWQgcG9zaXRpb24gZmlyc3QgaWYgbmVjZXNzYXJ5LlxyXG5cdFx0XHRpZiAoY2hpbGQuX2JvdW5kc05lZWRVcGRhdGUpIHtcclxuXHRcdFx0XHRjaGlsZC5fcmVjYWxjdWxhdGVCb3VuZHMoKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5fYm91bmRzLmV4dGVuZChjaGlsZC5fYm91bmRzKTtcclxuXHJcblx0XHRcdGNoaWxkTGF0TG5nID0gY2hpbGQuX3dMYXRMbmc7XHJcblx0XHRcdGNoaWxkQ291bnQgPSBjaGlsZC5fY2hpbGRDb3VudDtcclxuXHJcblx0XHRcdGxhdFN1bSArPSBjaGlsZExhdExuZy5sYXQgKiBjaGlsZENvdW50O1xyXG5cdFx0XHRsbmdTdW0gKz0gY2hpbGRMYXRMbmcubG5nICogY2hpbGRDb3VudDtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9sYXRsbmcgPSB0aGlzLl93TGF0TG5nID0gbmV3IEwuTGF0TG5nKGxhdFN1bSAvIHRvdGFsQ291bnQsIGxuZ1N1bSAvIHRvdGFsQ291bnQpO1xyXG5cclxuXHRcdC8vIFJlc2V0IGRpcnR5IGZsYWcuXHJcblx0XHR0aGlzLl9ib3VuZHNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblx0fSxcclxuXHJcblx0Ly9TZXQgb3VyIG1hcmtlcnMgcG9zaXRpb24gYXMgZ2l2ZW4gYW5kIGFkZCBpdCB0byB0aGUgbWFwXHJcblx0X2FkZFRvTWFwOiBmdW5jdGlvbiAoc3RhcnRQb3MpIHtcclxuXHRcdGlmIChzdGFydFBvcykge1xyXG5cdFx0XHR0aGlzLl9iYWNrdXBMYXRsbmcgPSB0aGlzLl9sYXRsbmc7XHJcblx0XHRcdHRoaXMuc2V0TGF0TG5nKHN0YXJ0UG9zKTtcclxuXHRcdH1cclxuXHRcdHRoaXMuX2dyb3VwLl9mZWF0dXJlR3JvdXAuYWRkTGF5ZXIodGhpcyk7XHJcblx0fSxcclxuXHJcblx0X3JlY3Vyc2l2ZWx5QW5pbWF0ZUNoaWxkcmVuSW46IGZ1bmN0aW9uIChib3VuZHMsIGNlbnRlciwgbWF4Wm9vbSkge1xyXG5cdFx0dGhpcy5fcmVjdXJzaXZlbHkoYm91bmRzLCB0aGlzLl9ncm91cC5fbWFwLmdldE1pblpvb20oKSwgbWF4Wm9vbSAtIDEsXHJcblx0XHRcdGZ1bmN0aW9uIChjKSB7XHJcblx0XHRcdFx0dmFyIG1hcmtlcnMgPSBjLl9tYXJrZXJzLFxyXG5cdFx0XHRcdFx0aSwgbTtcclxuXHRcdFx0XHRmb3IgKGkgPSBtYXJrZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdFx0XHRtID0gbWFya2Vyc1tpXTtcclxuXHJcblx0XHRcdFx0XHQvL09ubHkgZG8gaXQgaWYgdGhlIGljb24gaXMgc3RpbGwgb24gdGhlIG1hcFxyXG5cdFx0XHRcdFx0aWYgKG0uX2ljb24pIHtcclxuXHRcdFx0XHRcdFx0bS5fc2V0UG9zKGNlbnRlcik7XHJcblx0XHRcdFx0XHRcdG0uY2x1c3RlckhpZGUoKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH0sXHJcblx0XHRcdGZ1bmN0aW9uIChjKSB7XHJcblx0XHRcdFx0dmFyIGNoaWxkQ2x1c3RlcnMgPSBjLl9jaGlsZENsdXN0ZXJzLFxyXG5cdFx0XHRcdFx0aiwgY207XHJcblx0XHRcdFx0Zm9yIChqID0gY2hpbGRDbHVzdGVycy5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xyXG5cdFx0XHRcdFx0Y20gPSBjaGlsZENsdXN0ZXJzW2pdO1xyXG5cdFx0XHRcdFx0aWYgKGNtLl9pY29uKSB7XHJcblx0XHRcdFx0XHRcdGNtLl9zZXRQb3MoY2VudGVyKTtcclxuXHRcdFx0XHRcdFx0Y20uY2x1c3RlckhpZGUoKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdCk7XHJcblx0fSxcclxuXHJcblx0X3JlY3Vyc2l2ZWx5QW5pbWF0ZUNoaWxkcmVuSW5BbmRBZGRTZWxmVG9NYXA6IGZ1bmN0aW9uIChib3VuZHMsIG1hcE1pblpvb20sIHByZXZpb3VzWm9vbUxldmVsLCBuZXdab29tTGV2ZWwpIHtcclxuXHRcdHRoaXMuX3JlY3Vyc2l2ZWx5KGJvdW5kcywgbmV3Wm9vbUxldmVsLCBtYXBNaW5ab29tLFxyXG5cdFx0XHRmdW5jdGlvbiAoYykge1xyXG5cdFx0XHRcdGMuX3JlY3Vyc2l2ZWx5QW5pbWF0ZUNoaWxkcmVuSW4oYm91bmRzLCBjLl9ncm91cC5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludChjLmdldExhdExuZygpKS5yb3VuZCgpLCBwcmV2aW91c1pvb21MZXZlbCk7XHJcblxyXG5cdFx0XHRcdC8vVE9ETzogZGVwdGhUb0FuaW1hdGVJbiBhZmZlY3RzIF9pc1NpbmdsZVBhcmVudCwgaWYgdGhlcmUgaXMgYSBtdWx0aXpvb20gd2UgbWF5L21heSBub3QgYmUuXHJcblx0XHRcdFx0Ly9BcyBhIGhhY2sgd2Ugb25seSBkbyBhIGFuaW1hdGlvbiBmcmVlIHpvb20gb24gYSBzaW5nbGUgbGV2ZWwgem9vbSwgaWYgc29tZW9uZSBkb2VzIG11bHRpcGxlIGxldmVscyB0aGVuIHdlIGFsd2F5cyBhbmltYXRlXHJcblx0XHRcdFx0aWYgKGMuX2lzU2luZ2xlUGFyZW50KCkgJiYgcHJldmlvdXNab29tTGV2ZWwgLSAxID09PSBuZXdab29tTGV2ZWwpIHtcclxuXHRcdFx0XHRcdGMuY2x1c3RlclNob3coKTtcclxuXHRcdFx0XHRcdGMuX3JlY3Vyc2l2ZWx5UmVtb3ZlQ2hpbGRyZW5Gcm9tTWFwKGJvdW5kcywgbWFwTWluWm9vbSwgcHJldmlvdXNab29tTGV2ZWwpOyAvL0ltbWVkaWF0ZWx5IHJlbW92ZSBvdXIgY2hpbGRyZW4gYXMgd2UgYXJlIHJlcGxhY2luZyB0aGVtLiBUT0RPIHByZXZpb3VzQm91bmRzIG5vdCBib3VuZHNcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0Yy5jbHVzdGVySGlkZSgpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Yy5fYWRkVG9NYXAoKTtcclxuXHRcdFx0fVxyXG5cdFx0KTtcclxuXHR9LFxyXG5cclxuXHRfcmVjdXJzaXZlbHlCZWNvbWVWaXNpYmxlOiBmdW5jdGlvbiAoYm91bmRzLCB6b29tTGV2ZWwpIHtcclxuXHRcdHRoaXMuX3JlY3Vyc2l2ZWx5KGJvdW5kcywgdGhpcy5fZ3JvdXAuX21hcC5nZXRNaW5ab29tKCksIHpvb21MZXZlbCwgbnVsbCwgZnVuY3Rpb24gKGMpIHtcclxuXHRcdFx0Yy5jbHVzdGVyU2hvdygpO1xyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0X3JlY3Vyc2l2ZWx5QWRkQ2hpbGRyZW5Ub01hcDogZnVuY3Rpb24gKHN0YXJ0UG9zLCB6b29tTGV2ZWwsIGJvdW5kcykge1xyXG5cdFx0dGhpcy5fcmVjdXJzaXZlbHkoYm91bmRzLCB0aGlzLl9ncm91cC5fbWFwLmdldE1pblpvb20oKSAtIDEsIHpvb21MZXZlbCxcclxuXHRcdFx0ZnVuY3Rpb24gKGMpIHtcclxuXHRcdFx0XHRpZiAoem9vbUxldmVsID09PSBjLl96b29tKSB7XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvL0FkZCBvdXIgY2hpbGQgbWFya2VycyBhdCBzdGFydFBvcyAoc28gdGhleSBjYW4gYmUgYW5pbWF0ZWQgb3V0KVxyXG5cdFx0XHRcdGZvciAodmFyIGkgPSBjLl9tYXJrZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdFx0XHR2YXIgbm0gPSBjLl9tYXJrZXJzW2ldO1xyXG5cclxuXHRcdFx0XHRcdGlmICghYm91bmRzLmNvbnRhaW5zKG5tLl9sYXRsbmcpKSB7XHJcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGlmIChzdGFydFBvcykge1xyXG5cdFx0XHRcdFx0XHRubS5fYmFja3VwTGF0bG5nID0gbm0uZ2V0TGF0TG5nKCk7XHJcblxyXG5cdFx0XHRcdFx0XHRubS5zZXRMYXRMbmcoc3RhcnRQb3MpO1xyXG5cdFx0XHRcdFx0XHRpZiAobm0uY2x1c3RlckhpZGUpIHtcclxuXHRcdFx0XHRcdFx0XHRubS5jbHVzdGVySGlkZSgpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Yy5fZ3JvdXAuX2ZlYXR1cmVHcm91cC5hZGRMYXllcihubSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9LFxyXG5cdFx0XHRmdW5jdGlvbiAoYykge1xyXG5cdFx0XHRcdGMuX2FkZFRvTWFwKHN0YXJ0UG9zKTtcclxuXHRcdFx0fVxyXG5cdFx0KTtcclxuXHR9LFxyXG5cclxuXHRfcmVjdXJzaXZlbHlSZXN0b3JlQ2hpbGRQb3NpdGlvbnM6IGZ1bmN0aW9uICh6b29tTGV2ZWwpIHtcclxuXHRcdC8vRml4IHBvc2l0aW9ucyBvZiBjaGlsZCBtYXJrZXJzXHJcblx0XHRmb3IgKHZhciBpID0gdGhpcy5fbWFya2Vycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG5cdFx0XHR2YXIgbm0gPSB0aGlzLl9tYXJrZXJzW2ldO1xyXG5cdFx0XHRpZiAobm0uX2JhY2t1cExhdGxuZykge1xyXG5cdFx0XHRcdG5tLnNldExhdExuZyhubS5fYmFja3VwTGF0bG5nKTtcclxuXHRcdFx0XHRkZWxldGUgbm0uX2JhY2t1cExhdGxuZztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh6b29tTGV2ZWwgLSAxID09PSB0aGlzLl96b29tKSB7XHJcblx0XHRcdC8vUmVwb3NpdGlvbiBjaGlsZCBjbHVzdGVyc1xyXG5cdFx0XHRmb3IgKHZhciBqID0gdGhpcy5fY2hpbGRDbHVzdGVycy5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xyXG5cdFx0XHRcdHRoaXMuX2NoaWxkQ2x1c3RlcnNbal0uX3Jlc3RvcmVQb3NpdGlvbigpO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRmb3IgKHZhciBrID0gdGhpcy5fY2hpbGRDbHVzdGVycy5sZW5ndGggLSAxOyBrID49IDA7IGstLSkge1xyXG5cdFx0XHRcdHRoaXMuX2NoaWxkQ2x1c3RlcnNba10uX3JlY3Vyc2l2ZWx5UmVzdG9yZUNoaWxkUG9zaXRpb25zKHpvb21MZXZlbCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfcmVzdG9yZVBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fYmFja3VwTGF0bG5nKSB7XHJcblx0XHRcdHRoaXMuc2V0TGF0TG5nKHRoaXMuX2JhY2t1cExhdGxuZyk7XHJcblx0XHRcdGRlbGV0ZSB0aGlzLl9iYWNrdXBMYXRsbmc7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly9leGNlcHRCb3VuZHM6IElmIHNldCwgZG9uJ3QgcmVtb3ZlIGFueSBtYXJrZXJzL2NsdXN0ZXJzIGluIGl0XHJcblx0X3JlY3Vyc2l2ZWx5UmVtb3ZlQ2hpbGRyZW5Gcm9tTWFwOiBmdW5jdGlvbiAocHJldmlvdXNCb3VuZHMsIG1hcE1pblpvb20sIHpvb21MZXZlbCwgZXhjZXB0Qm91bmRzKSB7XHJcblx0XHR2YXIgbSwgaTtcclxuXHRcdHRoaXMuX3JlY3Vyc2l2ZWx5KHByZXZpb3VzQm91bmRzLCBtYXBNaW5ab29tIC0gMSwgem9vbUxldmVsIC0gMSxcclxuXHRcdFx0ZnVuY3Rpb24gKGMpIHtcclxuXHRcdFx0XHQvL1JlbW92ZSBtYXJrZXJzIGF0IGV2ZXJ5IGxldmVsXHJcblx0XHRcdFx0Zm9yIChpID0gYy5fbWFya2Vycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG5cdFx0XHRcdFx0bSA9IGMuX21hcmtlcnNbaV07XHJcblx0XHRcdFx0XHRpZiAoIWV4Y2VwdEJvdW5kcyB8fCAhZXhjZXB0Qm91bmRzLmNvbnRhaW5zKG0uX2xhdGxuZykpIHtcclxuXHRcdFx0XHRcdFx0Yy5fZ3JvdXAuX2ZlYXR1cmVHcm91cC5yZW1vdmVMYXllcihtKTtcclxuXHRcdFx0XHRcdFx0aWYgKG0uY2x1c3RlclNob3cpIHtcclxuXHRcdFx0XHRcdFx0XHRtLmNsdXN0ZXJTaG93KCk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH0sXHJcblx0XHRcdGZ1bmN0aW9uIChjKSB7XHJcblx0XHRcdFx0Ly9SZW1vdmUgY2hpbGQgY2x1c3RlcnMgYXQganVzdCB0aGUgYm90dG9tIGxldmVsXHJcblx0XHRcdFx0Zm9yIChpID0gYy5fY2hpbGRDbHVzdGVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG5cdFx0XHRcdFx0bSA9IGMuX2NoaWxkQ2x1c3RlcnNbaV07XHJcblx0XHRcdFx0XHRpZiAoIWV4Y2VwdEJvdW5kcyB8fCAhZXhjZXB0Qm91bmRzLmNvbnRhaW5zKG0uX2xhdGxuZykpIHtcclxuXHRcdFx0XHRcdFx0Yy5fZ3JvdXAuX2ZlYXR1cmVHcm91cC5yZW1vdmVMYXllcihtKTtcclxuXHRcdFx0XHRcdFx0aWYgKG0uY2x1c3RlclNob3cpIHtcclxuXHRcdFx0XHRcdFx0XHRtLmNsdXN0ZXJTaG93KCk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdCk7XHJcblx0fSxcclxuXHJcblx0Ly9SdW4gdGhlIGdpdmVuIGZ1bmN0aW9ucyByZWN1cnNpdmVseSB0byB0aGlzIGFuZCBjaGlsZCBjbHVzdGVyc1xyXG5cdC8vIGJvdW5kc1RvQXBwbHlUbzogYSBMLkxhdExuZ0JvdW5kcyByZXByZXNlbnRpbmcgdGhlIGJvdW5kcyBvZiB3aGF0IGNsdXN0ZXJzIHRvIHJlY3Vyc2UgaW4gdG9cclxuXHQvLyB6b29tTGV2ZWxUb1N0YXJ0OiB6b29tIGxldmVsIHRvIHN0YXJ0IHJ1bm5pbmcgZnVuY3Rpb25zIChpbmNsdXNpdmUpXHJcblx0Ly8gem9vbUxldmVsVG9TdG9wOiB6b29tIGxldmVsIHRvIHN0b3AgcnVubmluZyBmdW5jdGlvbnMgKGluY2x1c2l2ZSlcclxuXHQvLyBydW5BdEV2ZXJ5TGV2ZWw6IGZ1bmN0aW9uIHRoYXQgdGFrZXMgYW4gTC5NYXJrZXJDbHVzdGVyIGFzIGFuIGFyZ3VtZW50IHRoYXQgc2hvdWxkIGJlIGFwcGxpZWQgb24gZXZlcnkgbGV2ZWxcclxuXHQvLyBydW5BdEJvdHRvbUxldmVsOiBmdW5jdGlvbiB0aGF0IHRha2VzIGFuIEwuTWFya2VyQ2x1c3RlciBhcyBhbiBhcmd1bWVudCB0aGF0IHNob3VsZCBiZSBhcHBsaWVkIGF0IG9ubHkgdGhlIGJvdHRvbSBsZXZlbFxyXG5cdF9yZWN1cnNpdmVseTogZnVuY3Rpb24gKGJvdW5kc1RvQXBwbHlUbywgem9vbUxldmVsVG9TdGFydCwgem9vbUxldmVsVG9TdG9wLCBydW5BdEV2ZXJ5TGV2ZWwsIHJ1bkF0Qm90dG9tTGV2ZWwpIHtcclxuXHRcdHZhciBjaGlsZENsdXN0ZXJzID0gdGhpcy5fY2hpbGRDbHVzdGVycyxcclxuXHRcdCAgICB6b29tID0gdGhpcy5fem9vbSxcclxuXHRcdCAgICBpLCBjO1xyXG5cclxuXHRcdGlmICh6b29tTGV2ZWxUb1N0YXJ0IDw9IHpvb20pIHtcclxuXHRcdFx0aWYgKHJ1bkF0RXZlcnlMZXZlbCkge1xyXG5cdFx0XHRcdHJ1bkF0RXZlcnlMZXZlbCh0aGlzKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAocnVuQXRCb3R0b21MZXZlbCAmJiB6b29tID09PSB6b29tTGV2ZWxUb1N0b3ApIHtcclxuXHRcdFx0XHRydW5BdEJvdHRvbUxldmVsKHRoaXMpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHpvb20gPCB6b29tTGV2ZWxUb1N0YXJ0IHx8IHpvb20gPCB6b29tTGV2ZWxUb1N0b3ApIHtcclxuXHRcdFx0Zm9yIChpID0gY2hpbGRDbHVzdGVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG5cdFx0XHRcdGMgPSBjaGlsZENsdXN0ZXJzW2ldO1xyXG5cdFx0XHRcdGlmIChjLl9ib3VuZHNOZWVkVXBkYXRlKSB7XHJcblx0XHRcdFx0XHRjLl9yZWNhbGN1bGF0ZUJvdW5kcygpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAoYm91bmRzVG9BcHBseVRvLmludGVyc2VjdHMoYy5fYm91bmRzKSkge1xyXG5cdFx0XHRcdFx0Yy5fcmVjdXJzaXZlbHkoYm91bmRzVG9BcHBseVRvLCB6b29tTGV2ZWxUb1N0YXJ0LCB6b29tTGV2ZWxUb1N0b3AsIHJ1bkF0RXZlcnlMZXZlbCwgcnVuQXRCb3R0b21MZXZlbCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly9SZXR1cm5zIHRydWUgaWYgd2UgYXJlIHRoZSBwYXJlbnQgb2Ygb25seSBvbmUgY2x1c3RlciBhbmQgdGhhdCBjbHVzdGVyIGlzIHRoZSBzYW1lIGFzIHVzXHJcblx0X2lzU2luZ2xlUGFyZW50OiBmdW5jdGlvbiAoKSB7XHJcblx0XHQvL0Rvbid0IG5lZWQgdG8gY2hlY2sgdGhpcy5fbWFya2VycyBhcyB0aGUgcmVzdCB3b24ndCB3b3JrIGlmIHRoZXJlIGFyZSBhbnlcclxuXHRcdHJldHVybiB0aGlzLl9jaGlsZENsdXN0ZXJzLmxlbmd0aCA+IDAgJiYgdGhpcy5fY2hpbGRDbHVzdGVyc1swXS5fY2hpbGRDb3VudCA9PT0gdGhpcy5fY2hpbGRDb3VudDtcclxuXHR9XHJcbn0pO1xuXG4vKlxyXG4qIEV4dGVuZHMgTC5NYXJrZXIgdG8gaW5jbHVkZSB0d28gZXh0cmEgbWV0aG9kczogY2x1c3RlckhpZGUgYW5kIGNsdXN0ZXJTaG93LlxyXG4qIFxyXG4qIFRoZXkgd29yayBhcyBzZXRPcGFjaXR5KDApIGFuZCBzZXRPcGFjaXR5KDEpIHJlc3BlY3RpdmVseSwgYnV0XHJcbiogZG9uJ3Qgb3ZlcndyaXRlIHRoZSBvcHRpb25zLm9wYWNpdHlcclxuKiBcclxuKi9cclxuXHJcbkwuTWFya2VyLmluY2x1ZGUoe1xyXG5cdGNsdXN0ZXJIaWRlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgYmFja3VwID0gdGhpcy5vcHRpb25zLm9wYWNpdHk7XHJcblx0XHR0aGlzLnNldE9wYWNpdHkoMCk7XHJcblx0XHR0aGlzLm9wdGlvbnMub3BhY2l0eSA9IGJhY2t1cDtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblx0XHJcblx0Y2x1c3RlclNob3c6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLnNldE9wYWNpdHkodGhpcy5vcHRpb25zLm9wYWNpdHkpO1xyXG5cdH1cclxufSk7XG5cbkwuRGlzdGFuY2VHcmlkID0gZnVuY3Rpb24gKGNlbGxTaXplKSB7XHJcblx0dGhpcy5fY2VsbFNpemUgPSBjZWxsU2l6ZTtcclxuXHR0aGlzLl9zcUNlbGxTaXplID0gY2VsbFNpemUgKiBjZWxsU2l6ZTtcclxuXHR0aGlzLl9ncmlkID0ge307XHJcblx0dGhpcy5fb2JqZWN0UG9pbnQgPSB7IH07XHJcbn07XHJcblxyXG5MLkRpc3RhbmNlR3JpZC5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGFkZE9iamVjdDogZnVuY3Rpb24gKG9iaiwgcG9pbnQpIHtcclxuXHRcdHZhciB4ID0gdGhpcy5fZ2V0Q29vcmQocG9pbnQueCksXHJcblx0XHQgICAgeSA9IHRoaXMuX2dldENvb3JkKHBvaW50LnkpLFxyXG5cdFx0ICAgIGdyaWQgPSB0aGlzLl9ncmlkLFxyXG5cdFx0ICAgIHJvdyA9IGdyaWRbeV0gPSBncmlkW3ldIHx8IHt9LFxyXG5cdFx0ICAgIGNlbGwgPSByb3dbeF0gPSByb3dbeF0gfHwgW10sXHJcblx0XHQgICAgc3RhbXAgPSBMLlV0aWwuc3RhbXAob2JqKTtcclxuXHJcblx0XHR0aGlzLl9vYmplY3RQb2ludFtzdGFtcF0gPSBwb2ludDtcclxuXHJcblx0XHRjZWxsLnB1c2gob2JqKTtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGVPYmplY3Q6IGZ1bmN0aW9uIChvYmosIHBvaW50KSB7XHJcblx0XHR0aGlzLnJlbW92ZU9iamVjdChvYmopO1xyXG5cdFx0dGhpcy5hZGRPYmplY3Qob2JqLCBwb2ludCk7XHJcblx0fSxcclxuXHJcblx0Ly9SZXR1cm5zIHRydWUgaWYgdGhlIG9iamVjdCB3YXMgZm91bmRcclxuXHRyZW1vdmVPYmplY3Q6IGZ1bmN0aW9uIChvYmosIHBvaW50KSB7XHJcblx0XHR2YXIgeCA9IHRoaXMuX2dldENvb3JkKHBvaW50LngpLFxyXG5cdFx0ICAgIHkgPSB0aGlzLl9nZXRDb29yZChwb2ludC55KSxcclxuXHRcdCAgICBncmlkID0gdGhpcy5fZ3JpZCxcclxuXHRcdCAgICByb3cgPSBncmlkW3ldID0gZ3JpZFt5XSB8fCB7fSxcclxuXHRcdCAgICBjZWxsID0gcm93W3hdID0gcm93W3hdIHx8IFtdLFxyXG5cdFx0ICAgIGksIGxlbjtcclxuXHJcblx0XHRkZWxldGUgdGhpcy5fb2JqZWN0UG9pbnRbTC5VdGlsLnN0YW1wKG9iaildO1xyXG5cclxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNlbGwubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0aWYgKGNlbGxbaV0gPT09IG9iaikge1xyXG5cclxuXHRcdFx0XHRjZWxsLnNwbGljZShpLCAxKTtcclxuXHJcblx0XHRcdFx0aWYgKGxlbiA9PT0gMSkge1xyXG5cdFx0XHRcdFx0ZGVsZXRlIHJvd1t4XTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdGVhY2hPYmplY3Q6IGZ1bmN0aW9uIChmbiwgY29udGV4dCkge1xyXG5cdFx0dmFyIGksIGosIGssIGxlbiwgcm93LCBjZWxsLCByZW1vdmVkLFxyXG5cdFx0ICAgIGdyaWQgPSB0aGlzLl9ncmlkO1xyXG5cclxuXHRcdGZvciAoaSBpbiBncmlkKSB7XHJcblx0XHRcdHJvdyA9IGdyaWRbaV07XHJcblxyXG5cdFx0XHRmb3IgKGogaW4gcm93KSB7XHJcblx0XHRcdFx0Y2VsbCA9IHJvd1tqXTtcclxuXHJcblx0XHRcdFx0Zm9yIChrID0gMCwgbGVuID0gY2VsbC5sZW5ndGg7IGsgPCBsZW47IGsrKykge1xyXG5cdFx0XHRcdFx0cmVtb3ZlZCA9IGZuLmNhbGwoY29udGV4dCwgY2VsbFtrXSk7XHJcblx0XHRcdFx0XHRpZiAocmVtb3ZlZCkge1xyXG5cdFx0XHRcdFx0XHRrLS07XHJcblx0XHRcdFx0XHRcdGxlbi0tO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdGdldE5lYXJPYmplY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0dmFyIHggPSB0aGlzLl9nZXRDb29yZChwb2ludC54KSxcclxuXHRcdCAgICB5ID0gdGhpcy5fZ2V0Q29vcmQocG9pbnQueSksXHJcblx0XHQgICAgaSwgaiwgaywgcm93LCBjZWxsLCBsZW4sIG9iaiwgZGlzdCxcclxuXHRcdCAgICBvYmplY3RQb2ludCA9IHRoaXMuX29iamVjdFBvaW50LFxyXG5cdFx0ICAgIGNsb3Nlc3REaXN0U3EgPSB0aGlzLl9zcUNlbGxTaXplLFxyXG5cdFx0ICAgIGNsb3Nlc3QgPSBudWxsO1xyXG5cclxuXHRcdGZvciAoaSA9IHkgLSAxOyBpIDw9IHkgKyAxOyBpKyspIHtcclxuXHRcdFx0cm93ID0gdGhpcy5fZ3JpZFtpXTtcclxuXHRcdFx0aWYgKHJvdykge1xyXG5cclxuXHRcdFx0XHRmb3IgKGogPSB4IC0gMTsgaiA8PSB4ICsgMTsgaisrKSB7XHJcblx0XHRcdFx0XHRjZWxsID0gcm93W2pdO1xyXG5cdFx0XHRcdFx0aWYgKGNlbGwpIHtcclxuXHJcblx0XHRcdFx0XHRcdGZvciAoayA9IDAsIGxlbiA9IGNlbGwubGVuZ3RoOyBrIDwgbGVuOyBrKyspIHtcclxuXHRcdFx0XHRcdFx0XHRvYmogPSBjZWxsW2tdO1xyXG5cdFx0XHRcdFx0XHRcdGRpc3QgPSB0aGlzLl9zcURpc3Qob2JqZWN0UG9pbnRbTC5VdGlsLnN0YW1wKG9iaildLCBwb2ludCk7XHJcblx0XHRcdFx0XHRcdFx0aWYgKGRpc3QgPCBjbG9zZXN0RGlzdFNxIHx8XHJcblx0XHRcdFx0XHRcdFx0XHRkaXN0IDw9IGNsb3Nlc3REaXN0U3EgJiYgY2xvc2VzdCA9PT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0Y2xvc2VzdERpc3RTcSA9IGRpc3Q7XHJcblx0XHRcdFx0XHRcdFx0XHRjbG9zZXN0ID0gb2JqO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGNsb3Nlc3Q7XHJcblx0fSxcclxuXHJcblx0X2dldENvb3JkOiBmdW5jdGlvbiAoeCkge1xyXG5cdFx0dmFyIGNvb3JkID0gTWF0aC5mbG9vcih4IC8gdGhpcy5fY2VsbFNpemUpO1xyXG5cdFx0cmV0dXJuIGlzRmluaXRlKGNvb3JkKSA/IGNvb3JkIDogeDtcclxuXHR9LFxyXG5cclxuXHRfc3FEaXN0OiBmdW5jdGlvbiAocCwgcDIpIHtcclxuXHRcdHZhciBkeCA9IHAyLnggLSBwLngsXHJcblx0XHQgICAgZHkgPSBwMi55IC0gcC55O1xyXG5cdFx0cmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xyXG5cdH1cclxufTtcblxuLyogQ29weXJpZ2h0IChjKSAyMDEyIHRoZSBhdXRob3JzIGxpc3RlZCBhdCB0aGUgZm9sbG93aW5nIFVSTCwgYW5kL29yXHJcbnRoZSBhdXRob3JzIG9mIHJlZmVyZW5jZWQgYXJ0aWNsZXMgb3IgaW5jb3Jwb3JhdGVkIGV4dGVybmFsIGNvZGU6XHJcbmh0dHA6Ly9lbi5saXRlcmF0ZXByb2dyYW1zLm9yZy9RdWlja2h1bGxfKEphdmFzY3JpcHQpP2FjdGlvbj1oaXN0b3J5Jm9mZnNldD0yMDEyMDQxMDE3NTI1NlxyXG5cclxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nXHJcbmEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxyXG5cIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcclxud2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxyXG5kaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cclxucGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvXHJcbnRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuXHJcblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXHJcbmluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcclxuRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXHJcbk1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC5cclxuSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTllcclxuQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCxcclxuVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEVcclxuU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXHJcblxyXG5SZXRyaWV2ZWQgZnJvbTogaHR0cDovL2VuLmxpdGVyYXRlcHJvZ3JhbXMub3JnL1F1aWNraHVsbF8oSmF2YXNjcmlwdCk/b2xkaWQ9MTg0MzRcclxuKi9cclxuXHJcbihmdW5jdGlvbiAoKSB7XHJcblx0TC5RdWlja0h1bGwgPSB7XHJcblxyXG5cdFx0LypcclxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBjcHQgYSBwb2ludCB0byBiZSBtZWFzdXJlZCBmcm9tIHRoZSBiYXNlbGluZVxyXG5cdFx0ICogQHBhcmFtIHtBcnJheX0gYmwgdGhlIGJhc2VsaW5lLCBhcyByZXByZXNlbnRlZCBieSBhIHR3by1lbGVtZW50XHJcblx0XHQgKiAgIGFycmF5IG9mIGxhdGxuZyBvYmplY3RzLlxyXG5cdFx0ICogQHJldHVybnMge051bWJlcn0gYW4gYXBwcm94aW1hdGUgZGlzdGFuY2UgbWVhc3VyZVxyXG5cdFx0ICovXHJcblx0XHRnZXREaXN0YW50OiBmdW5jdGlvbiAoY3B0LCBibCkge1xyXG5cdFx0XHR2YXIgdlkgPSBibFsxXS5sYXQgLSBibFswXS5sYXQsXHJcblx0XHRcdFx0dlggPSBibFswXS5sbmcgLSBibFsxXS5sbmc7XHJcblx0XHRcdHJldHVybiAodlggKiAoY3B0LmxhdCAtIGJsWzBdLmxhdCkgKyB2WSAqIChjcHQubG5nIC0gYmxbMF0ubG5nKSk7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qXHJcblx0XHQgKiBAcGFyYW0ge0FycmF5fSBiYXNlTGluZSBhIHR3by1lbGVtZW50IGFycmF5IG9mIGxhdGxuZyBvYmplY3RzXHJcblx0XHQgKiAgIHJlcHJlc2VudGluZyB0aGUgYmFzZWxpbmUgdG8gcHJvamVjdCBmcm9tXHJcblx0XHQgKiBAcGFyYW0ge0FycmF5fSBsYXRMbmdzIGFuIGFycmF5IG9mIGxhdGxuZyBvYmplY3RzXHJcblx0XHQgKiBAcmV0dXJucyB7T2JqZWN0fSB0aGUgbWF4aW11bSBwb2ludCBhbmQgYWxsIG5ldyBwb2ludHMgdG8gc3RheVxyXG5cdFx0ICogICBpbiBjb25zaWRlcmF0aW9uIGZvciB0aGUgaHVsbC5cclxuXHRcdCAqL1xyXG5cdFx0ZmluZE1vc3REaXN0YW50UG9pbnRGcm9tQmFzZUxpbmU6IGZ1bmN0aW9uIChiYXNlTGluZSwgbGF0TG5ncykge1xyXG5cdFx0XHR2YXIgbWF4RCA9IDAsXHJcblx0XHRcdFx0bWF4UHQgPSBudWxsLFxyXG5cdFx0XHRcdG5ld1BvaW50cyA9IFtdLFxyXG5cdFx0XHRcdGksIHB0LCBkO1xyXG5cclxuXHRcdFx0Zm9yIChpID0gbGF0TG5ncy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG5cdFx0XHRcdHB0ID0gbGF0TG5nc1tpXTtcclxuXHRcdFx0XHRkID0gdGhpcy5nZXREaXN0YW50KHB0LCBiYXNlTGluZSk7XHJcblxyXG5cdFx0XHRcdGlmIChkID4gMCkge1xyXG5cdFx0XHRcdFx0bmV3UG9pbnRzLnB1c2gocHQpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmIChkID4gbWF4RCkge1xyXG5cdFx0XHRcdFx0bWF4RCA9IGQ7XHJcblx0XHRcdFx0XHRtYXhQdCA9IHB0O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHsgbWF4UG9pbnQ6IG1heFB0LCBuZXdQb2ludHM6IG5ld1BvaW50cyB9O1xyXG5cdFx0fSxcclxuXHJcblxyXG5cdFx0LypcclxuXHRcdCAqIEdpdmVuIGEgYmFzZWxpbmUsIGNvbXB1dGUgdGhlIGNvbnZleCBodWxsIG9mIGxhdExuZ3MgYXMgYW4gYXJyYXlcclxuXHRcdCAqIG9mIGxhdExuZ3MuXHJcblx0XHQgKlxyXG5cdFx0ICogQHBhcmFtIHtBcnJheX0gbGF0TG5nc1xyXG5cdFx0ICogQHJldHVybnMge0FycmF5fVxyXG5cdFx0ICovXHJcblx0XHRidWlsZENvbnZleEh1bGw6IGZ1bmN0aW9uIChiYXNlTGluZSwgbGF0TG5ncykge1xyXG5cdFx0XHR2YXIgY29udmV4SHVsbEJhc2VMaW5lcyA9IFtdLFxyXG5cdFx0XHRcdHQgPSB0aGlzLmZpbmRNb3N0RGlzdGFudFBvaW50RnJvbUJhc2VMaW5lKGJhc2VMaW5lLCBsYXRMbmdzKTtcclxuXHJcblx0XHRcdGlmICh0Lm1heFBvaW50KSB7IC8vIGlmIHRoZXJlIGlzIHN0aWxsIGEgcG9pbnQgXCJvdXRzaWRlXCIgdGhlIGJhc2UgbGluZVxyXG5cdFx0XHRcdGNvbnZleEh1bGxCYXNlTGluZXMgPVxyXG5cdFx0XHRcdFx0Y29udmV4SHVsbEJhc2VMaW5lcy5jb25jYXQoXHJcblx0XHRcdFx0XHRcdHRoaXMuYnVpbGRDb252ZXhIdWxsKFtiYXNlTGluZVswXSwgdC5tYXhQb2ludF0sIHQubmV3UG9pbnRzKVxyXG5cdFx0XHRcdFx0KTtcclxuXHRcdFx0XHRjb252ZXhIdWxsQmFzZUxpbmVzID1cclxuXHRcdFx0XHRcdGNvbnZleEh1bGxCYXNlTGluZXMuY29uY2F0KFxyXG5cdFx0XHRcdFx0XHR0aGlzLmJ1aWxkQ29udmV4SHVsbChbdC5tYXhQb2ludCwgYmFzZUxpbmVbMV1dLCB0Lm5ld1BvaW50cylcclxuXHRcdFx0XHRcdCk7XHJcblx0XHRcdFx0cmV0dXJuIGNvbnZleEh1bGxCYXNlTGluZXM7XHJcblx0XHRcdH0gZWxzZSB7ICAvLyBpZiB0aGVyZSBpcyBubyBtb3JlIHBvaW50IFwib3V0c2lkZVwiIHRoZSBiYXNlIGxpbmUsIHRoZSBjdXJyZW50IGJhc2UgbGluZSBpcyBwYXJ0IG9mIHRoZSBjb252ZXggaHVsbFxyXG5cdFx0XHRcdHJldHVybiBbYmFzZUxpbmVbMF1dO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qXHJcblx0XHQgKiBHaXZlbiBhbiBhcnJheSBvZiBsYXRsbmdzLCBjb21wdXRlIGEgY29udmV4IGh1bGwgYXMgYW4gYXJyYXlcclxuXHRcdCAqIG9mIGxhdGxuZ3NcclxuXHRcdCAqXHJcblx0XHQgKiBAcGFyYW0ge0FycmF5fSBsYXRMbmdzXHJcblx0XHQgKiBAcmV0dXJucyB7QXJyYXl9XHJcblx0XHQgKi9cclxuXHRcdGdldENvbnZleEh1bGw6IGZ1bmN0aW9uIChsYXRMbmdzKSB7XHJcblx0XHRcdC8vIGZpbmQgZmlyc3QgYmFzZWxpbmVcclxuXHRcdFx0dmFyIG1heExhdCA9IGZhbHNlLCBtaW5MYXQgPSBmYWxzZSxcclxuXHRcdFx0XHRtYXhMbmcgPSBmYWxzZSwgbWluTG5nID0gZmFsc2UsXHJcblx0XHRcdFx0bWF4TGF0UHQgPSBudWxsLCBtaW5MYXRQdCA9IG51bGwsXHJcblx0XHRcdFx0bWF4TG5nUHQgPSBudWxsLCBtaW5MbmdQdCA9IG51bGwsXHJcblx0XHRcdFx0bWF4UHQgPSBudWxsLCBtaW5QdCA9IG51bGwsXHJcblx0XHRcdFx0aTtcclxuXHJcblx0XHRcdGZvciAoaSA9IGxhdExuZ3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuXHRcdFx0XHR2YXIgcHQgPSBsYXRMbmdzW2ldO1xyXG5cdFx0XHRcdGlmIChtYXhMYXQgPT09IGZhbHNlIHx8IHB0LmxhdCA+IG1heExhdCkge1xyXG5cdFx0XHRcdFx0bWF4TGF0UHQgPSBwdDtcclxuXHRcdFx0XHRcdG1heExhdCA9IHB0LmxhdDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKG1pbkxhdCA9PT0gZmFsc2UgfHwgcHQubGF0IDwgbWluTGF0KSB7XHJcblx0XHRcdFx0XHRtaW5MYXRQdCA9IHB0O1xyXG5cdFx0XHRcdFx0bWluTGF0ID0gcHQubGF0O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAobWF4TG5nID09PSBmYWxzZSB8fCBwdC5sbmcgPiBtYXhMbmcpIHtcclxuXHRcdFx0XHRcdG1heExuZ1B0ID0gcHQ7XHJcblx0XHRcdFx0XHRtYXhMbmcgPSBwdC5sbmc7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmIChtaW5MbmcgPT09IGZhbHNlIHx8IHB0LmxuZyA8IG1pbkxuZykge1xyXG5cdFx0XHRcdFx0bWluTG5nUHQgPSBwdDtcclxuXHRcdFx0XHRcdG1pbkxuZyA9IHB0LmxuZztcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0XHJcblx0XHRcdGlmIChtaW5MYXQgIT09IG1heExhdCkge1xyXG5cdFx0XHRcdG1pblB0ID0gbWluTGF0UHQ7XHJcblx0XHRcdFx0bWF4UHQgPSBtYXhMYXRQdDtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRtaW5QdCA9IG1pbkxuZ1B0O1xyXG5cdFx0XHRcdG1heFB0ID0gbWF4TG5nUHQ7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBjaCA9IFtdLmNvbmNhdCh0aGlzLmJ1aWxkQ29udmV4SHVsbChbbWluUHQsIG1heFB0XSwgbGF0TG5ncyksXHJcblx0XHRcdFx0XHRcdFx0XHR0aGlzLmJ1aWxkQ29udmV4SHVsbChbbWF4UHQsIG1pblB0XSwgbGF0TG5ncykpO1xyXG5cdFx0XHRyZXR1cm4gY2g7XHJcblx0XHR9XHJcblx0fTtcclxufSgpKTtcclxuXHJcbkwuTWFya2VyQ2x1c3Rlci5pbmNsdWRlKHtcclxuXHRnZXRDb252ZXhIdWxsOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgY2hpbGRNYXJrZXJzID0gdGhpcy5nZXRBbGxDaGlsZE1hcmtlcnMoKSxcclxuXHRcdFx0cG9pbnRzID0gW10sXHJcblx0XHRcdHAsIGk7XHJcblxyXG5cdFx0Zm9yIChpID0gY2hpbGRNYXJrZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdHAgPSBjaGlsZE1hcmtlcnNbaV0uZ2V0TGF0TG5nKCk7XHJcblx0XHRcdHBvaW50cy5wdXNoKHApO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBMLlF1aWNrSHVsbC5nZXRDb252ZXhIdWxsKHBvaW50cyk7XHJcblx0fVxyXG59KTtcblxuLy9UaGlzIGNvZGUgaXMgMTAwJSBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vamF3ai9PdmVybGFwcGluZ01hcmtlclNwaWRlcmZpZXItTGVhZmxldFxyXG4vL0h1Z2UgdGhhbmtzIHRvIGphd2ogZm9yIGltcGxlbWVudGluZyBpdCBmaXJzdCB0byBtYWtlIG15IGpvYiBlYXN5IDotKVxyXG5cclxuTC5NYXJrZXJDbHVzdGVyLmluY2x1ZGUoe1xyXG5cclxuXHRfMlBJOiBNYXRoLlBJICogMixcclxuXHRfY2lyY2xlRm9vdFNlcGFyYXRpb246IDI1LCAvL3JlbGF0ZWQgdG8gY2lyY3VtZmVyZW5jZSBvZiBjaXJjbGVcclxuXHRfY2lyY2xlU3RhcnRBbmdsZTogMCxcclxuXHJcblx0X3NwaXJhbEZvb3RTZXBhcmF0aW9uOiAgMjgsIC8vcmVsYXRlZCB0byBzaXplIG9mIHNwaXJhbCAoZXhwZXJpbWVudCEpXHJcblx0X3NwaXJhbExlbmd0aFN0YXJ0OiAxMSxcclxuXHRfc3BpcmFsTGVuZ3RoRmFjdG9yOiA1LFxyXG5cclxuXHRfY2lyY2xlU3BpcmFsU3dpdGNob3ZlcjogOSwgLy9zaG93IHNwaXJhbCBpbnN0ZWFkIG9mIGNpcmNsZSBmcm9tIHRoaXMgbWFya2VyIGNvdW50IHVwd2FyZHMuXHJcblx0XHRcdFx0XHRcdFx0XHQvLyAwIC0+IGFsd2F5cyBzcGlyYWw7IEluZmluaXR5IC0+IGFsd2F5cyBjaXJjbGVcclxuXHJcblx0c3BpZGVyZnk6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9ncm91cC5fc3BpZGVyZmllZCA9PT0gdGhpcyB8fCB0aGlzLl9ncm91cC5faW5ab29tQW5pbWF0aW9uKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgY2hpbGRNYXJrZXJzID0gdGhpcy5nZXRBbGxDaGlsZE1hcmtlcnMobnVsbCwgdHJ1ZSksXHJcblx0XHRcdGdyb3VwID0gdGhpcy5fZ3JvdXAsXHJcblx0XHRcdG1hcCA9IGdyb3VwLl9tYXAsXHJcblx0XHRcdGNlbnRlciA9IG1hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKSxcclxuXHRcdFx0cG9zaXRpb25zO1xyXG5cclxuXHRcdHRoaXMuX2dyb3VwLl91bnNwaWRlcmZ5KCk7XHJcblx0XHR0aGlzLl9ncm91cC5fc3BpZGVyZmllZCA9IHRoaXM7XHJcblxyXG5cdFx0Ly9UT0RPIE1heWJlOiBjaGlsZE1hcmtlcnMgb3JkZXIgYnkgZGlzdGFuY2UgdG8gY2VudGVyXHJcblxyXG5cdFx0aWYgKGNoaWxkTWFya2Vycy5sZW5ndGggPj0gdGhpcy5fY2lyY2xlU3BpcmFsU3dpdGNob3Zlcikge1xyXG5cdFx0XHRwb3NpdGlvbnMgPSB0aGlzLl9nZW5lcmF0ZVBvaW50c1NwaXJhbChjaGlsZE1hcmtlcnMubGVuZ3RoLCBjZW50ZXIpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Y2VudGVyLnkgKz0gMTA7IC8vIE90aGVyd2lzZSBjaXJjbGVzIGxvb2sgd3JvbmcgPT4gaGFjayBmb3Igc3RhbmRhcmQgYmx1ZSBpY29uLCByZW5kZXJzIGRpZmZlcmVudGx5IGZvciBvdGhlciBpY29ucy5cclxuXHRcdFx0cG9zaXRpb25zID0gdGhpcy5fZ2VuZXJhdGVQb2ludHNDaXJjbGUoY2hpbGRNYXJrZXJzLmxlbmd0aCwgY2VudGVyKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9hbmltYXRpb25TcGlkZXJmeShjaGlsZE1hcmtlcnMsIHBvc2l0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0dW5zcGlkZXJmeTogZnVuY3Rpb24gKHpvb21EZXRhaWxzKSB7XHJcblx0XHQvLy8gPHBhcmFtIE5hbWU9XCJ6b29tRGV0YWlsc1wiPkFyZ3VtZW50IGZyb20gem9vbWFuaW0gaWYgYmVpbmcgY2FsbGVkIGluIGEgem9vbSBhbmltYXRpb24gb3IgbnVsbCBvdGhlcndpc2U8L3BhcmFtPlxyXG5cdFx0aWYgKHRoaXMuX2dyb3VwLl9pblpvb21BbmltYXRpb24pIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5fYW5pbWF0aW9uVW5zcGlkZXJmeSh6b29tRGV0YWlscyk7XHJcblxyXG5cdFx0dGhpcy5fZ3JvdXAuX3NwaWRlcmZpZWQgPSBudWxsO1xyXG5cdH0sXHJcblxyXG5cdF9nZW5lcmF0ZVBvaW50c0NpcmNsZTogZnVuY3Rpb24gKGNvdW50LCBjZW50ZXJQdCkge1xyXG5cdFx0dmFyIGNpcmN1bWZlcmVuY2UgPSB0aGlzLl9ncm91cC5vcHRpb25zLnNwaWRlcmZ5RGlzdGFuY2VNdWx0aXBsaWVyICogdGhpcy5fY2lyY2xlRm9vdFNlcGFyYXRpb24gKiAoMiArIGNvdW50KSxcclxuXHRcdFx0bGVnTGVuZ3RoID0gY2lyY3VtZmVyZW5jZSAvIHRoaXMuXzJQSSwgIC8vcmFkaXVzIGZyb20gY2lyY3VtZmVyZW5jZVxyXG5cdFx0XHRhbmdsZVN0ZXAgPSB0aGlzLl8yUEkgLyBjb3VudCxcclxuXHRcdFx0cmVzID0gW10sXHJcblx0XHRcdGksIGFuZ2xlO1xyXG5cclxuXHRcdGxlZ0xlbmd0aCA9IE1hdGgubWF4KGxlZ0xlbmd0aCwgMzUpOyAvLyBNaW5pbXVtIGRpc3RhbmNlIHRvIGdldCBvdXRzaWRlIHRoZSBjbHVzdGVyIGljb24uXHJcblxyXG5cdFx0cmVzLmxlbmd0aCA9IGNvdW50O1xyXG5cclxuXHRcdGZvciAoaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7IC8vIENsb2Nrd2lzZSwgbGlrZSBzcGlyYWwuXHJcblx0XHRcdGFuZ2xlID0gdGhpcy5fY2lyY2xlU3RhcnRBbmdsZSArIGkgKiBhbmdsZVN0ZXA7XHJcblx0XHRcdHJlc1tpXSA9IG5ldyBMLlBvaW50KGNlbnRlclB0LnggKyBsZWdMZW5ndGggKiBNYXRoLmNvcyhhbmdsZSksIGNlbnRlclB0LnkgKyBsZWdMZW5ndGggKiBNYXRoLnNpbihhbmdsZSkpLl9yb3VuZCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiByZXM7XHJcblx0fSxcclxuXHJcblx0X2dlbmVyYXRlUG9pbnRzU3BpcmFsOiBmdW5jdGlvbiAoY291bnQsIGNlbnRlclB0KSB7XHJcblx0XHR2YXIgc3BpZGVyZnlEaXN0YW5jZU11bHRpcGxpZXIgPSB0aGlzLl9ncm91cC5vcHRpb25zLnNwaWRlcmZ5RGlzdGFuY2VNdWx0aXBsaWVyLFxyXG5cdFx0XHRsZWdMZW5ndGggPSBzcGlkZXJmeURpc3RhbmNlTXVsdGlwbGllciAqIHRoaXMuX3NwaXJhbExlbmd0aFN0YXJ0LFxyXG5cdFx0XHRzZXBhcmF0aW9uID0gc3BpZGVyZnlEaXN0YW5jZU11bHRpcGxpZXIgKiB0aGlzLl9zcGlyYWxGb290U2VwYXJhdGlvbixcclxuXHRcdFx0bGVuZ3RoRmFjdG9yID0gc3BpZGVyZnlEaXN0YW5jZU11bHRpcGxpZXIgKiB0aGlzLl9zcGlyYWxMZW5ndGhGYWN0b3IgKiB0aGlzLl8yUEksXHJcblx0XHRcdGFuZ2xlID0gMCxcclxuXHRcdFx0cmVzID0gW10sXHJcblx0XHRcdGk7XHJcblxyXG5cdFx0cmVzLmxlbmd0aCA9IGNvdW50O1xyXG5cclxuXHRcdC8vIEhpZ2hlciBpbmRleCwgY2xvc2VyIHBvc2l0aW9uIHRvIGNsdXN0ZXIgY2VudGVyLlxyXG5cdFx0Zm9yIChpID0gY291bnQ7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdC8vIFNraXAgdGhlIGZpcnN0IHBvc2l0aW9uLCBzbyB0aGF0IHdlIGFyZSBhbHJlYWR5IGZhcnRoZXIgZnJvbSBjZW50ZXIgYW5kIHdlIGF2b2lkXHJcblx0XHRcdC8vIGJlaW5nIHVuZGVyIHRoZSBkZWZhdWx0IGNsdXN0ZXIgaWNvbiAoZXNwZWNpYWxseSBpbXBvcnRhbnQgZm9yIENpcmNsZSBNYXJrZXJzKS5cclxuXHRcdFx0aWYgKGkgPCBjb3VudCkge1xyXG5cdFx0XHRcdHJlc1tpXSA9IG5ldyBMLlBvaW50KGNlbnRlclB0LnggKyBsZWdMZW5ndGggKiBNYXRoLmNvcyhhbmdsZSksIGNlbnRlclB0LnkgKyBsZWdMZW5ndGggKiBNYXRoLnNpbihhbmdsZSkpLl9yb3VuZCgpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGFuZ2xlICs9IHNlcGFyYXRpb24gLyBsZWdMZW5ndGggKyBpICogMC4wMDA1O1xyXG5cdFx0XHRsZWdMZW5ndGggKz0gbGVuZ3RoRmFjdG9yIC8gYW5nbGU7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcmVzO1xyXG5cdH0sXHJcblxyXG5cdF9ub2FuaW1hdGlvblVuc3BpZGVyZnk6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBncm91cCA9IHRoaXMuX2dyb3VwLFxyXG5cdFx0XHRtYXAgPSBncm91cC5fbWFwLFxyXG5cdFx0XHRmZyA9IGdyb3VwLl9mZWF0dXJlR3JvdXAsXHJcblx0XHRcdGNoaWxkTWFya2VycyA9IHRoaXMuZ2V0QWxsQ2hpbGRNYXJrZXJzKG51bGwsIHRydWUpLFxyXG5cdFx0XHRtLCBpO1xyXG5cclxuXHRcdGdyb3VwLl9pZ25vcmVNb3ZlID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLnNldE9wYWNpdHkoMSk7XHJcblx0XHRmb3IgKGkgPSBjaGlsZE1hcmtlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuXHRcdFx0bSA9IGNoaWxkTWFya2Vyc1tpXTtcclxuXHJcblx0XHRcdGZnLnJlbW92ZUxheWVyKG0pO1xyXG5cclxuXHRcdFx0aWYgKG0uX3ByZVNwaWRlcmZ5TGF0bG5nKSB7XHJcblx0XHRcdFx0bS5zZXRMYXRMbmcobS5fcHJlU3BpZGVyZnlMYXRsbmcpO1xyXG5cdFx0XHRcdGRlbGV0ZSBtLl9wcmVTcGlkZXJmeUxhdGxuZztcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAobS5zZXRaSW5kZXhPZmZzZXQpIHtcclxuXHRcdFx0XHRtLnNldFpJbmRleE9mZnNldCgwKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKG0uX3NwaWRlckxlZykge1xyXG5cdFx0XHRcdG1hcC5yZW1vdmVMYXllcihtLl9zcGlkZXJMZWcpO1xyXG5cdFx0XHRcdGRlbGV0ZSBtLl9zcGlkZXJMZWc7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRncm91cC5maXJlKCd1bnNwaWRlcmZpZWQnLCB7XHJcblx0XHRcdGNsdXN0ZXI6IHRoaXMsXHJcblx0XHRcdG1hcmtlcnM6IGNoaWxkTWFya2Vyc1xyXG5cdFx0fSk7XHJcblx0XHRncm91cC5faWdub3JlTW92ZSA9IGZhbHNlO1xyXG5cdFx0Z3JvdXAuX3NwaWRlcmZpZWQgPSBudWxsO1xyXG5cdH1cclxufSk7XHJcblxyXG4vL05vbiBBbmltYXRlZCB2ZXJzaW9ucyBvZiBldmVyeXRoaW5nXHJcbkwuTWFya2VyQ2x1c3Rlck5vbkFuaW1hdGVkID0gTC5NYXJrZXJDbHVzdGVyLmV4dGVuZCh7XHJcblx0X2FuaW1hdGlvblNwaWRlcmZ5OiBmdW5jdGlvbiAoY2hpbGRNYXJrZXJzLCBwb3NpdGlvbnMpIHtcclxuXHRcdHZhciBncm91cCA9IHRoaXMuX2dyb3VwLFxyXG5cdFx0XHRtYXAgPSBncm91cC5fbWFwLFxyXG5cdFx0XHRmZyA9IGdyb3VwLl9mZWF0dXJlR3JvdXAsXHJcblx0XHRcdGxlZ09wdGlvbnMgPSB0aGlzLl9ncm91cC5vcHRpb25zLnNwaWRlckxlZ1BvbHlsaW5lT3B0aW9ucyxcclxuXHRcdFx0aSwgbSwgbGVnLCBuZXdQb3M7XHJcblxyXG5cdFx0Z3JvdXAuX2lnbm9yZU1vdmUgPSB0cnVlO1xyXG5cclxuXHRcdC8vIFRyYXZlcnNlIGluIGFzY2VuZGluZyBvcmRlciB0byBtYWtlIHN1cmUgdGhhdCBpbm5lciBjaXJjbGVNYXJrZXJzIGFyZSBvbiB0b3Agb2YgZnVydGhlciBsZWdzLiBOb3JtYWwgbWFya2VycyBhcmUgcmUtb3JkZXJlZCBieSBuZXdQb3NpdGlvbi5cclxuXHRcdC8vIFRoZSByZXZlcnNlIG9yZGVyIHRyaWNrIG5vIGxvbmdlciBpbXByb3ZlcyBwZXJmb3JtYW5jZSBvbiBtb2Rlcm4gYnJvd3NlcnMuXHJcblx0XHRmb3IgKGkgPSAwOyBpIDwgY2hpbGRNYXJrZXJzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdG5ld1BvcyA9IG1hcC5sYXllclBvaW50VG9MYXRMbmcocG9zaXRpb25zW2ldKTtcclxuXHRcdFx0bSA9IGNoaWxkTWFya2Vyc1tpXTtcclxuXHJcblx0XHRcdC8vIEFkZCB0aGUgbGVnIGJlZm9yZSB0aGUgbWFya2VyLCBzbyB0aGF0IGluIGNhc2UgdGhlIGxhdHRlciBpcyBhIGNpcmNsZU1hcmtlciwgdGhlIGxlZyBpcyBiZWhpbmQgaXQuXHJcblx0XHRcdGxlZyA9IG5ldyBMLlBvbHlsaW5lKFt0aGlzLl9sYXRsbmcsIG5ld1Bvc10sIGxlZ09wdGlvbnMpO1xyXG5cdFx0XHRtYXAuYWRkTGF5ZXIobGVnKTtcclxuXHRcdFx0bS5fc3BpZGVyTGVnID0gbGVnO1xyXG5cclxuXHRcdFx0Ly8gTm93IGFkZCB0aGUgbWFya2VyLlxyXG5cdFx0XHRtLl9wcmVTcGlkZXJmeUxhdGxuZyA9IG0uX2xhdGxuZztcclxuXHRcdFx0bS5zZXRMYXRMbmcobmV3UG9zKTtcclxuXHRcdFx0aWYgKG0uc2V0WkluZGV4T2Zmc2V0KSB7XHJcblx0XHRcdFx0bS5zZXRaSW5kZXhPZmZzZXQoMTAwMDAwMCk7IC8vTWFrZSB0aGVzZSBhcHBlYXIgb24gdG9wIG9mIEVWRVJZVEhJTkdcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0ZmcuYWRkTGF5ZXIobSk7XHJcblx0XHR9XHJcblx0XHR0aGlzLnNldE9wYWNpdHkoMC4zKTtcclxuXHJcblx0XHRncm91cC5faWdub3JlTW92ZSA9IGZhbHNlO1xyXG5cdFx0Z3JvdXAuZmlyZSgnc3BpZGVyZmllZCcsIHtcclxuXHRcdFx0Y2x1c3RlcjogdGhpcyxcclxuXHRcdFx0bWFya2VyczogY2hpbGRNYXJrZXJzXHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHRfYW5pbWF0aW9uVW5zcGlkZXJmeTogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fbm9hbmltYXRpb25VbnNwaWRlcmZ5KCk7XHJcblx0fVxyXG59KTtcclxuXHJcbi8vQW5pbWF0ZWQgdmVyc2lvbnMgaGVyZVxyXG5MLk1hcmtlckNsdXN0ZXIuaW5jbHVkZSh7XHJcblxyXG5cdF9hbmltYXRpb25TcGlkZXJmeTogZnVuY3Rpb24gKGNoaWxkTWFya2VycywgcG9zaXRpb25zKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzLFxyXG5cdFx0XHRncm91cCA9IHRoaXMuX2dyb3VwLFxyXG5cdFx0XHRtYXAgPSBncm91cC5fbWFwLFxyXG5cdFx0XHRmZyA9IGdyb3VwLl9mZWF0dXJlR3JvdXAsXHJcblx0XHRcdHRoaXNMYXllckxhdExuZyA9IHRoaXMuX2xhdGxuZyxcclxuXHRcdFx0dGhpc0xheWVyUG9zID0gbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzTGF5ZXJMYXRMbmcpLFxyXG5cdFx0XHRzdmcgPSBMLlBhdGguU1ZHLFxyXG5cdFx0XHRsZWdPcHRpb25zID0gTC5leHRlbmQoe30sIHRoaXMuX2dyb3VwLm9wdGlvbnMuc3BpZGVyTGVnUG9seWxpbmVPcHRpb25zKSwgLy8gQ29weSB0aGUgb3B0aW9ucyBzbyB0aGF0IHdlIGNhbiBtb2RpZnkgdGhlbSBmb3IgYW5pbWF0aW9uLlxyXG5cdFx0XHRmaW5hbExlZ09wYWNpdHkgPSBsZWdPcHRpb25zLm9wYWNpdHksXHJcblx0XHRcdGksIG0sIGxlZywgbGVnUGF0aCwgbGVnTGVuZ3RoLCBuZXdQb3M7XHJcblxyXG5cdFx0aWYgKGZpbmFsTGVnT3BhY2l0eSA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdGZpbmFsTGVnT3BhY2l0eSA9IEwuTWFya2VyQ2x1c3Rlckdyb3VwLnByb3RvdHlwZS5vcHRpb25zLnNwaWRlckxlZ1BvbHlsaW5lT3B0aW9ucy5vcGFjaXR5O1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChzdmcpIHtcclxuXHRcdFx0Ly8gSWYgdGhlIGluaXRpYWwgb3BhY2l0eSBvZiB0aGUgc3BpZGVyIGxlZyBpcyBub3QgMCB0aGVuIGl0IGFwcGVhcnMgYmVmb3JlIHRoZSBhbmltYXRpb24gc3RhcnRzLlxyXG5cdFx0XHRsZWdPcHRpb25zLm9wYWNpdHkgPSAwO1xyXG5cclxuXHRcdFx0Ly8gQWRkIHRoZSBjbGFzcyBmb3IgQ1NTIHRyYW5zaXRpb25zLlxyXG5cdFx0XHRsZWdPcHRpb25zLmNsYXNzTmFtZSA9IChsZWdPcHRpb25zLmNsYXNzTmFtZSB8fCAnJykgKyAnIGxlYWZsZXQtY2x1c3Rlci1zcGlkZXItbGVnJztcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8vIE1ha2Ugc3VyZSB3ZSBoYXZlIGEgZGVmaW5lZCBvcGFjaXR5LlxyXG5cdFx0XHRsZWdPcHRpb25zLm9wYWNpdHkgPSBmaW5hbExlZ09wYWNpdHk7XHJcblx0XHR9XHJcblxyXG5cdFx0Z3JvdXAuX2lnbm9yZU1vdmUgPSB0cnVlO1xyXG5cclxuXHRcdC8vIEFkZCBtYXJrZXJzIGFuZCBzcGlkZXIgbGVncyB0byBtYXAsIGhpZGRlbiBhdCBvdXIgY2VudGVyIHBvaW50LlxyXG5cdFx0Ly8gVHJhdmVyc2UgaW4gYXNjZW5kaW5nIG9yZGVyIHRvIG1ha2Ugc3VyZSB0aGF0IGlubmVyIGNpcmNsZU1hcmtlcnMgYXJlIG9uIHRvcCBvZiBmdXJ0aGVyIGxlZ3MuIE5vcm1hbCBtYXJrZXJzIGFyZSByZS1vcmRlcmVkIGJ5IG5ld1Bvc2l0aW9uLlxyXG5cdFx0Ly8gVGhlIHJldmVyc2Ugb3JkZXIgdHJpY2sgbm8gbG9uZ2VyIGltcHJvdmVzIHBlcmZvcm1hbmNlIG9uIG1vZGVybiBicm93c2Vycy5cclxuXHRcdGZvciAoaSA9IDA7IGkgPCBjaGlsZE1hcmtlcnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0bSA9IGNoaWxkTWFya2Vyc1tpXTtcclxuXHJcblx0XHRcdG5ld1BvcyA9IG1hcC5sYXllclBvaW50VG9MYXRMbmcocG9zaXRpb25zW2ldKTtcclxuXHJcblx0XHRcdC8vIEFkZCB0aGUgbGVnIGJlZm9yZSB0aGUgbWFya2VyLCBzbyB0aGF0IGluIGNhc2UgdGhlIGxhdHRlciBpcyBhIGNpcmNsZU1hcmtlciwgdGhlIGxlZyBpcyBiZWhpbmQgaXQuXHJcblx0XHRcdGxlZyA9IG5ldyBMLlBvbHlsaW5lKFt0aGlzTGF5ZXJMYXRMbmcsIG5ld1Bvc10sIGxlZ09wdGlvbnMpO1xyXG5cdFx0XHRtYXAuYWRkTGF5ZXIobGVnKTtcclxuXHRcdFx0bS5fc3BpZGVyTGVnID0gbGVnO1xyXG5cclxuXHRcdFx0Ly8gRXhwbGFuYXRpb25zOiBodHRwczovL2pha2VhcmNoaWJhbGQuY29tLzIwMTMvYW5pbWF0ZWQtbGluZS1kcmF3aW5nLXN2Zy9cclxuXHRcdFx0Ly8gSW4gb3VyIGNhc2UgdGhlIHRyYW5zaXRpb24gcHJvcGVydHkgaXMgZGVjbGFyZWQgaW4gdGhlIENTUyBmaWxlLlxyXG5cdFx0XHRpZiAoc3ZnKSB7XHJcblx0XHRcdFx0bGVnUGF0aCA9IGxlZy5fcGF0aDtcclxuXHRcdFx0XHRsZWdMZW5ndGggPSBsZWdQYXRoLmdldFRvdGFsTGVuZ3RoKCkgKyAwLjE7IC8vIE5lZWQgYSBzbWFsbCBleHRyYSBsZW5ndGggdG8gYXZvaWQgcmVtYWluaW5nIGRvdCBpbiBGaXJlZm94LlxyXG5cdFx0XHRcdGxlZ1BhdGguc3R5bGUuc3Ryb2tlRGFzaGFycmF5ID0gbGVnTGVuZ3RoOyAvLyBKdXN0IDEgbGVuZ3RoIGlzIGVub3VnaCwgaXQgd2lsbCBiZSBkdXBsaWNhdGVkLlxyXG5cdFx0XHRcdGxlZ1BhdGguc3R5bGUuc3Ryb2tlRGFzaG9mZnNldCA9IGxlZ0xlbmd0aDtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gSWYgaXQgaXMgYSBtYXJrZXIsIGFkZCBpdCBub3cgYW5kIHdlJ2xsIGFuaW1hdGUgaXQgb3V0XHJcblx0XHRcdGlmIChtLnNldFpJbmRleE9mZnNldCkge1xyXG5cdFx0XHRcdG0uc2V0WkluZGV4T2Zmc2V0KDEwMDAwMDApOyAvLyBNYWtlIG5vcm1hbCBtYXJrZXJzIGFwcGVhciBvbiB0b3Agb2YgRVZFUllUSElOR1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChtLmNsdXN0ZXJIaWRlKSB7XHJcblx0XHRcdFx0bS5jbHVzdGVySGlkZSgpO1xyXG5cdFx0XHR9XHJcblx0XHRcdFxyXG5cdFx0XHQvLyBWZWN0b3JzIGp1c3QgZ2V0IGltbWVkaWF0ZWx5IGFkZGVkXHJcblx0XHRcdGZnLmFkZExheWVyKG0pO1xyXG5cclxuXHRcdFx0aWYgKG0uX3NldFBvcykge1xyXG5cdFx0XHRcdG0uX3NldFBvcyh0aGlzTGF5ZXJQb3MpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Z3JvdXAuX2ZvcmNlTGF5b3V0KCk7XHJcblx0XHRncm91cC5fYW5pbWF0aW9uU3RhcnQoKTtcclxuXHJcblx0XHQvLyBSZXZlYWwgbWFya2VycyBhbmQgc3BpZGVyIGxlZ3MuXHJcblx0XHRmb3IgKGkgPSBjaGlsZE1hcmtlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuXHRcdFx0bmV3UG9zID0gbWFwLmxheWVyUG9pbnRUb0xhdExuZyhwb3NpdGlvbnNbaV0pO1xyXG5cdFx0XHRtID0gY2hpbGRNYXJrZXJzW2ldO1xyXG5cclxuXHRcdFx0Ly9Nb3ZlIG1hcmtlciB0byBuZXcgcG9zaXRpb25cclxuXHRcdFx0bS5fcHJlU3BpZGVyZnlMYXRsbmcgPSBtLl9sYXRsbmc7XHJcblx0XHRcdG0uc2V0TGF0TG5nKG5ld1Bvcyk7XHJcblx0XHRcdFxyXG5cdFx0XHRpZiAobS5jbHVzdGVyU2hvdykge1xyXG5cdFx0XHRcdG0uY2x1c3RlclNob3coKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gQW5pbWF0ZSBsZWcgKGFuaW1hdGlvbiBpcyBhY3R1YWxseSBkZWxlZ2F0ZWQgdG8gQ1NTIHRyYW5zaXRpb24pLlxyXG5cdFx0XHRpZiAoc3ZnKSB7XHJcblx0XHRcdFx0bGVnID0gbS5fc3BpZGVyTGVnO1xyXG5cdFx0XHRcdGxlZ1BhdGggPSBsZWcuX3BhdGg7XHJcblx0XHRcdFx0bGVnUGF0aC5zdHlsZS5zdHJva2VEYXNob2Zmc2V0ID0gMDtcclxuXHRcdFx0XHQvL2xlZ1BhdGguc3R5bGUuc3Ryb2tlT3BhY2l0eSA9IGZpbmFsTGVnT3BhY2l0eTtcclxuXHRcdFx0XHRsZWcuc2V0U3R5bGUoe29wYWNpdHk6IGZpbmFsTGVnT3BhY2l0eX0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHR0aGlzLnNldE9wYWNpdHkoMC4zKTtcclxuXHJcblx0XHRncm91cC5faWdub3JlTW92ZSA9IGZhbHNlO1xyXG5cclxuXHRcdHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRncm91cC5fYW5pbWF0aW9uRW5kKCk7XHJcblx0XHRcdGdyb3VwLmZpcmUoJ3NwaWRlcmZpZWQnLCB7XHJcblx0XHRcdFx0Y2x1c3RlcjogbWUsXHJcblx0XHRcdFx0bWFya2VyczogY2hpbGRNYXJrZXJzXHJcblx0XHRcdH0pO1xyXG5cdFx0fSwgMjAwKTtcclxuXHR9LFxyXG5cclxuXHRfYW5pbWF0aW9uVW5zcGlkZXJmeTogZnVuY3Rpb24gKHpvb21EZXRhaWxzKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzLFxyXG5cdFx0XHRncm91cCA9IHRoaXMuX2dyb3VwLFxyXG5cdFx0XHRtYXAgPSBncm91cC5fbWFwLFxyXG5cdFx0XHRmZyA9IGdyb3VwLl9mZWF0dXJlR3JvdXAsXHJcblx0XHRcdHRoaXNMYXllclBvcyA9IHpvb21EZXRhaWxzID8gbWFwLl9sYXRMbmdUb05ld0xheWVyUG9pbnQodGhpcy5fbGF0bG5nLCB6b29tRGV0YWlscy56b29tLCB6b29tRGV0YWlscy5jZW50ZXIpIDogbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcpLFxyXG5cdFx0XHRjaGlsZE1hcmtlcnMgPSB0aGlzLmdldEFsbENoaWxkTWFya2VycyhudWxsLCB0cnVlKSxcclxuXHRcdFx0c3ZnID0gTC5QYXRoLlNWRyxcclxuXHRcdFx0bSwgaSwgbGVnLCBsZWdQYXRoLCBsZWdMZW5ndGgsIG5vbkFuaW1hdGFibGU7XHJcblxyXG5cdFx0Z3JvdXAuX2lnbm9yZU1vdmUgPSB0cnVlO1xyXG5cdFx0Z3JvdXAuX2FuaW1hdGlvblN0YXJ0KCk7XHJcblxyXG5cdFx0Ly9NYWtlIHVzIHZpc2libGUgYW5kIGJyaW5nIHRoZSBjaGlsZCBtYXJrZXJzIGJhY2sgaW5cclxuXHRcdHRoaXMuc2V0T3BhY2l0eSgxKTtcclxuXHRcdGZvciAoaSA9IGNoaWxkTWFya2Vycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG5cdFx0XHRtID0gY2hpbGRNYXJrZXJzW2ldO1xyXG5cclxuXHRcdFx0Ly9NYXJrZXIgd2FzIGFkZGVkIHRvIHVzIGFmdGVyIHdlIHdlcmUgc3BpZGVyZmllZFxyXG5cdFx0XHRpZiAoIW0uX3ByZVNwaWRlcmZ5TGF0bG5nKSB7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vQ2xvc2UgYW55IHBvcHVwIG9uIHRoZSBtYXJrZXIgZmlyc3QsIG90aGVyd2lzZSBzZXR0aW5nIHRoZSBsb2NhdGlvbiBvZiB0aGUgbWFya2VyIHdpbGwgbWFrZSB0aGUgbWFwIHNjcm9sbFxyXG5cdFx0XHRtLmNsb3NlUG9wdXAoKTtcclxuXHJcblx0XHRcdC8vRml4IHVwIHRoZSBsb2NhdGlvbiB0byB0aGUgcmVhbCBvbmVcclxuXHRcdFx0bS5zZXRMYXRMbmcobS5fcHJlU3BpZGVyZnlMYXRsbmcpO1xyXG5cdFx0XHRkZWxldGUgbS5fcHJlU3BpZGVyZnlMYXRsbmc7XHJcblxyXG5cdFx0XHQvL0hhY2sgb3ZlcnJpZGUgdGhlIGxvY2F0aW9uIHRvIGJlIG91ciBjZW50ZXJcclxuXHRcdFx0bm9uQW5pbWF0YWJsZSA9IHRydWU7XHJcblx0XHRcdGlmIChtLl9zZXRQb3MpIHtcclxuXHRcdFx0XHRtLl9zZXRQb3ModGhpc0xheWVyUG9zKTtcclxuXHRcdFx0XHRub25BbmltYXRhYmxlID0gZmFsc2U7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKG0uY2x1c3RlckhpZGUpIHtcclxuXHRcdFx0XHRtLmNsdXN0ZXJIaWRlKCk7XHJcblx0XHRcdFx0bm9uQW5pbWF0YWJsZSA9IGZhbHNlO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChub25BbmltYXRhYmxlKSB7XHJcblx0XHRcdFx0ZmcucmVtb3ZlTGF5ZXIobSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIEFuaW1hdGUgdGhlIHNwaWRlciBsZWcgYmFjayBpbiAoYW5pbWF0aW9uIGlzIGFjdHVhbGx5IGRlbGVnYXRlZCB0byBDU1MgdHJhbnNpdGlvbikuXHJcblx0XHRcdGlmIChzdmcpIHtcclxuXHRcdFx0XHRsZWcgPSBtLl9zcGlkZXJMZWc7XHJcblx0XHRcdFx0bGVnUGF0aCA9IGxlZy5fcGF0aDtcclxuXHRcdFx0XHRsZWdMZW5ndGggPSBsZWdQYXRoLmdldFRvdGFsTGVuZ3RoKCkgKyAwLjE7XHJcblx0XHRcdFx0bGVnUGF0aC5zdHlsZS5zdHJva2VEYXNob2Zmc2V0ID0gbGVnTGVuZ3RoO1xyXG5cdFx0XHRcdGxlZy5zZXRTdHlsZSh7b3BhY2l0eTogMH0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Z3JvdXAuX2lnbm9yZU1vdmUgPSBmYWxzZTtcclxuXHJcblx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0Ly9JZiB3ZSBoYXZlIG9ubHkgPD0gb25lIGNoaWxkIGxlZnQgdGhlbiB0aGF0IG1hcmtlciB3aWxsIGJlIHNob3duIG9uIHRoZSBtYXAgc28gZG9uJ3QgcmVtb3ZlIGl0IVxyXG5cdFx0XHR2YXIgc3RpbGxUaGVyZUNoaWxkQ291bnQgPSAwO1xyXG5cdFx0XHRmb3IgKGkgPSBjaGlsZE1hcmtlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuXHRcdFx0XHRtID0gY2hpbGRNYXJrZXJzW2ldO1xyXG5cdFx0XHRcdGlmIChtLl9zcGlkZXJMZWcpIHtcclxuXHRcdFx0XHRcdHN0aWxsVGhlcmVDaGlsZENvdW50Kys7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cclxuXHRcdFx0Zm9yIChpID0gY2hpbGRNYXJrZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdFx0bSA9IGNoaWxkTWFya2Vyc1tpXTtcclxuXHJcblx0XHRcdFx0aWYgKCFtLl9zcGlkZXJMZWcpIHsgLy9IYXMgYWxyZWFkeSBiZWVuIHVuc3BpZGVyZmllZFxyXG5cdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAobS5jbHVzdGVyU2hvdykge1xyXG5cdFx0XHRcdFx0bS5jbHVzdGVyU2hvdygpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAobS5zZXRaSW5kZXhPZmZzZXQpIHtcclxuXHRcdFx0XHRcdG0uc2V0WkluZGV4T2Zmc2V0KDApO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKHN0aWxsVGhlcmVDaGlsZENvdW50ID4gMSkge1xyXG5cdFx0XHRcdFx0ZmcucmVtb3ZlTGF5ZXIobSk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRtYXAucmVtb3ZlTGF5ZXIobS5fc3BpZGVyTGVnKTtcclxuXHRcdFx0XHRkZWxldGUgbS5fc3BpZGVyTGVnO1xyXG5cdFx0XHR9XHJcblx0XHRcdGdyb3VwLl9hbmltYXRpb25FbmQoKTtcclxuXHRcdFx0Z3JvdXAuZmlyZSgndW5zcGlkZXJmaWVkJywge1xyXG5cdFx0XHRcdGNsdXN0ZXI6IG1lLFxyXG5cdFx0XHRcdG1hcmtlcnM6IGNoaWxkTWFya2Vyc1xyXG5cdFx0XHR9KTtcclxuXHRcdH0sIDIwMCk7XHJcblx0fVxyXG59KTtcclxuXHJcblxyXG5MLk1hcmtlckNsdXN0ZXJHcm91cC5pbmNsdWRlKHtcclxuXHQvL1RoZSBNYXJrZXJDbHVzdGVyIGN1cnJlbnRseSBzcGlkZXJmaWVkIChpZiBhbnkpXHJcblx0X3NwaWRlcmZpZWQ6IG51bGwsXHJcblxyXG5cdHVuc3BpZGVyZnk6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX3Vuc3BpZGVyZnkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuXHR9LFxyXG5cclxuXHRfc3BpZGVyZmllck9uQWRkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl9tYXAub24oJ2NsaWNrJywgdGhpcy5fdW5zcGlkZXJmeVdyYXBwZXIsIHRoaXMpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9tYXAub3B0aW9ucy56b29tQW5pbWF0aW9uKSB7XHJcblx0XHRcdHRoaXMuX21hcC5vbignem9vbXN0YXJ0JywgdGhpcy5fdW5zcGlkZXJmeVpvb21TdGFydCwgdGhpcyk7XHJcblx0XHR9XHJcblx0XHQvL0Jyb3dzZXJzIHdpdGhvdXQgem9vbUFuaW1hdGlvbiBvciBhIGJpZyB6b29tIGRvbid0IGZpcmUgem9vbXN0YXJ0XHJcblx0XHR0aGlzLl9tYXAub24oJ3pvb21lbmQnLCB0aGlzLl9ub2FuaW1hdGlvblVuc3BpZGVyZnksIHRoaXMpO1xyXG5cclxuXHRcdGlmICghTC5Ccm93c2VyLnRvdWNoKSB7XHJcblx0XHRcdHRoaXMuX21hcC5nZXRSZW5kZXJlcih0aGlzKTtcclxuXHRcdFx0Ly9OZWVkcyB0byBoYXBwZW4gaW4gdGhlIHBhZ2Vsb2FkLCBub3QgYWZ0ZXIsIG9yIGFuaW1hdGlvbnMgZG9uJ3Qgd29yayBpbiB3ZWJraXRcclxuXHRcdFx0Ly8gIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvODQ1NTIwMC9zdmctYW5pbWF0ZS13aXRoLWR5bmFtaWNhbGx5LWFkZGVkLWVsZW1lbnRzXHJcblx0XHRcdC8vRGlzYWJsZSBvbiB0b3VjaCBicm93c2VycyBhcyB0aGUgYW5pbWF0aW9uIG1lc3NlcyB1cCBvbiBhIHRvdWNoIHpvb20gYW5kIGlzbid0IHZlcnkgbm90aWNhYmxlXHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3NwaWRlcmZpZXJPblJlbW92ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fbWFwLm9mZignY2xpY2snLCB0aGlzLl91bnNwaWRlcmZ5V3JhcHBlciwgdGhpcyk7XHJcblx0XHR0aGlzLl9tYXAub2ZmKCd6b29tc3RhcnQnLCB0aGlzLl91bnNwaWRlcmZ5Wm9vbVN0YXJ0LCB0aGlzKTtcclxuXHRcdHRoaXMuX21hcC5vZmYoJ3pvb21hbmltJywgdGhpcy5fdW5zcGlkZXJmeVpvb21BbmltLCB0aGlzKTtcclxuXHRcdHRoaXMuX21hcC5vZmYoJ3pvb21lbmQnLCB0aGlzLl9ub2FuaW1hdGlvblVuc3BpZGVyZnksIHRoaXMpO1xyXG5cclxuXHRcdC8vRW5zdXJlIHRoYXQgbWFya2VycyBhcmUgYmFjayB3aGVyZSB0aGV5IHNob3VsZCBiZVxyXG5cdFx0Ly8gVXNlIG5vIGFuaW1hdGlvbiB0byBhdm9pZCBhIHN0aWNreSBsZWFmbGV0LWNsdXN0ZXItYW5pbSBjbGFzcyBvbiBtYXBQYW5lXHJcblx0XHR0aGlzLl9ub2FuaW1hdGlvblVuc3BpZGVyZnkoKTtcclxuXHR9LFxyXG5cclxuXHQvL09uIHpvb20gc3RhcnQgd2UgYWRkIGEgem9vbWFuaW0gaGFuZGxlciBzbyB0aGF0IHdlIGFyZSBndWFyYW50ZWVkIHRvIGJlIGxhc3QgKGFmdGVyIG1hcmtlcnMgYXJlIGFuaW1hdGVkKVxyXG5cdC8vVGhpcyBtZWFucyB3ZSBjYW4gZGVmaW5lIHRoZSBhbmltYXRpb24gdGhleSBkbyByYXRoZXIgdGhhbiBNYXJrZXJzIGRvaW5nIGFuIGFuaW1hdGlvbiB0byB0aGVpciBhY3R1YWwgbG9jYXRpb25cclxuXHRfdW5zcGlkZXJmeVpvb21TdGFydDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9tYXApIHsgLy9NYXkgaGF2ZSBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgbWFwIGJ5IGEgem9vbUVuZCBoYW5kbGVyXHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9tYXAub24oJ3pvb21hbmltJywgdGhpcy5fdW5zcGlkZXJmeVpvb21BbmltLCB0aGlzKTtcclxuXHR9LFxyXG5cclxuXHRfdW5zcGlkZXJmeVpvb21BbmltOiBmdW5jdGlvbiAoem9vbURldGFpbHMpIHtcclxuXHRcdC8vV2FpdCB1bnRpbCB0aGUgZmlyc3Qgem9vbWFuaW0gYWZ0ZXIgdGhlIHVzZXIgaGFzIGZpbmlzaGVkIHRvdWNoLXpvb21pbmcgYmVmb3JlIHJ1bm5pbmcgdGhlIGFuaW1hdGlvblxyXG5cdFx0aWYgKEwuRG9tVXRpbC5oYXNDbGFzcyh0aGlzLl9tYXAuX21hcFBhbmUsICdsZWFmbGV0LXRvdWNoaW5nJykpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX21hcC5vZmYoJ3pvb21hbmltJywgdGhpcy5fdW5zcGlkZXJmeVpvb21BbmltLCB0aGlzKTtcclxuXHRcdHRoaXMuX3Vuc3BpZGVyZnkoem9vbURldGFpbHMpO1xyXG5cdH0sXHJcblxyXG5cdF91bnNwaWRlcmZ5V3JhcHBlcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0Ly8vIDxzdW1tYXJ5Pl91bnNwaWRlcmZ5IGJ1dCBwYXNzZXMgbm8gYXJndW1lbnRzPC9zdW1tYXJ5PlxyXG5cdFx0dGhpcy5fdW5zcGlkZXJmeSgpO1xyXG5cdH0sXHJcblxyXG5cdF91bnNwaWRlcmZ5OiBmdW5jdGlvbiAoem9vbURldGFpbHMpIHtcclxuXHRcdGlmICh0aGlzLl9zcGlkZXJmaWVkKSB7XHJcblx0XHRcdHRoaXMuX3NwaWRlcmZpZWQudW5zcGlkZXJmeSh6b29tRGV0YWlscyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X25vYW5pbWF0aW9uVW5zcGlkZXJmeTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX3NwaWRlcmZpZWQpIHtcclxuXHRcdFx0dGhpcy5fc3BpZGVyZmllZC5fbm9hbmltYXRpb25VbnNwaWRlcmZ5KCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly9JZiB0aGUgZ2l2ZW4gbGF5ZXIgaXMgY3VycmVudGx5IGJlaW5nIHNwaWRlcmZpZWQgdGhlbiB3ZSB1bnNwaWRlcmZ5IGl0IHNvIGl0IGlzbid0IG9uIHRoZSBtYXAgYW55bW9yZSBldGNcclxuXHRfdW5zcGlkZXJmeUxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdGlmIChsYXllci5fc3BpZGVyTGVnKSB7XHJcblx0XHRcdHRoaXMuX2ZlYXR1cmVHcm91cC5yZW1vdmVMYXllcihsYXllcik7XHJcblxyXG5cdFx0XHRpZiAobGF5ZXIuY2x1c3RlclNob3cpIHtcclxuXHRcdFx0XHRsYXllci5jbHVzdGVyU2hvdygpO1xyXG5cdFx0XHR9XHJcblx0XHRcdFx0Ly9Qb3NpdGlvbiB3aWxsIGJlIGZpeGVkIHVwIGltbWVkaWF0ZWx5IGluIF9hbmltYXRpb25VbnNwaWRlcmZ5XHJcblx0XHRcdGlmIChsYXllci5zZXRaSW5kZXhPZmZzZXQpIHtcclxuXHRcdFx0XHRsYXllci5zZXRaSW5kZXhPZmZzZXQoMCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuX21hcC5yZW1vdmVMYXllcihsYXllci5fc3BpZGVyTGVnKTtcclxuXHRcdFx0ZGVsZXRlIGxheWVyLl9zcGlkZXJMZWc7XHJcblx0XHR9XHJcblx0fVxyXG59KTtcblxuLyoqXHJcbiAqIEFkZHMgMSBwdWJsaWMgbWV0aG9kIHRvIE1DRyBhbmQgMSB0byBMLk1hcmtlciB0byBmYWNpbGl0YXRlIGNoYW5naW5nXHJcbiAqIG1hcmtlcnMnIGljb24gb3B0aW9ucyBhbmQgcmVmcmVzaGluZyB0aGVpciBpY29uIGFuZCB0aGVpciBwYXJlbnQgY2x1c3RlcnNcclxuICogYWNjb3JkaW5nbHkgKGNhc2Ugd2hlcmUgdGhlaXIgaWNvbkNyZWF0ZUZ1bmN0aW9uIHVzZXMgZGF0YSBvZiBjaGlsZE1hcmtlcnNcclxuICogdG8gbWFrZSB1cCB0aGUgY2x1c3RlciBpY29uKS5cclxuICovXHJcblxyXG5cclxuTC5NYXJrZXJDbHVzdGVyR3JvdXAuaW5jbHVkZSh7XHJcblx0LyoqXHJcblx0ICogVXBkYXRlcyB0aGUgaWNvbiBvZiBhbGwgY2x1c3RlcnMgd2hpY2ggYXJlIHBhcmVudHMgb2YgdGhlIGdpdmVuIG1hcmtlcihzKS5cclxuXHQgKiBJbiBzaW5nbGVNYXJrZXJNb2RlLCBhbHNvIHVwZGF0ZXMgdGhlIGdpdmVuIG1hcmtlcihzKSBpY29uLlxyXG5cdCAqIEBwYXJhbSBsYXllcnMgTC5NYXJrZXJDbHVzdGVyR3JvdXB8TC5MYXllckdyb3VwfEFycmF5KEwuTWFya2VyKXxNYXAoTC5NYXJrZXIpfFxyXG5cdCAqIEwuTWFya2VyQ2x1c3RlcnxMLk1hcmtlciAob3B0aW9uYWwpIGxpc3Qgb2YgbWFya2VycyAob3Igc2luZ2xlIG1hcmtlcikgd2hvc2UgcGFyZW50XHJcblx0ICogY2x1c3RlcnMgbmVlZCB0byBiZSB1cGRhdGVkLiBJZiBub3QgcHJvdmlkZWQsIHJldHJpZXZlcyBhbGwgY2hpbGQgbWFya2VycyBvZiB0aGlzLlxyXG5cdCAqIEByZXR1cm5zIHtMLk1hcmtlckNsdXN0ZXJHcm91cH1cclxuXHQgKi9cclxuXHRyZWZyZXNoQ2x1c3RlcnM6IGZ1bmN0aW9uIChsYXllcnMpIHtcclxuXHRcdGlmICghbGF5ZXJzKSB7XHJcblx0XHRcdGxheWVycyA9IHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5nZXRBbGxDaGlsZE1hcmtlcnMoKTtcclxuXHRcdH0gZWxzZSBpZiAobGF5ZXJzIGluc3RhbmNlb2YgTC5NYXJrZXJDbHVzdGVyR3JvdXApIHtcclxuXHRcdFx0bGF5ZXJzID0gbGF5ZXJzLl90b3BDbHVzdGVyTGV2ZWwuZ2V0QWxsQ2hpbGRNYXJrZXJzKCk7XHJcblx0XHR9IGVsc2UgaWYgKGxheWVycyBpbnN0YW5jZW9mIEwuTGF5ZXJHcm91cCkge1xyXG5cdFx0XHRsYXllcnMgPSBsYXllcnMuX2xheWVycztcclxuXHRcdH0gZWxzZSBpZiAobGF5ZXJzIGluc3RhbmNlb2YgTC5NYXJrZXJDbHVzdGVyKSB7XHJcblx0XHRcdGxheWVycyA9IGxheWVycy5nZXRBbGxDaGlsZE1hcmtlcnMoKTtcclxuXHRcdH0gZWxzZSBpZiAobGF5ZXJzIGluc3RhbmNlb2YgTC5NYXJrZXIpIHtcclxuXHRcdFx0bGF5ZXJzID0gW2xheWVyc107XHJcblx0XHR9IC8vIGVsc2U6IG11c3QgYmUgYW4gQXJyYXkoTC5NYXJrZXIpfE1hcChMLk1hcmtlcilcclxuXHRcdHRoaXMuX2ZsYWdQYXJlbnRzSWNvbnNOZWVkVXBkYXRlKGxheWVycyk7XHJcblx0XHR0aGlzLl9yZWZyZXNoQ2x1c3RlcnNJY29ucygpO1xyXG5cclxuXHRcdC8vIEluIGNhc2Ugb2Ygc2luZ2xlTWFya2VyTW9kZSwgYWxzbyByZS1kcmF3IHRoZSBtYXJrZXJzLlxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5zaW5nbGVNYXJrZXJNb2RlKSB7XHJcblx0XHRcdHRoaXMuX3JlZnJlc2hTaW5nbGVNYXJrZXJNb2RlTWFya2VycyhsYXllcnMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNpbXBseSBmbGFncyBhbGwgcGFyZW50IGNsdXN0ZXJzIG9mIHRoZSBnaXZlbiBtYXJrZXJzIGFzIGhhdmluZyBhIFwiZGlydHlcIiBpY29uLlxyXG5cdCAqIEBwYXJhbSBsYXllcnMgQXJyYXkoTC5NYXJrZXIpfE1hcChMLk1hcmtlcikgbGlzdCBvZiBtYXJrZXJzLlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X2ZsYWdQYXJlbnRzSWNvbnNOZWVkVXBkYXRlOiBmdW5jdGlvbiAobGF5ZXJzKSB7XHJcblx0XHR2YXIgaWQsIHBhcmVudDtcclxuXHJcblx0XHQvLyBBc3N1bWVzIGxheWVycyBpcyBhbiBBcnJheSBvciBhbiBPYmplY3Qgd2hvc2UgcHJvdG90eXBlIGlzIG5vbi1lbnVtZXJhYmxlLlxyXG5cdFx0Zm9yIChpZCBpbiBsYXllcnMpIHtcclxuXHRcdFx0Ly8gRmxhZyBwYXJlbnQgY2x1c3RlcnMnIGljb24gYXMgXCJkaXJ0eVwiLCBhbGwgdGhlIHdheSB1cC5cclxuXHRcdFx0Ly8gRHVtYiBwcm9jZXNzIHRoYXQgZmxhZ3MgbXVsdGlwbGUgdGltZXMgdXBwZXIgcGFyZW50cywgYnV0IHN0aWxsXHJcblx0XHRcdC8vIG11Y2ggbW9yZSBlZmZpY2llbnQgdGhhbiB0cnlpbmcgdG8gYmUgc21hcnQgYW5kIG1ha2Ugc2hvcnQgbGlzdHMsXHJcblx0XHRcdC8vIGF0IGxlYXN0IGluIHRoZSBjYXNlIG9mIGEgaGllcmFyY2h5IGZvbGxvd2luZyBhIHBvd2VyIGxhdzpcclxuXHRcdFx0Ly8gaHR0cDovL2pzcGVyZi5jb20vZmxhZy1ub2Rlcy1pbi1wb3dlci1oaWVyYXJjaHkvMlxyXG5cdFx0XHRwYXJlbnQgPSBsYXllcnNbaWRdLl9fcGFyZW50O1xyXG5cdFx0XHR3aGlsZSAocGFyZW50KSB7XHJcblx0XHRcdFx0cGFyZW50Ll9pY29uTmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cdFx0XHRcdHBhcmVudCA9IHBhcmVudC5fX3BhcmVudDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlLWRyYXdzIHRoZSBpY29uIG9mIHRoZSBzdXBwbGllZCBtYXJrZXJzLlxyXG5cdCAqIFRvIGJlIHVzZWQgaW4gc2luZ2xlTWFya2VyTW9kZSBvbmx5LlxyXG5cdCAqIEBwYXJhbSBsYXllcnMgQXJyYXkoTC5NYXJrZXIpfE1hcChMLk1hcmtlcikgbGlzdCBvZiBtYXJrZXJzLlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X3JlZnJlc2hTaW5nbGVNYXJrZXJNb2RlTWFya2VyczogZnVuY3Rpb24gKGxheWVycykge1xyXG5cdFx0dmFyIGlkLCBsYXllcjtcclxuXHJcblx0XHRmb3IgKGlkIGluIGxheWVycykge1xyXG5cdFx0XHRsYXllciA9IGxheWVyc1tpZF07XHJcblxyXG5cdFx0XHQvLyBNYWtlIHN1cmUgd2UgZG8gbm90IG92ZXJyaWRlIG1hcmtlcnMgdGhhdCBkbyBub3QgYmVsb25nIHRvIFRISVMgZ3JvdXAuXHJcblx0XHRcdGlmICh0aGlzLmhhc0xheWVyKGxheWVyKSkge1xyXG5cdFx0XHRcdC8vIE5lZWQgdG8gcmUtY3JlYXRlIHRoZSBpY29uIGZpcnN0LCB0aGVuIHJlLWRyYXcgdGhlIG1hcmtlci5cclxuXHRcdFx0XHRsYXllci5zZXRJY29uKHRoaXMuX292ZXJyaWRlTWFya2VySWNvbihsYXllcikpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG59KTtcclxuXHJcbkwuTWFya2VyLmluY2x1ZGUoe1xyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZXMgdGhlIGdpdmVuIG9wdGlvbnMgaW4gdGhlIG1hcmtlcidzIGljb24gYW5kIHJlZnJlc2hlcyB0aGUgbWFya2VyLlxyXG5cdCAqIEBwYXJhbSBvcHRpb25zIG1hcCBvYmplY3Qgb2YgaWNvbiBvcHRpb25zLlxyXG5cdCAqIEBwYXJhbSBkaXJlY3RseVJlZnJlc2hDbHVzdGVycyBib29sZWFuIChvcHRpb25hbCkgdHJ1ZSB0byB0cmlnZ2VyXHJcblx0ICogTUNHLnJlZnJlc2hDbHVzdGVyc09mKCkgcmlnaHQgYXdheSB3aXRoIHRoaXMgc2luZ2xlIG1hcmtlci5cclxuXHQgKiBAcmV0dXJucyB7TC5NYXJrZXJ9XHJcblx0ICovXHJcblx0cmVmcmVzaEljb25PcHRpb25zOiBmdW5jdGlvbiAob3B0aW9ucywgZGlyZWN0bHlSZWZyZXNoQ2x1c3RlcnMpIHtcclxuXHRcdHZhciBpY29uID0gdGhpcy5vcHRpb25zLmljb247XHJcblxyXG5cdFx0TC5zZXRPcHRpb25zKGljb24sIG9wdGlvbnMpO1xyXG5cclxuXHRcdHRoaXMuc2V0SWNvbihpY29uKTtcclxuXHJcblx0XHQvLyBTaG9ydGN1dCB0byByZWZyZXNoIHRoZSBhc3NvY2lhdGVkIE1DRyBjbHVzdGVycyByaWdodCBhd2F5LlxyXG5cdFx0Ly8gVG8gYmUgdXNlZCB3aGVuIHJlZnJlc2hpbmcgYSBzaW5nbGUgbWFya2VyLlxyXG5cdFx0Ly8gT3RoZXJ3aXNlLCBiZXR0ZXIgdXNlIE1DRy5yZWZyZXNoQ2x1c3RlcnMoKSBvbmNlIGF0IHRoZSBlbmQgd2l0aFxyXG5cdFx0Ly8gdGhlIGxpc3Qgb2YgbW9kaWZpZWQgbWFya2Vycy5cclxuXHRcdGlmIChkaXJlY3RseVJlZnJlc2hDbHVzdGVycyAmJiB0aGlzLl9fcGFyZW50KSB7XHJcblx0XHRcdHRoaXMuX19wYXJlbnQuX2dyb3VwLnJlZnJlc2hDbHVzdGVycyh0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcbn0pO1xuXG5leHBvcnRzLk1hcmtlckNsdXN0ZXJHcm91cCA9IE1hcmtlckNsdXN0ZXJHcm91cDtcbmV4cG9ydHMuTWFya2VyQ2x1c3RlciA9IE1hcmtlckNsdXN0ZXI7XG5cbn0pKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sZWFmbGV0Lm1hcmtlcmNsdXN0ZXItc3JjLmpzLm1hcFxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/leaflet.markercluster/dist/leaflet.markercluster-src.js\n");

/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n   true ? module.exports : 0\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzPzk2Y2YiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsS0FBSztBQUNMLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0MsV0FBVztBQUNuRDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQyxrQkFBa0I7QUFDbkQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUEsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsS0FBMEIsb0JBQW9CLENBQUU7QUFDbEQ7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxudmFyIHJ1bnRpbWUgPSAoZnVuY3Rpb24gKGV4cG9ydHMpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIE9wID0gT2JqZWN0LnByb3RvdHlwZTtcbiAgdmFyIGhhc093biA9IE9wLmhhc093blByb3BlcnR5O1xuICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cbiAgdmFyICRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgPyBTeW1ib2wgOiB7fTtcbiAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIjtcbiAgdmFyIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIjtcbiAgdmFyIHRvU3RyaW5nVGFnU3ltYm9sID0gJFN5bWJvbC50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjtcblxuICBmdW5jdGlvbiBkZWZpbmUob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gb2JqW2tleV07XG4gIH1cbiAgdHJ5IHtcbiAgICAvLyBJRSA4IGhhcyBhIGJyb2tlbiBPYmplY3QuZGVmaW5lUHJvcGVydHkgdGhhdCBvbmx5IHdvcmtzIG9uIERPTSBvYmplY3RzLlxuICAgIGRlZmluZSh7fSwgXCJcIik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGRlZmluZSA9IGZ1bmN0aW9uKG9iaiwga2V5LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIG9ialtrZXldID0gdmFsdWU7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBJZiBvdXRlckZuIHByb3ZpZGVkIGFuZCBvdXRlckZuLnByb3RvdHlwZSBpcyBhIEdlbmVyYXRvciwgdGhlbiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvci5cbiAgICB2YXIgcHJvdG9HZW5lcmF0b3IgPSBvdXRlckZuICYmIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yID8gb3V0ZXJGbiA6IEdlbmVyYXRvcjtcbiAgICB2YXIgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShwcm90b0dlbmVyYXRvci5wcm90b3R5cGUpO1xuICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pO1xuXG4gICAgLy8gVGhlIC5faW52b2tlIG1ldGhvZCB1bmlmaWVzIHRoZSBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcy5cbiAgICBnZW5lcmF0b3IuX2ludm9rZSA9IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG5cbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9XG4gIGV4cG9ydHMud3JhcCA9IHdyYXA7XG5cbiAgLy8gVHJ5L2NhdGNoIGhlbHBlciB0byBtaW5pbWl6ZSBkZW9wdGltaXphdGlvbnMuIFJldHVybnMgYSBjb21wbGV0aW9uXG4gIC8vIHJlY29yZCBsaWtlIGNvbnRleHQudHJ5RW50cmllc1tpXS5jb21wbGV0aW9uLiBUaGlzIGludGVyZmFjZSBjb3VsZFxuICAvLyBoYXZlIGJlZW4gKGFuZCB3YXMgcHJldmlvdXNseSkgZGVzaWduZWQgdG8gdGFrZSBhIGNsb3N1cmUgdG8gYmVcbiAgLy8gaW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cywgYnV0IGluIGFsbCB0aGUgY2FzZXMgd2UgY2FyZSBhYm91dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYW4gZXhpc3RpbmcgbWV0aG9kIHdlIHdhbnQgdG8gY2FsbCwgc28gdGhlcmUncyBubyBuZWVkXG4gIC8vIHRvIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBvYmplY3QuIFdlIGNhbiBldmVuIGdldCBhd2F5IHdpdGggYXNzdW1pbmdcbiAgLy8gdGhlIG1ldGhvZCB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgc2luY2UgdGhhdCBoYXBwZW5zIHRvIGJlIHRydWVcbiAgLy8gaW4gZXZlcnkgY2FzZSwgc28gd2UgZG9uJ3QgaGF2ZSB0byB0b3VjaCB0aGUgYXJndW1lbnRzIG9iamVjdC4gVGhlXG4gIC8vIG9ubHkgYWRkaXRpb25hbCBhbGxvY2F0aW9uIHJlcXVpcmVkIGlzIHRoZSBjb21wbGV0aW9uIHJlY29yZCwgd2hpY2hcbiAgLy8gaGFzIGEgc3RhYmxlIHNoYXBlIGFuZCBzbyBob3BlZnVsbHkgc2hvdWxkIGJlIGNoZWFwIHRvIGFsbG9jYXRlLlxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJub3JtYWxcIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gXCJzdXNwZW5kZWRTdGFydFwiO1xuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9IFwic3VzcGVuZGVkWWllbGRcIjtcbiAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gXCJleGVjdXRpbmdcIjtcbiAgdmFyIEdlblN0YXRlQ29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjtcblxuICAvLyBSZXR1cm5pbmcgdGhpcyBvYmplY3QgZnJvbSB0aGUgaW5uZXJGbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXG4gIC8vIGJyZWFraW5nIG91dCBvZiB0aGUgZGlzcGF0Y2ggc3dpdGNoIHN0YXRlbWVudC5cbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcblxuICAvLyBEdW1teSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgdGhhdCB3ZSB1c2UgYXMgdGhlIC5jb25zdHJ1Y3RvciBhbmRcbiAgLy8gLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBwcm9wZXJ0aWVzIGZvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gR2VuZXJhdG9yXG4gIC8vIG9iamVjdHMuIEZvciBmdWxsIHNwZWMgY29tcGxpYW5jZSwgeW91IG1heSB3aXNoIHRvIGNvbmZpZ3VyZSB5b3VyXG4gIC8vIG1pbmlmaWVyIG5vdCB0byBtYW5nbGUgdGhlIG5hbWVzIG9mIHRoZXNlIHR3byBmdW5jdGlvbnMuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxuXG4gIC8vIFRoaXMgaXMgYSBwb2x5ZmlsbCBmb3IgJUl0ZXJhdG9yUHJvdG90eXBlJSBmb3IgZW52aXJvbm1lbnRzIHRoYXRcbiAgLy8gZG9uJ3QgbmF0aXZlbHkgc3VwcG9ydCBpdC5cbiAgdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG4gIEl0ZXJhdG9yUHJvdG90eXBlW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICB2YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG4gIHZhciBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvICYmIGdldFByb3RvKGdldFByb3RvKHZhbHVlcyhbXSkpKTtcbiAgaWYgKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICYmXG4gICAgICBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAhPT0gT3AgJiZcbiAgICAgIGhhc093bi5jYWxsKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCkpIHtcbiAgICAvLyBUaGlzIGVudmlyb25tZW50IGhhcyBhIG5hdGl2ZSAlSXRlcmF0b3JQcm90b3R5cGUlOyB1c2UgaXQgaW5zdGVhZFxuICAgIC8vIG9mIHRoZSBwb2x5ZmlsbC5cbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlO1xuICB9XG5cbiAgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID1cbiAgICBHZW5lcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSk7XG4gIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdwLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb247XG4gIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gZGVmaW5lKFxuICAgIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLFxuICAgIHRvU3RyaW5nVGFnU3ltYm9sLFxuICAgIFwiR2VuZXJhdG9yRnVuY3Rpb25cIlxuICApO1xuXG4gIC8vIEhlbHBlciBmb3IgZGVmaW5pbmcgdGhlIC5uZXh0LCAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMgb2YgdGhlXG4gIC8vIEl0ZXJhdG9yIGludGVyZmFjZSBpbiB0ZXJtcyBvZiBhIHNpbmdsZSAuX2ludm9rZSBtZXRob2QuXG4gIGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHtcbiAgICBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgIGRlZmluZShwcm90b3R5cGUsIG1ldGhvZCwgZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICB2YXIgY3RvciA9IHR5cGVvZiBnZW5GdW4gPT09IFwiZnVuY3Rpb25cIiAmJiBnZW5GdW4uY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIGN0b3JcbiAgICAgID8gY3RvciA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHxcbiAgICAgICAgLy8gRm9yIHRoZSBuYXRpdmUgR2VuZXJhdG9yRnVuY3Rpb24gY29uc3RydWN0b3IsIHRoZSBiZXN0IHdlIGNhblxuICAgICAgICAvLyBkbyBpcyB0byBjaGVjayBpdHMgLm5hbWUgcHJvcGVydHkuXG4gICAgICAgIChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkgPT09IFwiR2VuZXJhdG9yRnVuY3Rpb25cIlxuICAgICAgOiBmYWxzZTtcbiAgfTtcblxuICBleHBvcnRzLm1hcmsgPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZ2VuRnVuLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgICAgIGRlZmluZShnZW5GdW4sIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgICBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCk7XG4gICAgcmV0dXJuIGdlbkZ1bjtcbiAgfTtcblxuICAvLyBXaXRoaW4gdGhlIGJvZHkgb2YgYW55IGFzeW5jIGZ1bmN0aW9uLCBgYXdhaXQgeGAgaXMgdHJhbnNmb3JtZWQgdG9cbiAgLy8gYHlpZWxkIHJlZ2VuZXJhdG9yUnVudGltZS5hd3JhcCh4KWAsIHNvIHRoYXQgdGhlIHJ1bnRpbWUgY2FuIHRlc3RcbiAgLy8gYGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIilgIHRvIGRldGVybWluZSBpZiB0aGUgeWllbGRlZCB2YWx1ZSBpc1xuICAvLyBtZWFudCB0byBiZSBhd2FpdGVkLlxuICBleHBvcnRzLmF3cmFwID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHsgX19hd2FpdDogYXJnIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IsIFByb21pc2VJbXBsKSB7XG4gICAgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpO1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgcmVqZWN0KHJlY29yZC5hcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmc7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIikpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZS5fX2F3YWl0KS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJuZXh0XCIsIHZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgaW52b2tlKFwidGhyb3dcIiwgZXJyLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24odW53cmFwcGVkKSB7XG4gICAgICAgICAgLy8gV2hlbiBhIHlpZWxkZWQgUHJvbWlzZSBpcyByZXNvbHZlZCwgaXRzIGZpbmFsIHZhbHVlIGJlY29tZXNcbiAgICAgICAgICAvLyB0aGUgLnZhbHVlIG9mIHRoZSBQcm9taXNlPHt2YWx1ZSxkb25lfT4gcmVzdWx0IGZvciB0aGVcbiAgICAgICAgICAvLyBjdXJyZW50IGl0ZXJhdGlvbi5cbiAgICAgICAgICByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQ7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgIC8vIElmIGEgcmVqZWN0ZWQgUHJvbWlzZSB3YXMgeWllbGRlZCwgdGhyb3cgdGhlIHJlamVjdGlvbiBiYWNrXG4gICAgICAgICAgLy8gaW50byB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIHNvIGl0IGNhbiBiZSBoYW5kbGVkIHRoZXJlLlxuICAgICAgICAgIHJldHVybiBpbnZva2UoXCJ0aHJvd1wiLCBlcnJvciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzUHJvbWlzZTtcblxuICAgIGZ1bmN0aW9uIGVucXVldWUobWV0aG9kLCBhcmcpIHtcbiAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2VJbXBsKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmV2aW91c1Byb21pc2UgPVxuICAgICAgICAvLyBJZiBlbnF1ZXVlIGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byB3YWl0IHVudGlsXG4gICAgICAgIC8vIGFsbCBwcmV2aW91cyBQcm9taXNlcyBoYXZlIGJlZW4gcmVzb2x2ZWQgYmVmb3JlIGNhbGxpbmcgaW52b2tlLFxuICAgICAgICAvLyBzbyB0aGF0IHJlc3VsdHMgYXJlIGFsd2F5cyBkZWxpdmVyZWQgaW4gdGhlIGNvcnJlY3Qgb3JkZXIuIElmXG4gICAgICAgIC8vIGVucXVldWUgaGFzIG5vdCBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gaXQgaXMgaW1wb3J0YW50IHRvXG4gICAgICAgIC8vIGNhbGwgaW52b2tlIGltbWVkaWF0ZWx5LCB3aXRob3V0IHdhaXRpbmcgb24gYSBjYWxsYmFjayB0byBmaXJlLFxuICAgICAgICAvLyBzbyB0aGF0IHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gaGFzIHRoZSBvcHBvcnR1bml0eSB0byBkb1xuICAgICAgICAvLyBhbnkgbmVjZXNzYXJ5IHNldHVwIGluIGEgcHJlZGljdGFibGUgd2F5LiBUaGlzIHByZWRpY3RhYmlsaXR5XG4gICAgICAgIC8vIGlzIHdoeSB0aGUgUHJvbWlzZSBjb25zdHJ1Y3RvciBzeW5jaHJvbm91c2x5IGludm9rZXMgaXRzXG4gICAgICAgIC8vIGV4ZWN1dG9yIGNhbGxiYWNrLCBhbmQgd2h5IGFzeW5jIGZ1bmN0aW9ucyBzeW5jaHJvbm91c2x5XG4gICAgICAgIC8vIGV4ZWN1dGUgY29kZSBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0LiBTaW5jZSB3ZSBpbXBsZW1lbnQgc2ltcGxlXG4gICAgICAgIC8vIGFzeW5jIGZ1bmN0aW9ucyBpbiB0ZXJtcyBvZiBhc3luYyBnZW5lcmF0b3JzLCBpdCBpcyBlc3BlY2lhbGx5XG4gICAgICAgIC8vIGltcG9ydGFudCB0byBnZXQgdGhpcyByaWdodCwgZXZlbiB0aG91Z2ggaXQgcmVxdWlyZXMgY2FyZS5cbiAgICAgICAgcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsXG4gICAgICAgICAgLy8gQXZvaWQgcHJvcGFnYXRpbmcgZmFpbHVyZXMgdG8gUHJvbWlzZXMgcmV0dXJuZWQgYnkgbGF0ZXJcbiAgICAgICAgICAvLyBpbnZvY2F0aW9ucyBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmdcbiAgICAgICAgKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7XG4gICAgfVxuXG4gICAgLy8gRGVmaW5lIHRoZSB1bmlmaWVkIGhlbHBlciBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIGltcGxlbWVudCAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIChzZWUgZGVmaW5lSXRlcmF0b3JNZXRob2RzKS5cbiAgICB0aGlzLl9pbnZva2UgPSBlbnF1ZXVlO1xuICB9XG5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKTtcbiAgQXN5bmNJdGVyYXRvci5wcm90b3R5cGVbYXN5bmNJdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIGV4cG9ydHMuQXN5bmNJdGVyYXRvciA9IEFzeW5jSXRlcmF0b3I7XG5cbiAgLy8gTm90ZSB0aGF0IHNpbXBsZSBhc3luYyBmdW5jdGlvbnMgYXJlIGltcGxlbWVudGVkIG9uIHRvcCBvZlxuICAvLyBBc3luY0l0ZXJhdG9yIG9iamVjdHM7IHRoZXkganVzdCByZXR1cm4gYSBQcm9taXNlIGZvciB0aGUgdmFsdWUgb2ZcbiAgLy8gdGhlIGZpbmFsIHJlc3VsdCBwcm9kdWNlZCBieSB0aGUgaXRlcmF0b3IuXG4gIGV4cG9ydHMuYXN5bmMgPSBmdW5jdGlvbihpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCwgUHJvbWlzZUltcGwpIHtcbiAgICBpZiAoUHJvbWlzZUltcGwgPT09IHZvaWQgMCkgUHJvbWlzZUltcGwgPSBQcm9taXNlO1xuXG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcihcbiAgICAgIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpLFxuICAgICAgUHJvbWlzZUltcGxcbiAgICApO1xuXG4gICAgcmV0dXJuIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKVxuICAgICAgPyBpdGVyIC8vIElmIG91dGVyRm4gaXMgYSBnZW5lcmF0b3IsIHJldHVybiB0aGUgZnVsbCBpdGVyYXRvci5cbiAgICAgIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTtcbiAgICAgICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7XG4gICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcblxuICAgIHJldHVybiBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVFeGVjdXRpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUNvbXBsZXRlZCkge1xuICAgICAgICBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCZSBmb3JnaXZpbmcsIHBlciAyNS4zLjMuMy4zIG9mIHRoZSBzcGVjOlxuICAgICAgICAvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtZ2VuZXJhdG9ycmVzdW1lXG4gICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQubWV0aG9kID0gbWV0aG9kO1xuICAgICAgY29udGV4dC5hcmcgPSBhcmc7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XG4gICAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICAgIHZhciBkZWxlZ2F0ZVJlc3VsdCA9IG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0ID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTtcbiAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZVJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgLy8gU2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICBjb250ZXh0LnNlbnQgPSBjb250ZXh0Ll9zZW50ID0gY29udGV4dC5hcmc7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0KSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgICAgdGhyb3cgY29udGV4dC5hcmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZyk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGNvbnRleHQuYXJnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlID0gR2VuU3RhdGVFeGVjdXRpbmc7XG5cbiAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgICAvLyBJZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGZyb20gaW5uZXJGbiwgd2UgbGVhdmUgc3RhdGUgPT09XG4gICAgICAgICAgLy8gR2VuU3RhdGVFeGVjdXRpbmcgYW5kIGxvb3AgYmFjayBmb3IgYW5vdGhlciBpbnZvY2F0aW9uLlxuICAgICAgICAgIHN0YXRlID0gY29udGV4dC5kb25lXG4gICAgICAgICAgICA/IEdlblN0YXRlQ29tcGxldGVkXG4gICAgICAgICAgICA6IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG5cbiAgICAgICAgICBpZiAocmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLFxuICAgICAgICAgICAgZG9uZTogY29udGV4dC5kb25lXG4gICAgICAgICAgfTtcblxuICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgIC8vIERpc3BhdGNoIHRoZSBleGNlcHRpb24gYnkgbG9vcGluZyBiYWNrIGFyb3VuZCB0byB0aGVcbiAgICAgICAgICAvLyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKSBjYWxsIGFib3ZlLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBDYWxsIGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXShjb250ZXh0LmFyZykgYW5kIGhhbmRsZSB0aGVcbiAgLy8gcmVzdWx0LCBlaXRoZXIgYnkgcmV0dXJuaW5nIGEgeyB2YWx1ZSwgZG9uZSB9IHJlc3VsdCBmcm9tIHRoZVxuICAvLyBkZWxlZ2F0ZSBpdGVyYXRvciwgb3IgYnkgbW9kaWZ5aW5nIGNvbnRleHQubWV0aG9kIGFuZCBjb250ZXh0LmFyZyxcbiAgLy8gc2V0dGluZyBjb250ZXh0LmRlbGVnYXRlIHRvIG51bGwsIGFuZCByZXR1cm5pbmcgdGhlIENvbnRpbnVlU2VudGluZWwuXG4gIGZ1bmN0aW9uIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgbWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdO1xuICAgIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gQSAudGhyb3cgb3IgLnJldHVybiB3aGVuIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgbm8gLnRocm93XG4gICAgICAvLyBtZXRob2QgYWx3YXlzIHRlcm1pbmF0ZXMgdGhlIHlpZWxkKiBsb29wLlxuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIC8vIE5vdGU6IFtcInJldHVyblwiXSBtdXN0IGJlIHVzZWQgZm9yIEVTMyBwYXJzaW5nIGNvbXBhdGliaWxpdHkuXG4gICAgICAgIGlmIChkZWxlZ2F0ZS5pdGVyYXRvcltcInJldHVyblwiXSkge1xuICAgICAgICAgIC8vIElmIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgYSByZXR1cm4gbWV0aG9kLCBnaXZlIGl0IGFcbiAgICAgICAgICAvLyBjaGFuY2UgdG8gY2xlYW4gdXAuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuXG4gICAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIC8vIElmIG1heWJlSW52b2tlRGVsZWdhdGUoY29udGV4dCkgY2hhbmdlZCBjb250ZXh0Lm1ldGhvZCBmcm9tXG4gICAgICAgICAgICAvLyBcInJldHVyblwiIHRvIFwidGhyb3dcIiwgbGV0IHRoYXQgb3ZlcnJpZGUgdGhlIFR5cGVFcnJvciBiZWxvdy5cbiAgICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICd0aHJvdycgbWV0aG9kXCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gobWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgY29udGV4dC5hcmcpO1xuXG4gICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgaW5mbyA9IHJlY29yZC5hcmc7XG5cbiAgICBpZiAoISBpbmZvKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIml0ZXJhdG9yIHJlc3VsdCBpcyBub3QgYW4gb2JqZWN0XCIpO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICAvLyBBc3NpZ24gdGhlIHJlc3VsdCBvZiB0aGUgZmluaXNoZWQgZGVsZWdhdGUgdG8gdGhlIHRlbXBvcmFyeVxuICAgICAgLy8gdmFyaWFibGUgc3BlY2lmaWVkIGJ5IGRlbGVnYXRlLnJlc3VsdE5hbWUgKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlO1xuXG4gICAgICAvLyBSZXN1bWUgZXhlY3V0aW9uIGF0IHRoZSBkZXNpcmVkIGxvY2F0aW9uIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jO1xuXG4gICAgICAvLyBJZiBjb250ZXh0Lm1ldGhvZCB3YXMgXCJ0aHJvd1wiIGJ1dCB0aGUgZGVsZWdhdGUgaGFuZGxlZCB0aGVcbiAgICAgIC8vIGV4Y2VwdGlvbiwgbGV0IHRoZSBvdXRlciBnZW5lcmF0b3IgcHJvY2VlZCBub3JtYWxseS4gSWZcbiAgICAgIC8vIGNvbnRleHQubWV0aG9kIHdhcyBcIm5leHRcIiwgZm9yZ2V0IGNvbnRleHQuYXJnIHNpbmNlIGl0IGhhcyBiZWVuXG4gICAgICAvLyBcImNvbnN1bWVkXCIgYnkgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yLiBJZiBjb250ZXh0Lm1ldGhvZCB3YXNcbiAgICAgIC8vIFwicmV0dXJuXCIsIGFsbG93IHRoZSBvcmlnaW5hbCAucmV0dXJuIGNhbGwgdG8gY29udGludWUgaW4gdGhlXG4gICAgICAvLyBvdXRlciBnZW5lcmF0b3IuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgIT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmUteWllbGQgdGhlIHJlc3VsdCByZXR1cm5lZCBieSB0aGUgZGVsZWdhdGUgbWV0aG9kLlxuICAgICAgcmV0dXJuIGluZm87XG4gICAgfVxuXG4gICAgLy8gVGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGlzIGZpbmlzaGVkLCBzbyBmb3JnZXQgaXQgYW5kIGNvbnRpbnVlIHdpdGhcbiAgICAvLyB0aGUgb3V0ZXIgZ2VuZXJhdG9yLlxuICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICB9XG5cbiAgLy8gRGVmaW5lIEdlbmVyYXRvci5wcm90b3R5cGUue25leHQsdGhyb3cscmV0dXJufSBpbiB0ZXJtcyBvZiB0aGVcbiAgLy8gdW5pZmllZCAuX2ludm9rZSBoZWxwZXIgbWV0aG9kLlxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApO1xuXG4gIGRlZmluZShHcCwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yXCIpO1xuXG4gIC8vIEEgR2VuZXJhdG9yIHNob3VsZCBhbHdheXMgcmV0dXJuIGl0c2VsZiBhcyB0aGUgaXRlcmF0b3Igb2JqZWN0IHdoZW4gdGhlXG4gIC8vIEBAaXRlcmF0b3IgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGl0LiBTb21lIGJyb3dzZXJzJyBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlXG4gIC8vIGl0ZXJhdG9yIHByb3RvdHlwZSBjaGFpbiBpbmNvcnJlY3RseSBpbXBsZW1lbnQgdGhpcywgY2F1c2luZyB0aGUgR2VuZXJhdG9yXG4gIC8vIG9iamVjdCB0byBub3QgYmUgcmV0dXJuZWQgZnJvbSB0aGlzIGNhbGwuIFRoaXMgZW5zdXJlcyB0aGF0IGRvZXNuJ3QgaGFwcGVuLlxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL2lzc3Vlcy8yNzQgZm9yIG1vcmUgZGV0YWlscy5cbiAgR3BbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgR3AudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcbiAgfTtcblxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xuICAgIHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07XG5cbiAgICBpZiAoMSBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV07XG4gICAgfVxuXG4gICAgaWYgKDIgaW4gbG9jcykge1xuICAgICAgZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl07XG4gICAgICBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM107XG4gICAgfVxuXG4gICAgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xuICAgIHJlY29yZC50eXBlID0gXCJub3JtYWxcIjtcbiAgICBkZWxldGUgcmVjb3JkLmFyZztcbiAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAgIC8vIFRoZSByb290IGVudHJ5IG9iamVjdCAoZWZmZWN0aXZlbHkgYSB0cnkgc3RhdGVtZW50IHdpdGhvdXQgYSBjYXRjaFxuICAgIC8vIG9yIGEgZmluYWxseSBibG9jaykgZ2l2ZXMgdXMgYSBwbGFjZSB0byBzdG9yZSB2YWx1ZXMgdGhyb3duIGZyb21cbiAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XTtcbiAgICB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyk7XG4gICAgdGhpcy5yZXNldCh0cnVlKTtcbiAgfVxuXG4gIGV4cG9ydHMua2V5cyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICAgIGtleXMucmV2ZXJzZSgpO1xuXG4gICAgLy8gUmF0aGVyIHRoYW4gcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIGEgbmV4dCBtZXRob2QsIHdlIGtlZXBcbiAgICAvLyB0aGluZ3Mgc2ltcGxlIGFuZCByZXR1cm4gdGhlIG5leHQgZnVuY3Rpb24gaXRzZWxmLlxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgd2hpbGUgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzLnBvcCgpO1xuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgIG5leHQudmFsdWUgPSBrZXk7XG4gICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVG8gYXZvaWQgY3JlYXRpbmcgYW4gYWRkaXRpb25hbCBvYmplY3QsIHdlIGp1c3QgaGFuZyB0aGUgLnZhbHVlXG4gICAgICAvLyBhbmQgLmRvbmUgcHJvcGVydGllcyBvZmYgdGhlIG5leHQgZnVuY3Rpb24gb2JqZWN0IGl0c2VsZi4gVGhpc1xuICAgICAgLy8gYWxzbyBlbnN1cmVzIHRoYXQgdGhlIG1pbmlmaWVyIHdpbGwgbm90IGFub255bWl6ZSB0aGUgZnVuY3Rpb24uXG4gICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUpIHtcbiAgICAgIHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTtcbiAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmFibGUubmV4dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBpdGVyYWJsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBpID0gLTEsIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBpdGVyYWJsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHtcbiAgICAgICAgICAgICAgbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldO1xuICAgICAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV4dC52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGFuIGl0ZXJhdG9yIHdpdGggbm8gdmFsdWVzLlxuICAgIHJldHVybiB7IG5leHQ6IGRvbmVSZXN1bHQgfTtcbiAgfVxuICBleHBvcnRzLnZhbHVlcyA9IHZhbHVlcztcblxuICBmdW5jdGlvbiBkb25lUmVzdWx0KCkge1xuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgfVxuXG4gIENvbnRleHQucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBDb250ZXh0LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKHNraXBUZW1wUmVzZXQpIHtcbiAgICAgIHRoaXMucHJldiA9IDA7XG4gICAgICB0aGlzLm5leHQgPSAwO1xuICAgICAgLy8gUmVzZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICB0aGlzLmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuXG4gICAgICB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KTtcblxuICAgICAgaWYgKCFza2lwVGVtcFJlc2V0KSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcykge1xuICAgICAgICAgIC8vIE5vdCBzdXJlIGFib3V0IHRoZSBvcHRpbWFsIG9yZGVyIG9mIHRoZXNlIGNvbmRpdGlvbnM6XG4gICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSBcInRcIiAmJlxuICAgICAgICAgICAgICBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJlxuICAgICAgICAgICAgICAhaXNOYU4oK25hbWUuc2xpY2UoMSkpKSB7XG4gICAgICAgICAgICB0aGlzW25hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG5cbiAgICAgIHZhciByb290RW50cnkgPSB0aGlzLnRyeUVudHJpZXNbMF07XG4gICAgICB2YXIgcm9vdFJlY29yZCA9IHJvb3RFbnRyeS5jb21wbGV0aW9uO1xuICAgICAgaWYgKHJvb3RSZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJvb3RSZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5ydmFsO1xuICAgIH0sXG5cbiAgICBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24oZXhjZXB0aW9uKSB7XG4gICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuICAgICAgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7XG4gICAgICAgIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiO1xuICAgICAgICByZWNvcmQuYXJnID0gZXhjZXB0aW9uO1xuICAgICAgICBjb250ZXh0Lm5leHQgPSBsb2M7XG5cbiAgICAgICAgaWYgKGNhdWdodCkge1xuICAgICAgICAgIC8vIElmIHRoZSBkaXNwYXRjaGVkIGV4Y2VwdGlvbiB3YXMgY2F1Z2h0IGJ5IGEgY2F0Y2ggYmxvY2ssXG4gICAgICAgICAgLy8gdGhlbiBsZXQgdGhhdCBjYXRjaCBibG9jayBoYW5kbGUgdGhlIGV4Y2VwdGlvbiBub3JtYWxseS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICEhIGNhdWdodDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IFwicm9vdFwiKSB7XG4gICAgICAgICAgLy8gRXhjZXB0aW9uIHRocm93biBvdXRzaWRlIG9mIGFueSB0cnkgYmxvY2sgdGhhdCBjb3VsZCBoYW5kbGVcbiAgICAgICAgICAvLyBpdCwgc28gc2V0IHRoZSBjb21wbGV0aW9uIHZhbHVlIG9mIHRoZSBlbnRpcmUgZnVuY3Rpb24gdG9cbiAgICAgICAgICAvLyB0aHJvdyB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJldHVybiBoYW5kbGUoXCJlbmRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikge1xuICAgICAgICAgIHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpO1xuICAgICAgICAgIHZhciBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKTtcblxuICAgICAgICAgIGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYWJydXB0OiBmdW5jdGlvbih0eXBlLCBhcmcpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKSAmJlxuICAgICAgICAgICAgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgIHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZmluYWxseUVudHJ5ICYmXG4gICAgICAgICAgKHR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgICB0eXBlID09PSBcImNvbnRpbnVlXCIpICYmXG4gICAgICAgICAgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiZcbiAgICAgICAgICBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgLy8gSWdub3JlIHRoZSBmaW5hbGx5IGVudHJ5IGlmIGNvbnRyb2wgaXMgbm90IGp1bXBpbmcgdG8gYVxuICAgICAgICAvLyBsb2NhdGlvbiBvdXRzaWRlIHRoZSB0cnkvY2F0Y2ggYmxvY2suXG4gICAgICAgIGZpbmFsbHlFbnRyeSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9O1xuICAgICAgcmVjb3JkLnR5cGUgPSB0eXBlO1xuICAgICAgcmVjb3JkLmFyZyA9IGFyZztcblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSkge1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYztcbiAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XG4gICAgfSxcblxuICAgIGNvbXBsZXRlOiBmdW5jdGlvbihyZWNvcmQsIGFmdGVyTG9jKSB7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgIHJlY29yZC50eXBlID09PSBcImNvbnRpbnVlXCIpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gcmVjb3JkLmFyZztcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgdGhpcy5ydmFsID0gdGhpcy5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgIHRoaXMubmV4dCA9IFwiZW5kXCI7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiICYmIGFmdGVyTG9jKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IGFmdGVyTG9jO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9LFxuXG4gICAgZmluaXNoOiBmdW5jdGlvbihmaW5hbGx5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKTtcbiAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBcImNhdGNoXCI6IGZ1bmN0aW9uKHRyeUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykge1xuICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICB2YXIgdGhyb3duID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhyb3duO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBjb250ZXh0LmNhdGNoIG1ldGhvZCBtdXN0IG9ubHkgYmUgY2FsbGVkIHdpdGggYSBsb2NhdGlvblxuICAgICAgLy8gYXJndW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byBhIGtub3duIGNhdGNoIGJsb2NrLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpO1xuICAgIH0sXG5cbiAgICBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbihpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykge1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IHtcbiAgICAgICAgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksXG4gICAgICAgIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsXG4gICAgICAgIG5leHRMb2M6IG5leHRMb2NcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgLy8gRGVsaWJlcmF0ZWx5IGZvcmdldCB0aGUgbGFzdCBzZW50IHZhbHVlIHNvIHRoYXQgd2UgZG9uJ3RcbiAgICAgICAgLy8gYWNjaWRlbnRhbGx5IHBhc3MgaXQgb24gdG8gdGhlIGRlbGVnYXRlLlxuICAgICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuICB9O1xuXG4gIC8vIFJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGlzIHNjcmlwdCBpcyBleGVjdXRpbmcgYXMgYSBDb21tb25KUyBtb2R1bGVcbiAgLy8gb3Igbm90LCByZXR1cm4gdGhlIHJ1bnRpbWUgb2JqZWN0IHNvIHRoYXQgd2UgY2FuIGRlY2xhcmUgdGhlIHZhcmlhYmxlXG4gIC8vIHJlZ2VuZXJhdG9yUnVudGltZSBpbiB0aGUgb3V0ZXIgc2NvcGUsIHdoaWNoIGFsbG93cyB0aGlzIG1vZHVsZSB0byBiZVxuICAvLyBpbmplY3RlZCBlYXNpbHkgYnkgYGJpbi9yZWdlbmVyYXRvciAtLWluY2x1ZGUtcnVudGltZSBzY3JpcHQuanNgLlxuICByZXR1cm4gZXhwb3J0cztcblxufShcbiAgLy8gSWYgdGhpcyBzY3JpcHQgaXMgZXhlY3V0aW5nIGFzIGEgQ29tbW9uSlMgbW9kdWxlLCB1c2UgbW9kdWxlLmV4cG9ydHNcbiAgLy8gYXMgdGhlIHJlZ2VuZXJhdG9yUnVudGltZSBuYW1lc3BhY2UuIE90aGVyd2lzZSBjcmVhdGUgYSBuZXcgZW1wdHlcbiAgLy8gb2JqZWN0LiBFaXRoZXIgd2F5LCB0aGUgcmVzdWx0aW5nIG9iamVjdCB3aWxsIGJlIHVzZWQgdG8gaW5pdGlhbGl6ZVxuICAvLyB0aGUgcmVnZW5lcmF0b3JSdW50aW1lIHZhcmlhYmxlIGF0IHRoZSB0b3Agb2YgdGhpcyBmaWxlLlxuICB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiID8gbW9kdWxlLmV4cG9ydHMgOiB7fVxuKSk7XG5cbnRyeSB7XG4gIHJlZ2VuZXJhdG9yUnVudGltZSA9IHJ1bnRpbWU7XG59IGNhdGNoIChhY2NpZGVudGFsU3RyaWN0TW9kZSkge1xuICAvLyBUaGlzIG1vZHVsZSBzaG91bGQgbm90IGJlIHJ1bm5pbmcgaW4gc3RyaWN0IG1vZGUsIHNvIHRoZSBhYm92ZVxuICAvLyBhc3NpZ25tZW50IHNob3VsZCBhbHdheXMgd29yayB1bmxlc3Mgc29tZXRoaW5nIGlzIG1pc2NvbmZpZ3VyZWQuIEp1c3RcbiAgLy8gaW4gY2FzZSBydW50aW1lLmpzIGFjY2lkZW50YWxseSBydW5zIGluIHN0cmljdCBtb2RlLCB3ZSBjYW4gZXNjYXBlXG4gIC8vIHN0cmljdCBtb2RlIHVzaW5nIGEgZ2xvYmFsIEZ1bmN0aW9uIGNhbGwuIFRoaXMgY291bGQgY29uY2VpdmFibHkgZmFpbFxuICAvLyBpZiBhIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5IGZvcmJpZHMgdXNpbmcgRnVuY3Rpb24sIGJ1dCBpbiB0aGF0IGNhc2VcbiAgLy8gdGhlIHByb3BlciBzb2x1dGlvbiBpcyB0byBmaXggdGhlIGFjY2lkZW50YWwgc3RyaWN0IG1vZGUgcHJvYmxlbS4gSWZcbiAgLy8geW91J3ZlIG1pc2NvbmZpZ3VyZWQgeW91ciBidW5kbGVyIHRvIGZvcmNlIHN0cmljdCBtb2RlIGFuZCBhcHBsaWVkIGFcbiAgLy8gQ1NQIHRvIGZvcmJpZCBGdW5jdGlvbiwgYW5kIHlvdSdyZSBub3Qgd2lsbGluZyB0byBmaXggZWl0aGVyIG9mIHRob3NlXG4gIC8vIHByb2JsZW1zLCBwbGVhc2UgZGV0YWlsIHlvdXIgdW5pcXVlIHByZWRpY2FtZW50IGluIGEgR2l0SHViIGlzc3VlLlxuICBGdW5jdGlvbihcInJcIiwgXCJyZWdlbmVyYXRvclJ1bnRpbWUgPSByXCIpKHJ1bnRpbWUpO1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/regenerator-runtime/runtime.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => module['default'] :
/******/ 				() => module;
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	// startup
/******/ 	// Load entry module
/******/ 	__webpack_require__("./resources/js/map.js");
/******/ 	// This entry module used 'exports' so it can't be inlined
/******/ })()
;